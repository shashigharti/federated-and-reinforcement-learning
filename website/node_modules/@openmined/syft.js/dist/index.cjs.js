'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tf = require('@tensorflow/tfjs-core');

// Sockets
var SOCKET_STATUS = 'socket-status';
var SOCKET_PING = 'socket-ping'; // Grid

var GET_PROTOCOL = 'get-protocol';
var CYCLE_STATUS_ACCEPTED = 'accepted';
var CYCLE_STATUS_REJECTED = 'rejected'; // WebRTC

var WEBRTC_JOIN_ROOM = 'webrtc: join-room';
var WEBRTC_INTERNAL_MESSAGE = 'webrtc: internal-message';
var WEBRTC_PEER_LEFT = 'webrtc: peer-left'; // WebRTC: Data Channel

var WEBRTC_DATACHANNEL_CHUNK_SIZE = 64 * 1024;
var WEBRTC_DATACHANNEL_MAX_BUFFER = 4 * 1024 * 1024;
var WEBRTC_DATACHANNEL_BUFFER_TIMEOUT = 2000;
var WEBRTC_DATACHANNEL_MAX_BUFFER_TIMEOUTS = 5;
var WEBRTC_PEER_CONFIG = {
  iceServers: [{
    urls: ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302' // FF says too many stuns are bad, don't send more than this
    ]
  }]
};
var WEBRTC_PEER_OPTIONS = {
  optional: [{
    DtlsSrtpKeyAgreement: true
  } // Required for connection between Chrome and Firefox
  // FF works w/o this option, but Chrome fails with it
  // { RtpDataChannels: true } // Required in Firefox to use the DataChannels API
  ]
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var EventObserver = /*#__PURE__*/function () {
  function EventObserver() {
    _classCallCheck(this, EventObserver);

    this.observers = [];
  }

  _createClass(EventObserver, [{
    key: "subscribe",
    value: function subscribe(type, func) {
      this.observers.push({
        type: type,
        func: func
      });
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(eventType) {
      this.observers = this.observers.filter(function (_ref) {
        var type = _ref.type;
        return eventType !== type;
      });
    }
  }, {
    key: "broadcast",
    value: function broadcast(eventType, data) {
      this.observers.forEach(function (observer) {
        if (eventType === observer.type) {
          return observer.func(data);
        }
      });
    }
  }]);

  return EventObserver;
}();

// A simple logging function
var Logger = /*#__PURE__*/function () {
  function Logger(system, verbose) {
    _classCallCheck(this, Logger);

    if (!Logger.instance) {
      this.system = system;
      this.verbose = verbose;
      Logger.instance = this;
    }

    return Logger.instance;
  }

  _createClass(Logger, [{
    key: "log",
    value: function log(message, data) {
      // Only log if verbose is turned on
      if (this.verbose) {
        var output = "".concat(Date.now(), ": ").concat(this.system, " - ").concat(message); // Have the passed additional data?

        if (data) {
          console.log(output, data);
        } else {
          console.log(output);
        }
      }
    }
  }]);

  return Logger;
}();

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var crypto = {};

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$1.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
var _kMaxLength = kMaxLength();

function kMaxLength () {
  return Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$1 (arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer$1.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$1.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$1.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer$1.alloc(+length)
}
Buffer$1.isBuffer = isBuffer;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$1.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$1.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$1.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$1.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$1.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$1.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$1.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$1.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$1.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$1.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$1.compare(this, b) === 0
};

Buffer$1.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$1.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$1.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var bufferEs6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
  kMaxLength: _kMaxLength,
  Buffer: Buffer$1,
  SlowBuffer: SlowBuffer,
  isBuffer: isBuffer
});

var safeBuffer = createCommonjsModule(function (module, exports) {
/* eslint-disable node/no-deprecated-api */

var Buffer = bufferEs6.Buffer;

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = bufferEs6;
} else {
  // Copy properties from require('buffer')
  copyProps(bufferEs6, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return bufferEs6.SlowBuffer(size)
};
});

var randombytes = crypto.randomBytes;

var browser = createCommonjsModule(function (module, exports) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}


var Buffer = safeBuffer.Buffer;
var kBufferMaxLength = safeBuffer.kMaxLength;
var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
var kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill;
  exports.randomFillSync = randomFillSync;
} else {
  exports.randomFill = oldBrowser;
  exports.randomFillSync = oldBrowser;
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset;
    offset = 0;
    size = buf.length;
  } else if (typeof size === 'function') {
    cb = size;
    size = buf.length - offset;
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length);
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer;
    var uint = new Uint8Array(ourBuf, offset, size);
    crypto.getRandomValues(uint);
    if (cb) {
      process.nextTick(function () {
        cb(null, buf);
      });
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset);
      cb(null, buf);
    });
    return
  }
  var bytes = randombytes(size);
  bytes.copy(buf, offset);
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0;
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length);

  if (size === undefined) size = buf.length - offset;

  assertSize(size, offset, buf.length);

  return actualFill(buf, offset, size)
}
});

var randomfill = createCommonjsModule(function (module, exports) {
{
  module.exports = browser;
}
});

var SpeedTest = /*#__PURE__*/function () {
  function SpeedTest(_ref) {
    var downloadUrl = _ref.downloadUrl,
        uploadUrl = _ref.uploadUrl,
        pingUrl = _ref.pingUrl,
        _ref$maxUploadSizeMb = _ref.maxUploadSizeMb,
        maxUploadSizeMb = _ref$maxUploadSizeMb === void 0 ? 64 : _ref$maxUploadSizeMb,
        _ref$maxTestTimeSec = _ref.maxTestTimeSec,
        maxTestTimeSec = _ref$maxTestTimeSec === void 0 ? 10 : _ref$maxTestTimeSec;

    _classCallCheck(this, SpeedTest);

    this.downloadUrl = downloadUrl;
    this.uploadUrl = uploadUrl;
    this.pingUrl = pingUrl;
    this.maxUploadSizeMb = maxUploadSizeMb;
    this.maxTestTimeSec = maxTestTimeSec; // Various settings to tune.

    this.bwAvgWindow = 5;
    this.bwLowJitterThreshold = 0.05;
    this.bwMaxLowJitterConsecutiveMeasures = 5;
  }

  _createClass(SpeedTest, [{
    key: "meterXhr",
    value: function () {
      var _meterXhr = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(xhr) {
        var _this = this;

        var isUpload,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                isUpload = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  var timeoutHandler = null,
                      prevTime = 0,
                      prevSize = 0,
                      avgCollector = new AvgCollector({
                    avgWindow: _this.bwAvgWindow,
                    lowJitterThreshold: _this.bwLowJitterThreshold,
                    maxLowJitterConsecutiveMeasures: _this.bwMaxLowJitterConsecutiveMeasures
                  });
                  var req = isUpload ? xhr.upload : xhr;

                  var finish = function finish() {
                    var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

                    if (timeoutHandler) {
                      clearTimeout(timeoutHandler);
                    } // clean up


                    req.onprogress = null;
                    req.onload = null;
                    req.onerror = null;
                    xhr.abort();

                    if (!error) {
                      resolve(avgCollector.getAvg());
                    } else {
                      reject(new Error(error));
                    }
                  };

                  req.onreadystatechange = function () {
                    if (xhr.readyState === 1) {
                      // set speed test timeout
                      timeoutHandler = setTimeout(finish, _this.maxTestTimeSec * 1000);
                    }
                  };

                  req.onprogress = function (e) {
                    var // mbit
                    size = 8 * e.loaded / 1048576,
                        // seconds
                    time = Date.now() / 1000;

                    if (!prevTime) {
                      prevTime = time;
                      prevSize = size;
                      return;
                    }

                    var deltaSize = size - prevSize,
                        deltaTime = time - prevTime,
                        speed = deltaSize / deltaTime;
                    var canStop = avgCollector.collect(speed);

                    if (canStop) {
                      finish();
                    }

                    prevSize = size;
                    prevTime = time;
                  };

                  req.onload = function () {
                    finish();
                  };

                  req.onerror = function (e) {
                    finish(e);
                  };
                }));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function meterXhr(_x) {
        return _meterXhr.apply(this, arguments);
      }

      return meterXhr;
    }()
  }, {
    key: "getDownloadSpeed",
    value: function () {
      var _getDownloadSpeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var xhr, result;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                xhr = new XMLHttpRequest();
                result = this.meterXhr(xhr);
                xhr.open('GET', this.downloadUrl + '?' + Math.random(), true);
                xhr.send();
                return _context2.abrupt("return", result);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getDownloadSpeed() {
        return _getDownloadSpeed.apply(this, arguments);
      }

      return getDownloadSpeed;
    }()
  }, {
    key: "getUploadSpeed",
    value: function () {
      var _getUploadSpeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var xhr, result, buff, maxRandomChunkSize, chunkNum, chunk, offset;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                xhr = new XMLHttpRequest();
                result = this.meterXhr(xhr, true); // Create random bytes buffer.

                buff = new Uint8Array(this.maxUploadSizeMb * 1024 * 1024);
                maxRandomChunkSize = 65536;
                chunkNum = Math.ceil(buff.byteLength / maxRandomChunkSize);

                for (chunk = 0, offset = 0; chunk < chunkNum; chunk++, offset += maxRandomChunkSize) {
                  randomfill.randomFillSync(buff, offset, Math.min(maxRandomChunkSize, buff.byteLength - offset));
                }

                xhr.open('POST', this.uploadUrl, true);
                xhr.send(buff);
                return _context3.abrupt("return", result);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getUploadSpeed() {
        return _getUploadSpeed.apply(this, arguments);
      }

      return getUploadSpeed;
    }()
  }, {
    key: "getPing",
    value: function () {
      var _getPing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", new Promise(function (resolve, reject) {
                  var avgCollector = new AvgCollector({});
                  var currXhr;
                  var timeoutHandler;

                  var finish = function finish(xhr) {
                    var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

                    if (timeoutHandler) {
                      clearTimeout(timeoutHandler);
                    } // clean up


                    xhr.onprogress = null;
                    xhr.onload = null;
                    xhr.onerror = null;
                    xhr.abort();

                    if (!error) {
                      resolve(avgCollector.getAvg());
                    } else {
                      reject(new Error(error));
                    }
                  };

                  var runPing = function runPing() {
                    var xhr = new XMLHttpRequest();
                    currXhr = xhr;
                    var startTime = Date.now();

                    xhr.onload = function () {
                      var ping = Date.now() - startTime;
                      var canStop = avgCollector.collect(ping);

                      if (canStop) {
                        finish(xhr);
                      } else {
                        setTimeout(runPing, 0);
                      }
                    };

                    xhr.onerror = function (e) {
                      finish(xhr, e);
                    };

                    xhr.open('GET', _this2.pingUrl + '?' + Math.random(), true);
                    xhr.send();
                  };

                  timeoutHandler = setTimeout(function () {
                    finish(currXhr);
                  }, _this2.maxTestTimeSec * 1000);
                  runPing();
                }));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function getPing() {
        return _getPing.apply(this, arguments);
      }

      return getPing;
    }()
  }]);

  return SpeedTest;
}();
/**
 * Helper to average series of values
 */

var AvgCollector = /*#__PURE__*/function () {
  function AvgCollector(_ref2) {
    var _ref2$avgWindow = _ref2.avgWindow,
        avgWindow = _ref2$avgWindow === void 0 ? 5 : _ref2$avgWindow,
        _ref2$lowJitterThresh = _ref2.lowJitterThreshold,
        lowJitterThreshold = _ref2$lowJitterThresh === void 0 ? 0.05 : _ref2$lowJitterThresh,
        _ref2$maxLowJitterCon = _ref2.maxLowJitterConsecutiveMeasures,
        maxLowJitterConsecutiveMeasures = _ref2$maxLowJitterCon === void 0 ? 5 : _ref2$maxLowJitterCon;

    _classCallCheck(this, AvgCollector);

    this.measuresCount = 0;
    this.prevAvg = 0;
    this.avg = 0;
    this.lowJitterConsecutiveMeasures = 0;
    this.avgWindow = avgWindow;
    this.lowJitterThreshold = lowJitterThreshold;
    this.maxLowJitterConsecutiveMeasures = maxLowJitterConsecutiveMeasures;
    this.name = name;
  }

  _createClass(AvgCollector, [{
    key: "collect",
    value: function collect(value) {
      this.prevAvg = this.avg;
      var avgWindow = Math.min(this.measuresCount, this.avgWindow);
      this.avg = (this.avg * avgWindow + value) / (avgWindow + 1);
      this.measuresCount++; // Return true if measurements are stable.

      if (this.prevAvg > 0 && this.avg < this.prevAvg * (1 + this.lowJitterThreshold) && this.avg > this.prevAvg * (1 - this.lowJitterThreshold)) {
        this.lowJitterConsecutiveMeasures++;
      } else {
        this.lowJitterConsecutiveMeasures = 0;
      }

      if (this.lowJitterConsecutiveMeasures >= this.maxLowJitterConsecutiveMeasures) {
        return true;
      }

      return false;
    }
  }, {
    key: "getAvg",
    value: function getAvg() {
      return this.avg;
    }
  }]);

  return AvgCollector;
}();

var HTTP_PATH_VERB = {
  'federated/get-plan': 'GET',
  'federated/get-model': 'GET',
  'federated/get-protocol': 'GET',
  'federated/cycle-request': 'POST',
  'federated/report': 'POST'
};

var GridAPIClient = /*#__PURE__*/function () {
  function GridAPIClient(_ref) {
    var url = _ref.url,
        _ref$allowInsecureUrl = _ref.allowInsecureUrl,
        allowInsecureUrl = _ref$allowInsecureUrl === void 0 ? false : _ref$allowInsecureUrl;

    _classCallCheck(this, GridAPIClient);

    this.transport = url.match(/^ws/i) ? 'ws' : 'http';

    if (this.transport === 'ws') {
      this.wsUrl = url;
      this.httpUrl = url.replace(/^ws(s)?/i, 'http$1');
    } else {
      this.httpUrl = url;
      this.wsUrl = url.replace(/^http(s)?/i, 'ws$1');
    }

    if (!allowInsecureUrl) {
      this.wsUrl = this.wsUrl.replace('ws', 'wss');
      this.httpUrl = this.httpUrl.replace('http', 'https');
    }

    this.ws = null;
    this.logger = new Logger('grid', true);
    this.responseTimeout = 10000;
    this._handleWsError = this._handleWsError.bind(this);
    this._handleWsClose = this._handleWsClose.bind(this);
  }

  _createClass(GridAPIClient, [{
    key: "authenticate",
    value: function () {
      var _authenticate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(authToken) {
        var response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.logger.log("Authenticating with ".concat(authToken, "..."));
                _context.next = 3;
                return this._send('federated/authenticate', {
                  auth_token: authToken
                });

              case 3:
                response = _context.sent;
                return _context.abrupt("return", response);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function authenticate(_x) {
        return _authenticate.apply(this, arguments);
      }

      return authenticate;
    }()
  }, {
    key: "requestCycle",
    value: function requestCycle(workerId, modelName, modelVersion, ping, download, upload) {
      this.logger.log("[WID: ".concat(workerId, "] Requesting cycle for model ").concat(modelName, " v.").concat(modelVersion, " [").concat(ping, ", ").concat(download, ", ").concat(upload, "]..."));

      var response = this._send('federated/cycle-request', {
        worker_id: workerId,
        model: modelName,
        version: modelVersion,
        ping: ping,
        download: download,
        upload: upload
      });

      return response;
      /*
      return Promise.resolve({
        status: 'accepted',
        request_key: 'request_key',
        plans: {
          training_plan: 'training_plan_id',
          another_plan: 'another_plan_id'
        },
        client_config: {
          lr: 0.05,
          batch_size: 64,
          max_updates: 400
        },
        protocols: { secure_agg_protocol: 'sec_agg_protocol_id' },
        model_id: 'model_id'
      }); */
    }
  }, {
    key: "getModel",
    value: function () {
      var _getModel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(workerId, requestKey, modelId) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.logger.log("[WID: ".concat(workerId, ", KEY: ").concat(requestKey, "] Requesting model ").concat(modelId, "..."));
                _context2.next = 3;
                return this._sendHttp('federated/get-model', {
                  worker_id: workerId,
                  request_key: requestKey,
                  model_id: modelId
                }, 'arrayBuffer');

              case 3:
                response = _context2.sent;
                return _context2.abrupt("return", response);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getModel(_x2, _x3, _x4) {
        return _getModel.apply(this, arguments);
      }

      return getModel;
    }()
  }, {
    key: "getPlan",
    value: function () {
      var _getPlan = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(workerId, requestKey, planId) {
        var response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.logger.log("[WID: ".concat(workerId, ", KEY: ").concat(requestKey, "] Requesting plan ").concat(planId, "...")); // const response = await fetch('/data/tp_ops.pb');
                // return response.arrayBuffer();

                _context3.next = 3;
                return this._sendHttp('federated/get-plan', {
                  worker_id: workerId,
                  request_key: requestKey,
                  plan_id: planId,
                  receive_operations_as: 'list'
                }, 'arrayBuffer');

              case 3:
                response = _context3.sent;
                return _context3.abrupt("return", response);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPlan(_x5, _x6, _x7) {
        return _getPlan.apply(this, arguments);
      }

      return getPlan;
    }()
  }, {
    key: "getProtocol",
    value: function getProtocol(workerId, requestKey, protocolId) {
      this.logger.log("[WID: ".concat(workerId, ", KEY: ").concat(requestKey, "] Requesting protocol ").concat(protocolId, "..."));
      return Promise.resolve('CgYIjcivoCUqEwoGCIHIr6AlEgkSB3dvcmtlcjEqEwoGCIXIr6AlEgkSB3dvcmtlcjIqEwoGCInIr6AlEgkSB3dvcmtlcjM=');
    }
  }, {
    key: "submitReport",
    value: function () {
      var _submitReport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(workerId, requestKey, diff) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.logger.log("[WID: ".concat(workerId, ", KEY: ").concat(requestKey, "] Submitting report..."));
                _context4.next = 3;
                return this._send('federated/report', {
                  worker_id: workerId,
                  request_key: requestKey,
                  diff: diff
                });

              case 3:
                response = _context4.sent;
                return _context4.abrupt("return", response);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function submitReport(_x8, _x9, _x10) {
        return _submitReport.apply(this, arguments);
      }

      return submitReport;
    }()
  }, {
    key: "getConnectionSpeed",
    value: function () {
      var _getConnectionSpeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(workerId) {
        var speedTest, ping, _yield$Promise$all, _yield$Promise$all2, download, upload;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                speedTest = new SpeedTest({
                  downloadUrl: this.httpUrl + '/federated/speed-test?worker_id=' + encodeURIComponent(workerId) + '&random=' + Math.random(),
                  uploadUrl: this.httpUrl + '/federated/speed-test?worker_id=' + encodeURIComponent(workerId) + '&random=' + Math.random(),
                  pingUrl: this.httpUrl + '/federated/speed-test?is_ping=1&worker_id=' + encodeURIComponent(workerId) + '&random=' + Math.random()
                });
                _context5.next = 3;
                return speedTest.getPing();

              case 3:
                ping = _context5.sent;
                _context5.next = 6;
                return Promise.all([speedTest.getDownloadSpeed(), speedTest.getUploadSpeed()]);

              case 6:
                _yield$Promise$all = _context5.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                download = _yield$Promise$all2[0];
                upload = _yield$Promise$all2[1];
                return _context5.abrupt("return", {
                  ping: ping,
                  download: download,
                  upload: upload
                });

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getConnectionSpeed(_x11) {
        return _getConnectionSpeed.apply(this, arguments);
      }

      return getConnectionSpeed;
    }()
  }, {
    key: "_send",
    value: function () {
      var _send2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(path, data) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(this.transport === 'ws')) {
                  _context6.next = 6;
                  break;
                }

                _context6.next = 3;
                return this._sendWs(path, data);

              case 3:
                _context6.t0 = _context6.sent;
                _context6.next = 9;
                break;

              case 6:
                _context6.next = 8;
                return this._sendHttp(path, data);

              case 8:
                _context6.t0 = _context6.sent;

              case 9:
                response = _context6.t0;

                if (!response.error) {
                  _context6.next = 12;
                  break;
                }

                throw new Error(response.error);

              case 12:
                return _context6.abrupt("return", response);

              case 13:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _send(_x12, _x13) {
        return _send2.apply(this, arguments);
      }

      return _send;
    }()
  }, {
    key: "_sendHttp",
    value: function () {
      var _sendHttp2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(path, data) {
        var type,
            method,
            response,
            query,
            _args7 = arguments;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                type = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : 'json';
                method = HTTP_PATH_VERB[path] || 'GET';

                if (!(method === 'GET')) {
                  _context7.next = 9;
                  break;
                }

                query = Object.keys(data).map(function (k) {
                  return encodeURIComponent(k) + '=' + encodeURIComponent(data[k]);
                }).join('&');
                _context7.next = 6;
                return fetch(this.httpUrl + '/' + path + '?' + query, {
                  method: 'GET',
                  mode: 'cors'
                });

              case 6:
                response = _context7.sent;
                _context7.next = 12;
                break;

              case 9:
                _context7.next = 11;
                return fetch(this.httpUrl + '/' + path, {
                  method: 'POST',
                  mode: 'cors',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(data)
                });

              case 11:
                response = _context7.sent;

              case 12:
                if (response.ok) {
                  _context7.next = 14;
                  break;
                }

                throw new Error('Network response was not ok');

              case 14:
                return _context7.abrupt("return", response[type]());

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _sendHttp(_x14, _x15) {
        return _sendHttp2.apply(this, arguments);
      }

      return _sendHttp;
    }()
  }, {
    key: "_sendWs",
    value: function () {
      var _sendWs2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(type, data) {
        var _this = this;

        var message;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this.ws) {
                  _context8.next = 3;
                  break;
                }

                _context8.next = 3;
                return this._initWs();

              case 3:
                message = {
                  type: type,
                  data: data
                };
                this.logger.log('Sending WS message', message);
                return _context8.abrupt("return", new Promise(function (resolve, reject) {
                  _this.ws.send(JSON.stringify(message));

                  var timeoutHandler = setTimeout(function () {
                    _this.ws.onmessage = null;
                    reject(new Error('Response timeout'));
                  }, _this.responseTimeout); // We expect first message after send to be response.

                  _this.ws.onmessage = function (event) {
                    // reset handlers
                    _this.ws.onerror = _this._handleWsClose;
                    _this.ws.onclose = _this._handleWsClose;
                    _this.ws.onmessage = null;
                    clearTimeout(timeoutHandler);
                    var data = JSON.parse(event.data);

                    _this.logger.log('Received message', data);

                    if (data.type !== message.type) {
                      // TODO do it differently
                      _this.logger.log('Received invalid response type, ignoring');
                    } else {
                      resolve(data.data);
                    }
                  };

                  _this.ws.onerror = function (event) {
                    clearTimeout(timeoutHandler);

                    _this._handleWsError(event);

                    reject(new Error(event));
                  };

                  _this.ws.onclose = function (event) {
                    clearTimeout(timeoutHandler);

                    _this._handleWsClose(event);

                    reject(new Error('WS connection closed'));
                  };
                }));

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _sendWs(_x16, _x17) {
        return _sendWs2.apply(this, arguments);
      }

      return _sendWs;
    }()
  }, {
    key: "_initWs",
    value: function () {
      var _initWs2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var _this2 = this;

        var ws;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                ws = new WebSocket(this.wsUrl);
                return _context9.abrupt("return", new Promise(function (resolve, reject) {
                  ws.onopen = function () {
                    // setup handlers
                    ws.onerror = _this2._handleWsError;
                    ws.onclose = _this2._handleWsClose;
                    _this2.ws = ws;
                    resolve();
                  };

                  ws.onerror = function (event) {
                    // couldn't connect
                    _this2._handleWsError(event);

                    reject(new Error(event));
                  };

                  ws.onclose = function (event) {
                    // couldn't connect
                    _this2._handleWsClose(event);

                    reject(new Error('WS connection closed during connect'));
                  };
                }));

              case 2:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _initWs() {
        return _initWs2.apply(this, arguments);
      }

      return _initWs;
    }()
  }, {
    key: "_handleWsError",
    value: function _handleWsError(event) {
      this.logger.log('WS connection error', event);
      this.ws = null;
    }
  }, {
    key: "_handleWsClose",
    value: function _handleWsClose(event) {
      this.logger.log('WS connection closed', event);
      this.ws = null;
    }
  }]);

  return GridAPIClient;
}();

var NO_DETAILER = function NO_DETAILER(d) {
  return "Serialized object contains type that may exist in PySyft, but is not currently supported in syft.js. Please file a feature request (https://github.com/OpenMined/syft.js/issues) for type ".concat(d, ".");
};
var NOT_ENOUGH_ARGS = function NOT_ENOUGH_ARGS(passed, expected) {
  return "You have passed ".concat(passed, " argument(s) when the plan requires ").concat(expected, " argument(s).");
};
var MISSING_VARIABLE = function MISSING_VARIABLE() {
  return "Command requires variable that is missing.";
};
var CANNOT_FIND_COMMAND = function CANNOT_FIND_COMMAND(command) {
  return "We cannot find function ".concat(command, " in TensorFlow.js, performing a manual lookup.");
};
var GRID_UNKNOWN_CYCLE_STATUS = function GRID_UNKNOWN_CYCLE_STATUS(status) {
  return "Unknown cycle status: ".concat(status);
};

var _DOC = "This file defines PySyft protocol serialization constants";
var VERSION = 0;
var TYPES = {
	dict: {
		code: 0
	},
	list: {
		code: 1
	},
	range: {
		code: 2
	},
	set: {
		code: 3
	},
	slice: {
		code: 4
	},
	str: {
		code: 5
	},
	tuple: {
		code: 6
	},
	ellipsis: {
		code: 7
	},
	"numpy.ndarray": {
		code: 8
	},
	"numpy.float32": {
		code: 9
	},
	"numpy.float64": {
		code: 9
	},
	"numpy.int32": {
		code: 9
	},
	"numpy.int64": {
		code: 9
	},
	"torch.device": {
		code: 10
	},
	"torch.Size": {
		code: 11
	},
	"torch.jit.ScriptModule": {
		code: 12
	},
	"torch._C.Function": {
		code: 12
	},
	"torch.jit.ScriptFunction": {
		code: 12
	},
	"torch.jit.TopLevelTracedModule": {
		code: 12
	},
	"torch.nn.parameter.Parameter": {
		code: 13
	},
	"torch.Tensor": {
		code: 14
	},
	"syft.frameworks.torch.tensors.interpreters.additive_shared.AdditiveSharingTensor": {
		code: 15
	},
	"syft.frameworks.torch.tensors.interpreters.precision.FixedPrecisionTensor": {
		code: 16
	},
	"syft.frameworks.torch.tensors.interpreters.crt_precision.CRTPrecisionTensor": {
		code: 17
	},
	"syft.frameworks.torch.tensors.decorators.logging.LoggingTensor": {
		code: 18
	},
	"syft.generic.pointers.multi_pointer.MultiPointerTensor": {
		code: 19
	},
	"syft.generic.pointers.object_pointer.ObjectPointer": {
		code: 20
	},
	"syft.execution.plan.Plan": {
		code: 21
	},
	"syft.execution.state.State": {
		code: 22
	},
	"syft.execution.procedure.Procedure": {
		code: 23
	},
	"syft.execution.protocol.Protocol": {
		code: 24
	},
	"syft.generic.pointers.pointer_tensor.PointerTensor": {
		code: 25
	},
	"syft.generic.pointers.pointer_plan.PointerPlan": {
		code: 26
	},
	"syft.generic.pointers.pointer_protocol.PointerProtocol": {
		code: 27
	},
	"syft.generic.pointers.object_wrapper.ObjectWrapper": {
		code: 28
	},
	"syft.federated.train_config.TrainConfig": {
		code: 29
	},
	"syft.workers.base.BaseWorker": {
		code: 30,
		forced_code: 43
	},
	"syft.frameworks.torch.tensors.interpreters.autograd.AutogradTensor": {
		code: 31
	},
	"syft.messaging.message.Message": {
		code: 32
	},
	"syft.messaging.message.TensorCommandMessage": {
		code: 33
	},
	"syft.messaging.message.ObjectMessage": {
		code: 34
	},
	"syft.messaging.message.ObjectRequestMessage": {
		code: 35
	},
	"syft.messaging.message.IsNoneMessage": {
		code: 36
	},
	"syft.messaging.message.GetShapeMessage": {
		code: 37
	},
	"syft.messaging.message.ForceObjectDeleteMessage": {
		code: 38
	},
	"syft.messaging.message.SearchMessage": {
		code: 39
	},
	"syft.messaging.message.PlanCommandMessage": {
		code: 40
	},
	"syft.exceptions.GetNotPermittedError": {
		code: 41
	},
	"syft.exceptions.ResponseSignatureError": {
		code: 42
	},
	"syft.generic.string.String": {
		code: 44
	},
	"syft.frameworks.torch.tensors.interpreters.promise.PromiseTensor": {
		code: 45
	},
	"syft.frameworks.torch.tensors.interpreters.private.PrivateTensor": {
		code: 46
	},
	"syft.frameworks.torch.tensors.interpreters.gradients_core.GradFunc": {
		code: 47
	},
	"syft.execution.placeholder.PlaceHolder": {
		code: 48
	},
	"torch.memory_format": {
		code: 49
	},
	"syft.messaging.message.CryptenInitPlan": {
		code: 50
	},
	"syft.frameworks.torch.fl.dataset.BaseDataset": {
		code: 51
	},
	"torch.dtype": {
		code: 52
	},
	"syft.messaging.message.WorkerCommandMessage": {
		code: 53
	},
	"syft.execution.computation.ComputationAction": {
		code: 54
	},
	"syft.execution.communication.CommunicationAction": {
		code: 55
	},
	"syft.execution.placeholder_id.PlaceholderId": {
		code: 56
	},
	"syft.generic.pointers.pointer_dataset.PointerDataset": {
		code: 57
	},
	"syft.execution.role.Role": {
		code: 58
	},
	"syft.frameworks.torch.tensors.interpreters.paillier.PaillierTensor": {
		code: 59
	},
	"syft.messaging.message.CryptenInitJail": {
		code: 60
	},
	type: {
		code: 61
	},
	"syft.execution.type_wrapper.NestedTypeWrapper": {
		code: 62
	},
	"syft.workers.virtual.VirtualWorker": {
		code: 63,
		forced_code: 64
	},
	"syft.execution.role_assignments.RoleAssignments": {
		code: 65
	},
	"syft.frameworks.torch.tensors.interpreters.fv.FVTensor": {
		code: 66
	},
	"syft.execution.worker_actions.WorkerAction": {
		code: 67
	}
};
var proto = {
	_DOC: _DOC,
	VERSION: VERSION,
	TYPES: TYPES
};

var proto$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  _DOC: _DOC,
  VERSION: VERSION,
  TYPES: TYPES,
  'default': proto
});

var aspromise = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

var base64_1 = createCommonjsModule(function (module, exports) {

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};
});

var eventemitter = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

var float_1 = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

var inquire_1 = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

var utf8_1 = createCommonjsModule(function (module, exports) {

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};
});

var pool_1 = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

var longbits = LongBits;



/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (minimal.isString(value)) {
        /* istanbul ignore else */
        if (minimal.Long)
            value = minimal.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return minimal.Long
        ? new minimal.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

var minimal = createCommonjsModule(function (module, exports) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = aspromise;

// converts to / from base64 encoded strings
util.base64 = base64_1;

// base class of rpc.Service
util.EventEmitter = eventemitter;

// float handling accross browsers
util.float = float_1;

// requires modules optionally and hides the call from bundlers
util.inquire = inquire_1;

// converts to / from utf8 encoded strings
util.utf8 = utf8_1;

// provides a node-like buffer pool in the browser
util.pool = pool_1;

// utility to work with the low and high bits of a 64 bit value
util.LongBits = longbits;

// global object reference
util.global = typeof window !== "undefined" && window
           || typeof commonjsGlobal !== "undefined" && commonjsGlobal
           || typeof self   !== "undefined" && self
           || commonjsGlobal; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};
});

var writer = Writer;



var BufferWriter; // cyclic

var LongBits$1  = minimal.LongBits,
    base64    = minimal.base64,
    utf8      = minimal.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = minimal.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new minimal.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (minimal.Array !== Array)
    Writer.alloc = minimal.pool(Writer.alloc, minimal.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits$1.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits$1.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits$1.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(minimal.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(minimal.float.writeDoubleLE, 8, value);
};

var writeBytes = minimal.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (minimal.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};

var writer_buffer = BufferWriter$1;

// extends Writer

(BufferWriter$1.prototype = Object.create(writer.prototype)).constructor = BufferWriter$1;



var Buffer$2 = minimal.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter$1() {
    writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter$1.alloc = function alloc_buffer(size) {
    return (BufferWriter$1.alloc = minimal._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer$2 && Buffer$2.prototype instanceof Uint8Array && Buffer$2.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter$1.prototype.bytes = function write_bytes_buffer(value) {
    if (minimal.isString(value))
        value = minimal._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        minimal.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter$1.prototype.string = function write_string_buffer(value) {
    var len = Buffer$2.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};

var reader = Reader;



var BufferReader; // cyclic

var LongBits$2  = minimal.LongBits,
    utf8$1      = minimal.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = minimal.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return minimal.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = minimal.Array.prototype.subarray || /* istanbul ignore next */ minimal.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits$2(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits$2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = minimal.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = minimal.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8$1.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = minimal.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    minimal.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

var reader_buffer = BufferReader$1;

// extends Reader

(BufferReader$1.prototype = Object.create(reader.prototype)).constructor = BufferReader$1;



/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader$1(buffer) {
    reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (minimal.Buffer)
    BufferReader$1.prototype._slice = minimal.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader$1.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

var service = Service;



// Extends EventEmitter
(Service.prototype = Object.create(minimal.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    minimal.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return minimal.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

var rpc_1 = createCommonjsModule(function (module, exports) {

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = service;
});

var roots = {};

var indexMinimal = createCommonjsModule(function (module, exports) {
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = writer;
protobuf.BufferWriter = writer_buffer;
protobuf.Reader       = reader;
protobuf.BufferReader = reader_buffer;

// Utility
protobuf.util         = minimal;
protobuf.rpc          = rpc_1;
protobuf.roots        = roots;
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Set up buffer utility according to the environment
protobuf.Writer._configure(protobuf.BufferWriter);
configure();
});

var minimal$1 = indexMinimal;

// Common aliases
var $Reader = minimal$1.Reader, $Writer = minimal$1.Writer, $util = minimal$1.util;

// Exported root namespace
var $root = minimal$1.roots["default"] || (minimal$1.roots["default"] = {});

$root.syft_proto = (function() {

    /**
     * Namespace syft_proto.
     * @exports syft_proto
     * @namespace
     */
    var syft_proto = {};

    syft_proto.execution = (function() {

        /**
         * Namespace execution.
         * @memberof syft_proto
         * @namespace
         */
        var execution = {};

        execution.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof syft_proto.execution
             * @namespace
             */
            var v1 = {};

            v1.CommunicationAction = (function() {

                /**
                 * Properties of a CommunicationAction.
                 * @memberof syft_proto.execution.v1
                 * @interface ICommunicationAction
                 * @property {string|null} [command] CommunicationAction command
                 * @property {syft_proto.types.syft.v1.IId|null} [target_id] CommunicationAction target_id
                 * @property {syft_proto.generic.pointers.v1.IPointerTensor|null} [target_pointer] CommunicationAction target_pointer
                 * @property {syft_proto.execution.v1.IPlaceholderId|null} [target_placeholder_id] CommunicationAction target_placeholder_id
                 * @property {syft_proto.types.torch.v1.ITorchTensor|null} [target_tensor] CommunicationAction target_tensor
                 * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] CommunicationAction args
                 * @property {Object.<string,syft_proto.types.syft.v1.IArg>|null} [kwargs] CommunicationAction kwargs
                 * @property {Array.<syft_proto.types.syft.v1.IId>|null} [return_ids] CommunicationAction return_ids
                 * @property {Array.<syft_proto.execution.v1.IPlaceholderId>|null} [return_placeholder_ids] CommunicationAction return_placeholder_ids
                 */

                /**
                 * Constructs a new CommunicationAction.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a CommunicationAction.
                 * @implements ICommunicationAction
                 * @constructor
                 * @param {syft_proto.execution.v1.ICommunicationAction=} [properties] Properties to set
                 */
                function CommunicationAction(properties) {
                    this.args = [];
                    this.kwargs = {};
                    this.return_ids = [];
                    this.return_placeholder_ids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommunicationAction command.
                 * @member {string} command
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.command = "";

                /**
                 * CommunicationAction target_id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} target_id
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.target_id = null;

                /**
                 * CommunicationAction target_pointer.
                 * @member {syft_proto.generic.pointers.v1.IPointerTensor|null|undefined} target_pointer
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.target_pointer = null;

                /**
                 * CommunicationAction target_placeholder_id.
                 * @member {syft_proto.execution.v1.IPlaceholderId|null|undefined} target_placeholder_id
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.target_placeholder_id = null;

                /**
                 * CommunicationAction target_tensor.
                 * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} target_tensor
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.target_tensor = null;

                /**
                 * CommunicationAction args.
                 * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.args = $util.emptyArray;

                /**
                 * CommunicationAction kwargs.
                 * @member {Object.<string,syft_proto.types.syft.v1.IArg>} kwargs
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.kwargs = $util.emptyObject;

                /**
                 * CommunicationAction return_ids.
                 * @member {Array.<syft_proto.types.syft.v1.IId>} return_ids
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.return_ids = $util.emptyArray;

                /**
                 * CommunicationAction return_placeholder_ids.
                 * @member {Array.<syft_proto.execution.v1.IPlaceholderId>} return_placeholder_ids
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                CommunicationAction.prototype.return_placeholder_ids = $util.emptyArray;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * CommunicationAction target.
                 * @member {"target_id"|"target_pointer"|"target_placeholder_id"|"target_tensor"|undefined} target
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 */
                Object.defineProperty(CommunicationAction.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["target_id", "target_pointer", "target_placeholder_id", "target_tensor"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new CommunicationAction instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @static
                 * @param {syft_proto.execution.v1.ICommunicationAction=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.CommunicationAction} CommunicationAction instance
                 */
                CommunicationAction.create = function create(properties) {
                    return new CommunicationAction(properties);
                };

                /**
                 * Encodes the specified CommunicationAction message. Does not implicitly {@link syft_proto.execution.v1.CommunicationAction.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @static
                 * @param {syft_proto.execution.v1.ICommunicationAction} message CommunicationAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommunicationAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command != null && message.hasOwnProperty("command"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer"))
                        $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.target_pointer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id"))
                        $root.syft_proto.execution.v1.PlaceholderId.encode(message.target_placeholder_id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor"))
                        $root.syft_proto.types.torch.v1.TorchTensor.encode(message.target_tensor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.args != null && message.args.length)
                        for (var i = 0; i < message.args.length; ++i)
                            $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.kwargs != null && message.hasOwnProperty("kwargs"))
                        for (var keys = Object.keys(message.kwargs), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.syft_proto.types.syft.v1.Arg.encode(message.kwargs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.return_ids != null && message.return_ids.length)
                        for (var i = 0; i < message.return_ids.length; ++i)
                            $root.syft_proto.types.syft.v1.Id.encode(message.return_ids[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.return_placeholder_ids != null && message.return_placeholder_ids.length)
                        for (var i = 0; i < message.return_placeholder_ids.length; ++i)
                            $root.syft_proto.execution.v1.PlaceholderId.encode(message.return_placeholder_ids[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.target_id != null && message.hasOwnProperty("target_id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.target_id, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CommunicationAction message, length delimited. Does not implicitly {@link syft_proto.execution.v1.CommunicationAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @static
                 * @param {syft_proto.execution.v1.ICommunicationAction} message CommunicationAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommunicationAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommunicationAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.CommunicationAction} CommunicationAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommunicationAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.CommunicationAction(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command = reader.string();
                            break;
                        case 9:
                            message.target_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            reader.skip().pos++;
                            if (message.kwargs === $util.emptyObject)
                                message.kwargs = {};
                            key = reader.string();
                            reader.pos++;
                            message.kwargs[key] = $root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32());
                            break;
                        case 7:
                            if (!(message.return_ids && message.return_ids.length))
                                message.return_ids = [];
                            message.return_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.return_placeholder_ids && message.return_placeholder_ids.length))
                                message.return_placeholder_ids = [];
                            message.return_placeholder_ids.push($root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommunicationAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.CommunicationAction} CommunicationAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommunicationAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommunicationAction message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommunicationAction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.command != null && message.hasOwnProperty("command"))
                        if (!$util.isString(message.command))
                            return "command: string expected";
                    if (message.target_id != null && message.hasOwnProperty("target_id")) {
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.target_id);
                            if (error)
                                return "target_id." + error;
                        }
                    }
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.target_pointer);
                            if (error)
                                return "target_pointer." + error;
                        }
                    }
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.target_placeholder_id);
                            if (error)
                                return "target_placeholder_id." + error;
                        }
                    }
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.target_tensor);
                            if (error)
                                return "target_tensor." + error;
                        }
                    }
                    if (message.args != null && message.hasOwnProperty("args")) {
                        if (!Array.isArray(message.args))
                            return "args: array expected";
                        for (var i = 0; i < message.args.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                            if (error)
                                return "args." + error;
                        }
                    }
                    if (message.kwargs != null && message.hasOwnProperty("kwargs")) {
                        if (!$util.isObject(message.kwargs))
                            return "kwargs: object expected";
                        var key = Object.keys(message.kwargs);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Arg.verify(message.kwargs[key[i]]);
                            if (error)
                                return "kwargs." + error;
                        }
                    }
                    if (message.return_ids != null && message.hasOwnProperty("return_ids")) {
                        if (!Array.isArray(message.return_ids))
                            return "return_ids: array expected";
                        for (var i = 0; i < message.return_ids.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.return_ids[i]);
                            if (error)
                                return "return_ids." + error;
                        }
                    }
                    if (message.return_placeholder_ids != null && message.hasOwnProperty("return_placeholder_ids")) {
                        if (!Array.isArray(message.return_placeholder_ids))
                            return "return_placeholder_ids: array expected";
                        for (var i = 0; i < message.return_placeholder_ids.length; ++i) {
                            var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.return_placeholder_ids[i]);
                            if (error)
                                return "return_placeholder_ids." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CommunicationAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.CommunicationAction} CommunicationAction
                 */
                CommunicationAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.CommunicationAction)
                        return object;
                    var message = new $root.syft_proto.execution.v1.CommunicationAction();
                    if (object.command != null)
                        message.command = String(object.command);
                    if (object.target_id != null) {
                        if (typeof object.target_id !== "object")
                            throw TypeError(".syft_proto.execution.v1.CommunicationAction.target_id: object expected");
                        message.target_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.target_id);
                    }
                    if (object.target_pointer != null) {
                        if (typeof object.target_pointer !== "object")
                            throw TypeError(".syft_proto.execution.v1.CommunicationAction.target_pointer: object expected");
                        message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.target_pointer);
                    }
                    if (object.target_placeholder_id != null) {
                        if (typeof object.target_placeholder_id !== "object")
                            throw TypeError(".syft_proto.execution.v1.CommunicationAction.target_placeholder_id: object expected");
                        message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.target_placeholder_id);
                    }
                    if (object.target_tensor != null) {
                        if (typeof object.target_tensor !== "object")
                            throw TypeError(".syft_proto.execution.v1.CommunicationAction.target_tensor: object expected");
                        message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.target_tensor);
                    }
                    if (object.args) {
                        if (!Array.isArray(object.args))
                            throw TypeError(".syft_proto.execution.v1.CommunicationAction.args: array expected");
                        message.args = [];
                        for (var i = 0; i < object.args.length; ++i) {
                            if (typeof object.args[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.CommunicationAction.args: object expected");
                            message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                        }
                    }
                    if (object.kwargs) {
                        if (typeof object.kwargs !== "object")
                            throw TypeError(".syft_proto.execution.v1.CommunicationAction.kwargs: object expected");
                        message.kwargs = {};
                        for (var keys = Object.keys(object.kwargs), i = 0; i < keys.length; ++i) {
                            if (typeof object.kwargs[keys[i]] !== "object")
                                throw TypeError(".syft_proto.execution.v1.CommunicationAction.kwargs: object expected");
                            message.kwargs[keys[i]] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.kwargs[keys[i]]);
                        }
                    }
                    if (object.return_ids) {
                        if (!Array.isArray(object.return_ids))
                            throw TypeError(".syft_proto.execution.v1.CommunicationAction.return_ids: array expected");
                        message.return_ids = [];
                        for (var i = 0; i < object.return_ids.length; ++i) {
                            if (typeof object.return_ids[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.CommunicationAction.return_ids: object expected");
                            message.return_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.return_ids[i]);
                        }
                    }
                    if (object.return_placeholder_ids) {
                        if (!Array.isArray(object.return_placeholder_ids))
                            throw TypeError(".syft_proto.execution.v1.CommunicationAction.return_placeholder_ids: array expected");
                        message.return_placeholder_ids = [];
                        for (var i = 0; i < object.return_placeholder_ids.length; ++i) {
                            if (typeof object.return_placeholder_ids[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.CommunicationAction.return_placeholder_ids: object expected");
                            message.return_placeholder_ids[i] = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.return_placeholder_ids[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CommunicationAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @static
                 * @param {syft_proto.execution.v1.CommunicationAction} message CommunicationAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommunicationAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.args = [];
                        object.return_ids = [];
                        object.return_placeholder_ids = [];
                    }
                    if (options.objects || options.defaults)
                        object.kwargs = {};
                    if (options.defaults)
                        object.command = "";
                    if (message.command != null && message.hasOwnProperty("command"))
                        object.command = message.command;
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                        object.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.target_pointer, options);
                        if (options.oneofs)
                            object.target = "target_pointer";
                    }
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                        object.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.target_placeholder_id, options);
                        if (options.oneofs)
                            object.target = "target_placeholder_id";
                    }
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                        object.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.target_tensor, options);
                        if (options.oneofs)
                            object.target = "target_tensor";
                    }
                    if (message.args && message.args.length) {
                        object.args = [];
                        for (var j = 0; j < message.args.length; ++j)
                            object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                    }
                    var keys2;
                    if (message.kwargs && (keys2 = Object.keys(message.kwargs)).length) {
                        object.kwargs = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.kwargs[keys2[j]] = $root.syft_proto.types.syft.v1.Arg.toObject(message.kwargs[keys2[j]], options);
                    }
                    if (message.return_ids && message.return_ids.length) {
                        object.return_ids = [];
                        for (var j = 0; j < message.return_ids.length; ++j)
                            object.return_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.return_ids[j], options);
                    }
                    if (message.return_placeholder_ids && message.return_placeholder_ids.length) {
                        object.return_placeholder_ids = [];
                        for (var j = 0; j < message.return_placeholder_ids.length; ++j)
                            object.return_placeholder_ids[j] = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.return_placeholder_ids[j], options);
                    }
                    if (message.target_id != null && message.hasOwnProperty("target_id")) {
                        object.target_id = $root.syft_proto.types.syft.v1.Id.toObject(message.target_id, options);
                        if (options.oneofs)
                            object.target = "target_id";
                    }
                    return object;
                };

                /**
                 * Converts this CommunicationAction to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.CommunicationAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommunicationAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return CommunicationAction;
            })();

            v1.PlaceholderId = (function() {

                /**
                 * Properties of a PlaceholderId.
                 * @memberof syft_proto.execution.v1
                 * @interface IPlaceholderId
                 * @property {syft_proto.types.syft.v1.IId|null} [id] PlaceholderId id
                 */

                /**
                 * Constructs a new PlaceholderId.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a PlaceholderId.
                 * @implements IPlaceholderId
                 * @constructor
                 * @param {syft_proto.execution.v1.IPlaceholderId=} [properties] Properties to set
                 */
                function PlaceholderId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlaceholderId id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @instance
                 */
                PlaceholderId.prototype.id = null;

                /**
                 * Creates a new PlaceholderId instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @static
                 * @param {syft_proto.execution.v1.IPlaceholderId=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.PlaceholderId} PlaceholderId instance
                 */
                PlaceholderId.create = function create(properties) {
                    return new PlaceholderId(properties);
                };

                /**
                 * Encodes the specified PlaceholderId message. Does not implicitly {@link syft_proto.execution.v1.PlaceholderId.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @static
                 * @param {syft_proto.execution.v1.IPlaceholderId} message PlaceholderId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlaceholderId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlaceholderId message, length delimited. Does not implicitly {@link syft_proto.execution.v1.PlaceholderId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @static
                 * @param {syft_proto.execution.v1.IPlaceholderId} message PlaceholderId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlaceholderId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlaceholderId message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.PlaceholderId} PlaceholderId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlaceholderId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.PlaceholderId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlaceholderId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.PlaceholderId} PlaceholderId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlaceholderId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlaceholderId message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlaceholderId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PlaceholderId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.PlaceholderId} PlaceholderId
                 */
                PlaceholderId.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.PlaceholderId)
                        return object;
                    var message = new $root.syft_proto.execution.v1.PlaceholderId();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".syft_proto.execution.v1.PlaceholderId.id: object expected");
                        message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlaceholderId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @static
                 * @param {syft_proto.execution.v1.PlaceholderId} message PlaceholderId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlaceholderId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.id = null;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                    return object;
                };

                /**
                 * Converts this PlaceholderId to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.PlaceholderId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlaceholderId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return PlaceholderId;
            })();

            v1.Placeholder = (function() {

                /**
                 * Properties of a Placeholder.
                 * @memberof syft_proto.execution.v1
                 * @interface IPlaceholder
                 * @property {syft_proto.types.syft.v1.IId|null} [id] Placeholder id
                 * @property {Array.<string>|null} [tags] Placeholder tags
                 * @property {string|null} [description] Placeholder description
                 * @property {syft_proto.types.syft.v1.IShape|null} [expected_shape] Placeholder expected_shape
                 */

                /**
                 * Constructs a new Placeholder.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a Placeholder.
                 * @implements IPlaceholder
                 * @constructor
                 * @param {syft_proto.execution.v1.IPlaceholder=} [properties] Properties to set
                 */
                function Placeholder(properties) {
                    this.tags = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Placeholder id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @instance
                 */
                Placeholder.prototype.id = null;

                /**
                 * Placeholder tags.
                 * @member {Array.<string>} tags
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @instance
                 */
                Placeholder.prototype.tags = $util.emptyArray;

                /**
                 * Placeholder description.
                 * @member {string} description
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @instance
                 */
                Placeholder.prototype.description = "";

                /**
                 * Placeholder expected_shape.
                 * @member {syft_proto.types.syft.v1.IShape|null|undefined} expected_shape
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @instance
                 */
                Placeholder.prototype.expected_shape = null;

                /**
                 * Creates a new Placeholder instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @static
                 * @param {syft_proto.execution.v1.IPlaceholder=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.Placeholder} Placeholder instance
                 */
                Placeholder.create = function create(properties) {
                    return new Placeholder(properties);
                };

                /**
                 * Encodes the specified Placeholder message. Does not implicitly {@link syft_proto.execution.v1.Placeholder.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @static
                 * @param {syft_proto.execution.v1.IPlaceholder} message Placeholder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Placeholder.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.tags[i]);
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                    if (message.expected_shape != null && message.hasOwnProperty("expected_shape"))
                        $root.syft_proto.types.syft.v1.Shape.encode(message.expected_shape, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Placeholder message, length delimited. Does not implicitly {@link syft_proto.execution.v1.Placeholder.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @static
                 * @param {syft_proto.execution.v1.IPlaceholder} message Placeholder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Placeholder.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Placeholder message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.Placeholder} Placeholder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Placeholder.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.Placeholder();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        case 3:
                            message.description = reader.string();
                            break;
                        case 4:
                            message.expected_shape = $root.syft_proto.types.syft.v1.Shape.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Placeholder message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.Placeholder} Placeholder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Placeholder.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Placeholder message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Placeholder.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.expected_shape != null && message.hasOwnProperty("expected_shape")) {
                        var error = $root.syft_proto.types.syft.v1.Shape.verify(message.expected_shape);
                        if (error)
                            return "expected_shape." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Placeholder message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.Placeholder} Placeholder
                 */
                Placeholder.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.Placeholder)
                        return object;
                    var message = new $root.syft_proto.execution.v1.Placeholder();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".syft_proto.execution.v1.Placeholder.id: object expected");
                        message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                    }
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".syft_proto.execution.v1.Placeholder.tags: array expected");
                        message.tags = [];
                        for (var i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.expected_shape != null) {
                        if (typeof object.expected_shape !== "object")
                            throw TypeError(".syft_proto.execution.v1.Placeholder.expected_shape: object expected");
                        message.expected_shape = $root.syft_proto.types.syft.v1.Shape.fromObject(object.expected_shape);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Placeholder message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @static
                 * @param {syft_proto.execution.v1.Placeholder} message Placeholder
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Placeholder.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.tags = [];
                    if (options.defaults) {
                        object.id = null;
                        object.description = "";
                        object.expected_shape = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (var j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.expected_shape != null && message.hasOwnProperty("expected_shape"))
                        object.expected_shape = $root.syft_proto.types.syft.v1.Shape.toObject(message.expected_shape, options);
                    return object;
                };

                /**
                 * Converts this Placeholder to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.Placeholder
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Placeholder.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return Placeholder;
            })();

            v1.ComputationAction = (function() {

                /**
                 * Properties of a ComputationAction.
                 * @memberof syft_proto.execution.v1
                 * @interface IComputationAction
                 * @property {string|null} [command] ComputationAction command
                 * @property {syft_proto.types.syft.v1.IId|null} [target_id] ComputationAction target_id
                 * @property {syft_proto.generic.pointers.v1.IPointerTensor|null} [target_pointer] ComputationAction target_pointer
                 * @property {syft_proto.execution.v1.IPlaceholderId|null} [target_placeholder_id] ComputationAction target_placeholder_id
                 * @property {syft_proto.types.torch.v1.ITorchTensor|null} [target_tensor] ComputationAction target_tensor
                 * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] ComputationAction args
                 * @property {Object.<string,syft_proto.types.syft.v1.IArg>|null} [kwargs] ComputationAction kwargs
                 * @property {Array.<syft_proto.types.syft.v1.IId>|null} [return_ids] ComputationAction return_ids
                 * @property {Array.<syft_proto.execution.v1.IPlaceholderId>|null} [return_placeholder_ids] ComputationAction return_placeholder_ids
                 */

                /**
                 * Constructs a new ComputationAction.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a ComputationAction.
                 * @implements IComputationAction
                 * @constructor
                 * @param {syft_proto.execution.v1.IComputationAction=} [properties] Properties to set
                 */
                function ComputationAction(properties) {
                    this.args = [];
                    this.kwargs = {};
                    this.return_ids = [];
                    this.return_placeholder_ids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ComputationAction command.
                 * @member {string} command
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.command = "";

                /**
                 * ComputationAction target_id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} target_id
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.target_id = null;

                /**
                 * ComputationAction target_pointer.
                 * @member {syft_proto.generic.pointers.v1.IPointerTensor|null|undefined} target_pointer
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.target_pointer = null;

                /**
                 * ComputationAction target_placeholder_id.
                 * @member {syft_proto.execution.v1.IPlaceholderId|null|undefined} target_placeholder_id
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.target_placeholder_id = null;

                /**
                 * ComputationAction target_tensor.
                 * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} target_tensor
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.target_tensor = null;

                /**
                 * ComputationAction args.
                 * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.args = $util.emptyArray;

                /**
                 * ComputationAction kwargs.
                 * @member {Object.<string,syft_proto.types.syft.v1.IArg>} kwargs
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.kwargs = $util.emptyObject;

                /**
                 * ComputationAction return_ids.
                 * @member {Array.<syft_proto.types.syft.v1.IId>} return_ids
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.return_ids = $util.emptyArray;

                /**
                 * ComputationAction return_placeholder_ids.
                 * @member {Array.<syft_proto.execution.v1.IPlaceholderId>} return_placeholder_ids
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                ComputationAction.prototype.return_placeholder_ids = $util.emptyArray;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * ComputationAction target.
                 * @member {"target_id"|"target_pointer"|"target_placeholder_id"|"target_tensor"|undefined} target
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 */
                Object.defineProperty(ComputationAction.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["target_id", "target_pointer", "target_placeholder_id", "target_tensor"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new ComputationAction instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @static
                 * @param {syft_proto.execution.v1.IComputationAction=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.ComputationAction} ComputationAction instance
                 */
                ComputationAction.create = function create(properties) {
                    return new ComputationAction(properties);
                };

                /**
                 * Encodes the specified ComputationAction message. Does not implicitly {@link syft_proto.execution.v1.ComputationAction.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @static
                 * @param {syft_proto.execution.v1.IComputationAction} message ComputationAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ComputationAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command != null && message.hasOwnProperty("command"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer"))
                        $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.target_pointer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id"))
                        $root.syft_proto.execution.v1.PlaceholderId.encode(message.target_placeholder_id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor"))
                        $root.syft_proto.types.torch.v1.TorchTensor.encode(message.target_tensor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.args != null && message.args.length)
                        for (var i = 0; i < message.args.length; ++i)
                            $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.kwargs != null && message.hasOwnProperty("kwargs"))
                        for (var keys = Object.keys(message.kwargs), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.syft_proto.types.syft.v1.Arg.encode(message.kwargs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.return_ids != null && message.return_ids.length)
                        for (var i = 0; i < message.return_ids.length; ++i)
                            $root.syft_proto.types.syft.v1.Id.encode(message.return_ids[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.return_placeholder_ids != null && message.return_placeholder_ids.length)
                        for (var i = 0; i < message.return_placeholder_ids.length; ++i)
                            $root.syft_proto.execution.v1.PlaceholderId.encode(message.return_placeholder_ids[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.target_id != null && message.hasOwnProperty("target_id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.target_id, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ComputationAction message, length delimited. Does not implicitly {@link syft_proto.execution.v1.ComputationAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @static
                 * @param {syft_proto.execution.v1.IComputationAction} message ComputationAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ComputationAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ComputationAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.ComputationAction} ComputationAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ComputationAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.ComputationAction(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command = reader.string();
                            break;
                        case 9:
                            message.target_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            reader.skip().pos++;
                            if (message.kwargs === $util.emptyObject)
                                message.kwargs = {};
                            key = reader.string();
                            reader.pos++;
                            message.kwargs[key] = $root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32());
                            break;
                        case 7:
                            if (!(message.return_ids && message.return_ids.length))
                                message.return_ids = [];
                            message.return_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.return_placeholder_ids && message.return_placeholder_ids.length))
                                message.return_placeholder_ids = [];
                            message.return_placeholder_ids.push($root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ComputationAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.ComputationAction} ComputationAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ComputationAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ComputationAction message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ComputationAction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.command != null && message.hasOwnProperty("command"))
                        if (!$util.isString(message.command))
                            return "command: string expected";
                    if (message.target_id != null && message.hasOwnProperty("target_id")) {
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.target_id);
                            if (error)
                                return "target_id." + error;
                        }
                    }
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.target_pointer);
                            if (error)
                                return "target_pointer." + error;
                        }
                    }
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.target_placeholder_id);
                            if (error)
                                return "target_placeholder_id." + error;
                        }
                    }
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.target_tensor);
                            if (error)
                                return "target_tensor." + error;
                        }
                    }
                    if (message.args != null && message.hasOwnProperty("args")) {
                        if (!Array.isArray(message.args))
                            return "args: array expected";
                        for (var i = 0; i < message.args.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                            if (error)
                                return "args." + error;
                        }
                    }
                    if (message.kwargs != null && message.hasOwnProperty("kwargs")) {
                        if (!$util.isObject(message.kwargs))
                            return "kwargs: object expected";
                        var key = Object.keys(message.kwargs);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Arg.verify(message.kwargs[key[i]]);
                            if (error)
                                return "kwargs." + error;
                        }
                    }
                    if (message.return_ids != null && message.hasOwnProperty("return_ids")) {
                        if (!Array.isArray(message.return_ids))
                            return "return_ids: array expected";
                        for (var i = 0; i < message.return_ids.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.return_ids[i]);
                            if (error)
                                return "return_ids." + error;
                        }
                    }
                    if (message.return_placeholder_ids != null && message.hasOwnProperty("return_placeholder_ids")) {
                        if (!Array.isArray(message.return_placeholder_ids))
                            return "return_placeholder_ids: array expected";
                        for (var i = 0; i < message.return_placeholder_ids.length; ++i) {
                            var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.return_placeholder_ids[i]);
                            if (error)
                                return "return_placeholder_ids." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ComputationAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.ComputationAction} ComputationAction
                 */
                ComputationAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.ComputationAction)
                        return object;
                    var message = new $root.syft_proto.execution.v1.ComputationAction();
                    if (object.command != null)
                        message.command = String(object.command);
                    if (object.target_id != null) {
                        if (typeof object.target_id !== "object")
                            throw TypeError(".syft_proto.execution.v1.ComputationAction.target_id: object expected");
                        message.target_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.target_id);
                    }
                    if (object.target_pointer != null) {
                        if (typeof object.target_pointer !== "object")
                            throw TypeError(".syft_proto.execution.v1.ComputationAction.target_pointer: object expected");
                        message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.target_pointer);
                    }
                    if (object.target_placeholder_id != null) {
                        if (typeof object.target_placeholder_id !== "object")
                            throw TypeError(".syft_proto.execution.v1.ComputationAction.target_placeholder_id: object expected");
                        message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.target_placeholder_id);
                    }
                    if (object.target_tensor != null) {
                        if (typeof object.target_tensor !== "object")
                            throw TypeError(".syft_proto.execution.v1.ComputationAction.target_tensor: object expected");
                        message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.target_tensor);
                    }
                    if (object.args) {
                        if (!Array.isArray(object.args))
                            throw TypeError(".syft_proto.execution.v1.ComputationAction.args: array expected");
                        message.args = [];
                        for (var i = 0; i < object.args.length; ++i) {
                            if (typeof object.args[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.ComputationAction.args: object expected");
                            message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                        }
                    }
                    if (object.kwargs) {
                        if (typeof object.kwargs !== "object")
                            throw TypeError(".syft_proto.execution.v1.ComputationAction.kwargs: object expected");
                        message.kwargs = {};
                        for (var keys = Object.keys(object.kwargs), i = 0; i < keys.length; ++i) {
                            if (typeof object.kwargs[keys[i]] !== "object")
                                throw TypeError(".syft_proto.execution.v1.ComputationAction.kwargs: object expected");
                            message.kwargs[keys[i]] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.kwargs[keys[i]]);
                        }
                    }
                    if (object.return_ids) {
                        if (!Array.isArray(object.return_ids))
                            throw TypeError(".syft_proto.execution.v1.ComputationAction.return_ids: array expected");
                        message.return_ids = [];
                        for (var i = 0; i < object.return_ids.length; ++i) {
                            if (typeof object.return_ids[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.ComputationAction.return_ids: object expected");
                            message.return_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.return_ids[i]);
                        }
                    }
                    if (object.return_placeholder_ids) {
                        if (!Array.isArray(object.return_placeholder_ids))
                            throw TypeError(".syft_proto.execution.v1.ComputationAction.return_placeholder_ids: array expected");
                        message.return_placeholder_ids = [];
                        for (var i = 0; i < object.return_placeholder_ids.length; ++i) {
                            if (typeof object.return_placeholder_ids[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.ComputationAction.return_placeholder_ids: object expected");
                            message.return_placeholder_ids[i] = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.return_placeholder_ids[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ComputationAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @static
                 * @param {syft_proto.execution.v1.ComputationAction} message ComputationAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ComputationAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.args = [];
                        object.return_ids = [];
                        object.return_placeholder_ids = [];
                    }
                    if (options.objects || options.defaults)
                        object.kwargs = {};
                    if (options.defaults)
                        object.command = "";
                    if (message.command != null && message.hasOwnProperty("command"))
                        object.command = message.command;
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                        object.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.target_pointer, options);
                        if (options.oneofs)
                            object.target = "target_pointer";
                    }
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                        object.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.target_placeholder_id, options);
                        if (options.oneofs)
                            object.target = "target_placeholder_id";
                    }
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                        object.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.target_tensor, options);
                        if (options.oneofs)
                            object.target = "target_tensor";
                    }
                    if (message.args && message.args.length) {
                        object.args = [];
                        for (var j = 0; j < message.args.length; ++j)
                            object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                    }
                    var keys2;
                    if (message.kwargs && (keys2 = Object.keys(message.kwargs)).length) {
                        object.kwargs = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.kwargs[keys2[j]] = $root.syft_proto.types.syft.v1.Arg.toObject(message.kwargs[keys2[j]], options);
                    }
                    if (message.return_ids && message.return_ids.length) {
                        object.return_ids = [];
                        for (var j = 0; j < message.return_ids.length; ++j)
                            object.return_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.return_ids[j], options);
                    }
                    if (message.return_placeholder_ids && message.return_placeholder_ids.length) {
                        object.return_placeholder_ids = [];
                        for (var j = 0; j < message.return_placeholder_ids.length; ++j)
                            object.return_placeholder_ids[j] = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.return_placeholder_ids[j], options);
                    }
                    if (message.target_id != null && message.hasOwnProperty("target_id")) {
                        object.target_id = $root.syft_proto.types.syft.v1.Id.toObject(message.target_id, options);
                        if (options.oneofs)
                            object.target = "target_id";
                    }
                    return object;
                };

                /**
                 * Converts this ComputationAction to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.ComputationAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ComputationAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return ComputationAction;
            })();

            v1.Plan = (function() {

                /**
                 * Properties of a Plan.
                 * @memberof syft_proto.execution.v1
                 * @interface IPlan
                 * @property {syft_proto.types.syft.v1.IId|null} [id] Plan id
                 * @property {syft_proto.execution.v1.IRole|null} [role] Plan role
                 * @property {boolean|null} [include_state] Plan include_state
                 * @property {string|null} [name] Plan name
                 * @property {Array.<string>|null} [tags] Plan tags
                 * @property {string|null} [description] Plan description
                 * @property {Uint8Array|null} [torchscript] Plan torchscript
                 * @property {syft_proto.execution.v1.INestedTypeWrapper|null} [input_types] Plan input_types
                 */

                /**
                 * Constructs a new Plan.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a Plan.
                 * @implements IPlan
                 * @constructor
                 * @param {syft_proto.execution.v1.IPlan=} [properties] Properties to set
                 */
                function Plan(properties) {
                    this.tags = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Plan id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 */
                Plan.prototype.id = null;

                /**
                 * Plan role.
                 * @member {syft_proto.execution.v1.IRole|null|undefined} role
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 */
                Plan.prototype.role = null;

                /**
                 * Plan include_state.
                 * @member {boolean} include_state
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 */
                Plan.prototype.include_state = false;

                /**
                 * Plan name.
                 * @member {string} name
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 */
                Plan.prototype.name = "";

                /**
                 * Plan tags.
                 * @member {Array.<string>} tags
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 */
                Plan.prototype.tags = $util.emptyArray;

                /**
                 * Plan description.
                 * @member {string} description
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 */
                Plan.prototype.description = "";

                /**
                 * Plan torchscript.
                 * @member {Uint8Array} torchscript
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 */
                Plan.prototype.torchscript = $util.newBuffer([]);

                /**
                 * Plan input_types.
                 * @member {syft_proto.execution.v1.INestedTypeWrapper|null|undefined} input_types
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 */
                Plan.prototype.input_types = null;

                /**
                 * Creates a new Plan instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.Plan
                 * @static
                 * @param {syft_proto.execution.v1.IPlan=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.Plan} Plan instance
                 */
                Plan.create = function create(properties) {
                    return new Plan(properties);
                };

                /**
                 * Encodes the specified Plan message. Does not implicitly {@link syft_proto.execution.v1.Plan.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.Plan
                 * @static
                 * @param {syft_proto.execution.v1.IPlan} message Plan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Plan.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.role != null && message.hasOwnProperty("role"))
                        $root.syft_proto.execution.v1.Role.encode(message.role, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.include_state != null && message.hasOwnProperty("include_state"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.include_state);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
                    if (message.torchscript != null && message.hasOwnProperty("torchscript"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.torchscript);
                    if (message.input_types != null && message.hasOwnProperty("input_types"))
                        $root.syft_proto.execution.v1.NestedTypeWrapper.encode(message.input_types, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Plan message, length delimited. Does not implicitly {@link syft_proto.execution.v1.Plan.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.Plan
                 * @static
                 * @param {syft_proto.execution.v1.IPlan} message Plan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Plan.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Plan message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.Plan
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.Plan} Plan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Plan.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.Plan();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.role = $root.syft_proto.execution.v1.Role.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.include_state = reader.bool();
                            break;
                        case 4:
                            message.name = reader.string();
                            break;
                        case 5:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        case 6:
                            message.description = reader.string();
                            break;
                        case 7:
                            message.torchscript = reader.bytes();
                            break;
                        case 8:
                            message.input_types = $root.syft_proto.execution.v1.NestedTypeWrapper.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Plan message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.Plan
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.Plan} Plan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Plan.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Plan message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.Plan
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Plan.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.role != null && message.hasOwnProperty("role")) {
                        var error = $root.syft_proto.execution.v1.Role.verify(message.role);
                        if (error)
                            return "role." + error;
                    }
                    if (message.include_state != null && message.hasOwnProperty("include_state"))
                        if (typeof message.include_state !== "boolean")
                            return "include_state: boolean expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.torchscript != null && message.hasOwnProperty("torchscript"))
                        if (!(message.torchscript && typeof message.torchscript.length === "number" || $util.isString(message.torchscript)))
                            return "torchscript: buffer expected";
                    if (message.input_types != null && message.hasOwnProperty("input_types")) {
                        var error = $root.syft_proto.execution.v1.NestedTypeWrapper.verify(message.input_types);
                        if (error)
                            return "input_types." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Plan message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.Plan
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.Plan} Plan
                 */
                Plan.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.Plan)
                        return object;
                    var message = new $root.syft_proto.execution.v1.Plan();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".syft_proto.execution.v1.Plan.id: object expected");
                        message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                    }
                    if (object.role != null) {
                        if (typeof object.role !== "object")
                            throw TypeError(".syft_proto.execution.v1.Plan.role: object expected");
                        message.role = $root.syft_proto.execution.v1.Role.fromObject(object.role);
                    }
                    if (object.include_state != null)
                        message.include_state = Boolean(object.include_state);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".syft_proto.execution.v1.Plan.tags: array expected");
                        message.tags = [];
                        for (var i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.torchscript != null)
                        if (typeof object.torchscript === "string")
                            $util.base64.decode(object.torchscript, message.torchscript = $util.newBuffer($util.base64.length(object.torchscript)), 0);
                        else if (object.torchscript.length)
                            message.torchscript = object.torchscript;
                    if (object.input_types != null) {
                        if (typeof object.input_types !== "object")
                            throw TypeError(".syft_proto.execution.v1.Plan.input_types: object expected");
                        message.input_types = $root.syft_proto.execution.v1.NestedTypeWrapper.fromObject(object.input_types);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Plan message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.Plan
                 * @static
                 * @param {syft_proto.execution.v1.Plan} message Plan
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Plan.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.tags = [];
                    if (options.defaults) {
                        object.id = null;
                        object.role = null;
                        object.include_state = false;
                        object.name = "";
                        object.description = "";
                        if (options.bytes === String)
                            object.torchscript = "";
                        else {
                            object.torchscript = [];
                            if (options.bytes !== Array)
                                object.torchscript = $util.newBuffer(object.torchscript);
                        }
                        object.input_types = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                    if (message.role != null && message.hasOwnProperty("role"))
                        object.role = $root.syft_proto.execution.v1.Role.toObject(message.role, options);
                    if (message.include_state != null && message.hasOwnProperty("include_state"))
                        object.include_state = message.include_state;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (var j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.torchscript != null && message.hasOwnProperty("torchscript"))
                        object.torchscript = options.bytes === String ? $util.base64.encode(message.torchscript, 0, message.torchscript.length) : options.bytes === Array ? Array.prototype.slice.call(message.torchscript) : message.torchscript;
                    if (message.input_types != null && message.hasOwnProperty("input_types"))
                        object.input_types = $root.syft_proto.execution.v1.NestedTypeWrapper.toObject(message.input_types, options);
                    return object;
                };

                /**
                 * Converts this Plan to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.Plan
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Plan.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return Plan;
            })();

            v1.Role = (function() {

                /**
                 * Properties of a Role.
                 * @memberof syft_proto.execution.v1
                 * @interface IRole
                 * @property {syft_proto.types.syft.v1.IId|null} [id] Role id
                 * @property {Array.<syft_proto.execution.v1.IComputationAction>|null} [actions] Role actions
                 * @property {syft_proto.execution.v1.IState|null} [state] Role state
                 * @property {Array.<syft_proto.execution.v1.IPlaceholder>|null} [placeholders] Role placeholders
                 * @property {Array.<syft_proto.types.syft.v1.IId>|null} [input_placeholder_ids] Role input_placeholder_ids
                 * @property {Array.<syft_proto.types.syft.v1.IId>|null} [output_placeholder_ids] Role output_placeholder_ids
                 * @property {Array.<string>|null} [tags] Role tags
                 * @property {string|null} [description] Role description
                 */

                /**
                 * Constructs a new Role.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a Role.
                 * @implements IRole
                 * @constructor
                 * @param {syft_proto.execution.v1.IRole=} [properties] Properties to set
                 */
                function Role(properties) {
                    this.actions = [];
                    this.placeholders = [];
                    this.input_placeholder_ids = [];
                    this.output_placeholder_ids = [];
                    this.tags = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Role id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 */
                Role.prototype.id = null;

                /**
                 * Role actions.
                 * @member {Array.<syft_proto.execution.v1.IComputationAction>} actions
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 */
                Role.prototype.actions = $util.emptyArray;

                /**
                 * Role state.
                 * @member {syft_proto.execution.v1.IState|null|undefined} state
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 */
                Role.prototype.state = null;

                /**
                 * Role placeholders.
                 * @member {Array.<syft_proto.execution.v1.IPlaceholder>} placeholders
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 */
                Role.prototype.placeholders = $util.emptyArray;

                /**
                 * Role input_placeholder_ids.
                 * @member {Array.<syft_proto.types.syft.v1.IId>} input_placeholder_ids
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 */
                Role.prototype.input_placeholder_ids = $util.emptyArray;

                /**
                 * Role output_placeholder_ids.
                 * @member {Array.<syft_proto.types.syft.v1.IId>} output_placeholder_ids
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 */
                Role.prototype.output_placeholder_ids = $util.emptyArray;

                /**
                 * Role tags.
                 * @member {Array.<string>} tags
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 */
                Role.prototype.tags = $util.emptyArray;

                /**
                 * Role description.
                 * @member {string} description
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 */
                Role.prototype.description = "";

                /**
                 * Creates a new Role instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.Role
                 * @static
                 * @param {syft_proto.execution.v1.IRole=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.Role} Role instance
                 */
                Role.create = function create(properties) {
                    return new Role(properties);
                };

                /**
                 * Encodes the specified Role message. Does not implicitly {@link syft_proto.execution.v1.Role.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.Role
                 * @static
                 * @param {syft_proto.execution.v1.IRole} message Role message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Role.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.actions != null && message.actions.length)
                        for (var i = 0; i < message.actions.length; ++i)
                            $root.syft_proto.execution.v1.ComputationAction.encode(message.actions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.state != null && message.hasOwnProperty("state"))
                        $root.syft_proto.execution.v1.State.encode(message.state, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.placeholders != null && message.placeholders.length)
                        for (var i = 0; i < message.placeholders.length; ++i)
                            $root.syft_proto.execution.v1.Placeholder.encode(message.placeholders[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.input_placeholder_ids != null && message.input_placeholder_ids.length)
                        for (var i = 0; i < message.input_placeholder_ids.length; ++i)
                            $root.syft_proto.types.syft.v1.Id.encode(message.input_placeholder_ids[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.output_placeholder_ids != null && message.output_placeholder_ids.length)
                        for (var i = 0; i < message.output_placeholder_ids.length; ++i)
                            $root.syft_proto.types.syft.v1.Id.encode(message.output_placeholder_ids[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.tags[i]);
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.description);
                    return writer;
                };

                /**
                 * Encodes the specified Role message, length delimited. Does not implicitly {@link syft_proto.execution.v1.Role.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.Role
                 * @static
                 * @param {syft_proto.execution.v1.IRole} message Role message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Role.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Role message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.Role
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.Role} Role
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Role.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.Role();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.actions && message.actions.length))
                                message.actions = [];
                            message.actions.push($root.syft_proto.execution.v1.ComputationAction.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.state = $root.syft_proto.execution.v1.State.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.placeholders && message.placeholders.length))
                                message.placeholders = [];
                            message.placeholders.push($root.syft_proto.execution.v1.Placeholder.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.input_placeholder_ids && message.input_placeholder_ids.length))
                                message.input_placeholder_ids = [];
                            message.input_placeholder_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.output_placeholder_ids && message.output_placeholder_ids.length))
                                message.output_placeholder_ids = [];
                            message.output_placeholder_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        case 8:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Role message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.Role
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.Role} Role
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Role.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Role message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.Role
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Role.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.actions != null && message.hasOwnProperty("actions")) {
                        if (!Array.isArray(message.actions))
                            return "actions: array expected";
                        for (var i = 0; i < message.actions.length; ++i) {
                            var error = $root.syft_proto.execution.v1.ComputationAction.verify(message.actions[i]);
                            if (error)
                                return "actions." + error;
                        }
                    }
                    if (message.state != null && message.hasOwnProperty("state")) {
                        var error = $root.syft_proto.execution.v1.State.verify(message.state);
                        if (error)
                            return "state." + error;
                    }
                    if (message.placeholders != null && message.hasOwnProperty("placeholders")) {
                        if (!Array.isArray(message.placeholders))
                            return "placeholders: array expected";
                        for (var i = 0; i < message.placeholders.length; ++i) {
                            var error = $root.syft_proto.execution.v1.Placeholder.verify(message.placeholders[i]);
                            if (error)
                                return "placeholders." + error;
                        }
                    }
                    if (message.input_placeholder_ids != null && message.hasOwnProperty("input_placeholder_ids")) {
                        if (!Array.isArray(message.input_placeholder_ids))
                            return "input_placeholder_ids: array expected";
                        for (var i = 0; i < message.input_placeholder_ids.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.input_placeholder_ids[i]);
                            if (error)
                                return "input_placeholder_ids." + error;
                        }
                    }
                    if (message.output_placeholder_ids != null && message.hasOwnProperty("output_placeholder_ids")) {
                        if (!Array.isArray(message.output_placeholder_ids))
                            return "output_placeholder_ids: array expected";
                        for (var i = 0; i < message.output_placeholder_ids.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.output_placeholder_ids[i]);
                            if (error)
                                return "output_placeholder_ids." + error;
                        }
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };

                /**
                 * Creates a Role message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.Role
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.Role} Role
                 */
                Role.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.Role)
                        return object;
                    var message = new $root.syft_proto.execution.v1.Role();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".syft_proto.execution.v1.Role.id: object expected");
                        message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                    }
                    if (object.actions) {
                        if (!Array.isArray(object.actions))
                            throw TypeError(".syft_proto.execution.v1.Role.actions: array expected");
                        message.actions = [];
                        for (var i = 0; i < object.actions.length; ++i) {
                            if (typeof object.actions[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.Role.actions: object expected");
                            message.actions[i] = $root.syft_proto.execution.v1.ComputationAction.fromObject(object.actions[i]);
                        }
                    }
                    if (object.state != null) {
                        if (typeof object.state !== "object")
                            throw TypeError(".syft_proto.execution.v1.Role.state: object expected");
                        message.state = $root.syft_proto.execution.v1.State.fromObject(object.state);
                    }
                    if (object.placeholders) {
                        if (!Array.isArray(object.placeholders))
                            throw TypeError(".syft_proto.execution.v1.Role.placeholders: array expected");
                        message.placeholders = [];
                        for (var i = 0; i < object.placeholders.length; ++i) {
                            if (typeof object.placeholders[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.Role.placeholders: object expected");
                            message.placeholders[i] = $root.syft_proto.execution.v1.Placeholder.fromObject(object.placeholders[i]);
                        }
                    }
                    if (object.input_placeholder_ids) {
                        if (!Array.isArray(object.input_placeholder_ids))
                            throw TypeError(".syft_proto.execution.v1.Role.input_placeholder_ids: array expected");
                        message.input_placeholder_ids = [];
                        for (var i = 0; i < object.input_placeholder_ids.length; ++i) {
                            if (typeof object.input_placeholder_ids[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.Role.input_placeholder_ids: object expected");
                            message.input_placeholder_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.input_placeholder_ids[i]);
                        }
                    }
                    if (object.output_placeholder_ids) {
                        if (!Array.isArray(object.output_placeholder_ids))
                            throw TypeError(".syft_proto.execution.v1.Role.output_placeholder_ids: array expected");
                        message.output_placeholder_ids = [];
                        for (var i = 0; i < object.output_placeholder_ids.length; ++i) {
                            if (typeof object.output_placeholder_ids[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.Role.output_placeholder_ids: object expected");
                            message.output_placeholder_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.output_placeholder_ids[i]);
                        }
                    }
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".syft_proto.execution.v1.Role.tags: array expected");
                        message.tags = [];
                        for (var i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };

                /**
                 * Creates a plain object from a Role message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.Role
                 * @static
                 * @param {syft_proto.execution.v1.Role} message Role
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Role.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.actions = [];
                        object.placeholders = [];
                        object.input_placeholder_ids = [];
                        object.output_placeholder_ids = [];
                        object.tags = [];
                    }
                    if (options.defaults) {
                        object.id = null;
                        object.state = null;
                        object.description = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                    if (message.actions && message.actions.length) {
                        object.actions = [];
                        for (var j = 0; j < message.actions.length; ++j)
                            object.actions[j] = $root.syft_proto.execution.v1.ComputationAction.toObject(message.actions[j], options);
                    }
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = $root.syft_proto.execution.v1.State.toObject(message.state, options);
                    if (message.placeholders && message.placeholders.length) {
                        object.placeholders = [];
                        for (var j = 0; j < message.placeholders.length; ++j)
                            object.placeholders[j] = $root.syft_proto.execution.v1.Placeholder.toObject(message.placeholders[j], options);
                    }
                    if (message.input_placeholder_ids && message.input_placeholder_ids.length) {
                        object.input_placeholder_ids = [];
                        for (var j = 0; j < message.input_placeholder_ids.length; ++j)
                            object.input_placeholder_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.input_placeholder_ids[j], options);
                    }
                    if (message.output_placeholder_ids && message.output_placeholder_ids.length) {
                        object.output_placeholder_ids = [];
                        for (var j = 0; j < message.output_placeholder_ids.length; ++j)
                            object.output_placeholder_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.output_placeholder_ids[j], options);
                    }
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (var j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };

                /**
                 * Converts this Role to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.Role
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Role.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return Role;
            })();

            v1.State = (function() {

                /**
                 * Properties of a State.
                 * @memberof syft_proto.execution.v1
                 * @interface IState
                 * @property {Array.<syft_proto.execution.v1.IPlaceholder>|null} [placeholders] State placeholders
                 * @property {Array.<syft_proto.execution.v1.IStateTensor>|null} [tensors] State tensors
                 */

                /**
                 * Constructs a new State.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a State.
                 * @implements IState
                 * @constructor
                 * @param {syft_proto.execution.v1.IState=} [properties] Properties to set
                 */
                function State(properties) {
                    this.placeholders = [];
                    this.tensors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * State placeholders.
                 * @member {Array.<syft_proto.execution.v1.IPlaceholder>} placeholders
                 * @memberof syft_proto.execution.v1.State
                 * @instance
                 */
                State.prototype.placeholders = $util.emptyArray;

                /**
                 * State tensors.
                 * @member {Array.<syft_proto.execution.v1.IStateTensor>} tensors
                 * @memberof syft_proto.execution.v1.State
                 * @instance
                 */
                State.prototype.tensors = $util.emptyArray;

                /**
                 * Creates a new State instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.State
                 * @static
                 * @param {syft_proto.execution.v1.IState=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.State} State instance
                 */
                State.create = function create(properties) {
                    return new State(properties);
                };

                /**
                 * Encodes the specified State message. Does not implicitly {@link syft_proto.execution.v1.State.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.State
                 * @static
                 * @param {syft_proto.execution.v1.IState} message State message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                State.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.placeholders != null && message.placeholders.length)
                        for (var i = 0; i < message.placeholders.length; ++i)
                            $root.syft_proto.execution.v1.Placeholder.encode(message.placeholders[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.tensors != null && message.tensors.length)
                        for (var i = 0; i < message.tensors.length; ++i)
                            $root.syft_proto.execution.v1.StateTensor.encode(message.tensors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified State message, length delimited. Does not implicitly {@link syft_proto.execution.v1.State.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.State
                 * @static
                 * @param {syft_proto.execution.v1.IState} message State message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                State.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a State message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.State
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.State} State
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                State.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.State();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.placeholders && message.placeholders.length))
                                message.placeholders = [];
                            message.placeholders.push($root.syft_proto.execution.v1.Placeholder.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.tensors && message.tensors.length))
                                message.tensors = [];
                            message.tensors.push($root.syft_proto.execution.v1.StateTensor.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a State message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.State
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.State} State
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                State.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a State message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.State
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                State.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.placeholders != null && message.hasOwnProperty("placeholders")) {
                        if (!Array.isArray(message.placeholders))
                            return "placeholders: array expected";
                        for (var i = 0; i < message.placeholders.length; ++i) {
                            var error = $root.syft_proto.execution.v1.Placeholder.verify(message.placeholders[i]);
                            if (error)
                                return "placeholders." + error;
                        }
                    }
                    if (message.tensors != null && message.hasOwnProperty("tensors")) {
                        if (!Array.isArray(message.tensors))
                            return "tensors: array expected";
                        for (var i = 0; i < message.tensors.length; ++i) {
                            var error = $root.syft_proto.execution.v1.StateTensor.verify(message.tensors[i]);
                            if (error)
                                return "tensors." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a State message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.State
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.State} State
                 */
                State.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.State)
                        return object;
                    var message = new $root.syft_proto.execution.v1.State();
                    if (object.placeholders) {
                        if (!Array.isArray(object.placeholders))
                            throw TypeError(".syft_proto.execution.v1.State.placeholders: array expected");
                        message.placeholders = [];
                        for (var i = 0; i < object.placeholders.length; ++i) {
                            if (typeof object.placeholders[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.State.placeholders: object expected");
                            message.placeholders[i] = $root.syft_proto.execution.v1.Placeholder.fromObject(object.placeholders[i]);
                        }
                    }
                    if (object.tensors) {
                        if (!Array.isArray(object.tensors))
                            throw TypeError(".syft_proto.execution.v1.State.tensors: array expected");
                        message.tensors = [];
                        for (var i = 0; i < object.tensors.length; ++i) {
                            if (typeof object.tensors[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.State.tensors: object expected");
                            message.tensors[i] = $root.syft_proto.execution.v1.StateTensor.fromObject(object.tensors[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a State message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.State
                 * @static
                 * @param {syft_proto.execution.v1.State} message State
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                State.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.placeholders = [];
                        object.tensors = [];
                    }
                    if (message.placeholders && message.placeholders.length) {
                        object.placeholders = [];
                        for (var j = 0; j < message.placeholders.length; ++j)
                            object.placeholders[j] = $root.syft_proto.execution.v1.Placeholder.toObject(message.placeholders[j], options);
                    }
                    if (message.tensors && message.tensors.length) {
                        object.tensors = [];
                        for (var j = 0; j < message.tensors.length; ++j)
                            object.tensors[j] = $root.syft_proto.execution.v1.StateTensor.toObject(message.tensors[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this State to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.State
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                State.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return State;
            })();

            v1.StateTensor = (function() {

                /**
                 * Properties of a StateTensor.
                 * @memberof syft_proto.execution.v1
                 * @interface IStateTensor
                 * @property {syft_proto.types.torch.v1.ITorchTensor|null} [torch_tensor] StateTensor torch_tensor
                 * @property {syft_proto.types.torch.v1.IParameter|null} [torch_param] StateTensor torch_param
                 */

                /**
                 * Constructs a new StateTensor.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a StateTensor.
                 * @implements IStateTensor
                 * @constructor
                 * @param {syft_proto.execution.v1.IStateTensor=} [properties] Properties to set
                 */
                function StateTensor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StateTensor torch_tensor.
                 * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} torch_tensor
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @instance
                 */
                StateTensor.prototype.torch_tensor = null;

                /**
                 * StateTensor torch_param.
                 * @member {syft_proto.types.torch.v1.IParameter|null|undefined} torch_param
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @instance
                 */
                StateTensor.prototype.torch_param = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * StateTensor tensor.
                 * @member {"torch_tensor"|"torch_param"|undefined} tensor
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @instance
                 */
                Object.defineProperty(StateTensor.prototype, "tensor", {
                    get: $util.oneOfGetter($oneOfFields = ["torch_tensor", "torch_param"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new StateTensor instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @static
                 * @param {syft_proto.execution.v1.IStateTensor=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.StateTensor} StateTensor instance
                 */
                StateTensor.create = function create(properties) {
                    return new StateTensor(properties);
                };

                /**
                 * Encodes the specified StateTensor message. Does not implicitly {@link syft_proto.execution.v1.StateTensor.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @static
                 * @param {syft_proto.execution.v1.IStateTensor} message StateTensor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StateTensor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.torch_tensor != null && message.hasOwnProperty("torch_tensor"))
                        $root.syft_proto.types.torch.v1.TorchTensor.encode(message.torch_tensor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.torch_param != null && message.hasOwnProperty("torch_param"))
                        $root.syft_proto.types.torch.v1.Parameter.encode(message.torch_param, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StateTensor message, length delimited. Does not implicitly {@link syft_proto.execution.v1.StateTensor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @static
                 * @param {syft_proto.execution.v1.IStateTensor} message StateTensor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StateTensor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StateTensor message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.StateTensor} StateTensor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StateTensor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.StateTensor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.torch_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.torch_param = $root.syft_proto.types.torch.v1.Parameter.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StateTensor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.StateTensor} StateTensor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StateTensor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StateTensor message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StateTensor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.torch_tensor != null && message.hasOwnProperty("torch_tensor")) {
                        properties.tensor = 1;
                        {
                            var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.torch_tensor);
                            if (error)
                                return "torch_tensor." + error;
                        }
                    }
                    if (message.torch_param != null && message.hasOwnProperty("torch_param")) {
                        if (properties.tensor === 1)
                            return "tensor: multiple values";
                        properties.tensor = 1;
                        {
                            var error = $root.syft_proto.types.torch.v1.Parameter.verify(message.torch_param);
                            if (error)
                                return "torch_param." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a StateTensor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.StateTensor} StateTensor
                 */
                StateTensor.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.StateTensor)
                        return object;
                    var message = new $root.syft_proto.execution.v1.StateTensor();
                    if (object.torch_tensor != null) {
                        if (typeof object.torch_tensor !== "object")
                            throw TypeError(".syft_proto.execution.v1.StateTensor.torch_tensor: object expected");
                        message.torch_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.torch_tensor);
                    }
                    if (object.torch_param != null) {
                        if (typeof object.torch_param !== "object")
                            throw TypeError(".syft_proto.execution.v1.StateTensor.torch_param: object expected");
                        message.torch_param = $root.syft_proto.types.torch.v1.Parameter.fromObject(object.torch_param);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StateTensor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @static
                 * @param {syft_proto.execution.v1.StateTensor} message StateTensor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StateTensor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.torch_tensor != null && message.hasOwnProperty("torch_tensor")) {
                        object.torch_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.torch_tensor, options);
                        if (options.oneofs)
                            object.tensor = "torch_tensor";
                    }
                    if (message.torch_param != null && message.hasOwnProperty("torch_param")) {
                        object.torch_param = $root.syft_proto.types.torch.v1.Parameter.toObject(message.torch_param, options);
                        if (options.oneofs)
                            object.tensor = "torch_param";
                    }
                    return object;
                };

                /**
                 * Converts this StateTensor to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.StateTensor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StateTensor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return StateTensor;
            })();

            v1.InputTypeDescriptor = (function() {

                /**
                 * Properties of an InputTypeDescriptor.
                 * @memberof syft_proto.execution.v1
                 * @interface IInputTypeDescriptor
                 * @property {string|null} [type_name] InputTypeDescriptor type_name
                 */

                /**
                 * Constructs a new InputTypeDescriptor.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents an InputTypeDescriptor.
                 * @implements IInputTypeDescriptor
                 * @constructor
                 * @param {syft_proto.execution.v1.IInputTypeDescriptor=} [properties] Properties to set
                 */
                function InputTypeDescriptor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InputTypeDescriptor type_name.
                 * @member {string} type_name
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @instance
                 */
                InputTypeDescriptor.prototype.type_name = "";

                /**
                 * Creates a new InputTypeDescriptor instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @static
                 * @param {syft_proto.execution.v1.IInputTypeDescriptor=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.InputTypeDescriptor} InputTypeDescriptor instance
                 */
                InputTypeDescriptor.create = function create(properties) {
                    return new InputTypeDescriptor(properties);
                };

                /**
                 * Encodes the specified InputTypeDescriptor message. Does not implicitly {@link syft_proto.execution.v1.InputTypeDescriptor.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @static
                 * @param {syft_proto.execution.v1.IInputTypeDescriptor} message InputTypeDescriptor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InputTypeDescriptor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_name);
                    return writer;
                };

                /**
                 * Encodes the specified InputTypeDescriptor message, length delimited. Does not implicitly {@link syft_proto.execution.v1.InputTypeDescriptor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @static
                 * @param {syft_proto.execution.v1.IInputTypeDescriptor} message InputTypeDescriptor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InputTypeDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InputTypeDescriptor message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.InputTypeDescriptor} InputTypeDescriptor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InputTypeDescriptor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.InputTypeDescriptor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type_name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InputTypeDescriptor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.InputTypeDescriptor} InputTypeDescriptor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InputTypeDescriptor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InputTypeDescriptor message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InputTypeDescriptor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    return null;
                };

                /**
                 * Creates an InputTypeDescriptor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.InputTypeDescriptor} InputTypeDescriptor
                 */
                InputTypeDescriptor.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.InputTypeDescriptor)
                        return object;
                    var message = new $root.syft_proto.execution.v1.InputTypeDescriptor();
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    return message;
                };

                /**
                 * Creates a plain object from an InputTypeDescriptor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @static
                 * @param {syft_proto.execution.v1.InputTypeDescriptor} message InputTypeDescriptor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InputTypeDescriptor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.type_name = "";
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    return object;
                };

                /**
                 * Converts this InputTypeDescriptor to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.InputTypeDescriptor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InputTypeDescriptor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return InputTypeDescriptor;
            })();

            v1.NestedTypeWrapper = (function() {

                /**
                 * Properties of a NestedTypeWrapper.
                 * @memberof syft_proto.execution.v1
                 * @interface INestedTypeWrapper
                 * @property {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer|null} [nested_types] NestedTypeWrapper nested_types
                 */

                /**
                 * Constructs a new NestedTypeWrapper.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a NestedTypeWrapper.
                 * @implements INestedTypeWrapper
                 * @constructor
                 * @param {syft_proto.execution.v1.INestedTypeWrapper=} [properties] Properties to set
                 */
                function NestedTypeWrapper(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NestedTypeWrapper nested_types.
                 * @member {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer|null|undefined} nested_types
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @instance
                 */
                NestedTypeWrapper.prototype.nested_types = null;

                /**
                 * Creates a new NestedTypeWrapper instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @static
                 * @param {syft_proto.execution.v1.INestedTypeWrapper=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.NestedTypeWrapper} NestedTypeWrapper instance
                 */
                NestedTypeWrapper.create = function create(properties) {
                    return new NestedTypeWrapper(properties);
                };

                /**
                 * Encodes the specified NestedTypeWrapper message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @static
                 * @param {syft_proto.execution.v1.INestedTypeWrapper} message NestedTypeWrapper message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NestedTypeWrapper.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nested_types != null && message.hasOwnProperty("nested_types"))
                        $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.encode(message.nested_types, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified NestedTypeWrapper message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @static
                 * @param {syft_proto.execution.v1.INestedTypeWrapper} message NestedTypeWrapper message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NestedTypeWrapper.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NestedTypeWrapper message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.NestedTypeWrapper} NestedTypeWrapper
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NestedTypeWrapper.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nested_types = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NestedTypeWrapper message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.NestedTypeWrapper} NestedTypeWrapper
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NestedTypeWrapper.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NestedTypeWrapper message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NestedTypeWrapper.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nested_types != null && message.hasOwnProperty("nested_types")) {
                        var error = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.verify(message.nested_types);
                        if (error)
                            return "nested_types." + error;
                    }
                    return null;
                };

                /**
                 * Creates a NestedTypeWrapper message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.NestedTypeWrapper} NestedTypeWrapper
                 */
                NestedTypeWrapper.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper)
                        return object;
                    var message = new $root.syft_proto.execution.v1.NestedTypeWrapper();
                    if (object.nested_types != null) {
                        if (typeof object.nested_types !== "object")
                            throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.nested_types: object expected");
                        message.nested_types = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.fromObject(object.nested_types);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a NestedTypeWrapper message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @static
                 * @param {syft_proto.execution.v1.NestedTypeWrapper} message NestedTypeWrapper
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NestedTypeWrapper.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.nested_types = null;
                    if (message.nested_types != null && message.hasOwnProperty("nested_types"))
                        object.nested_types = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.toObject(message.nested_types, options);
                    return object;
                };

                /**
                 * Converts this NestedTypeWrapper to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.NestedTypeWrapper
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NestedTypeWrapper.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                NestedTypeWrapper.TypeList = (function() {

                    /**
                     * Properties of a TypeList.
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper
                     * @interface ITypeList
                     * @property {Array.<syft_proto.execution.v1.INestedTypeWrapper>|null} [nested_types] TypeList nested_types
                     */

                    /**
                     * Constructs a new TypeList.
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper
                     * @classdesc Represents a TypeList.
                     * @implements ITypeList
                     * @constructor
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeList=} [properties] Properties to set
                     */
                    function TypeList(properties) {
                        this.nested_types = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TypeList nested_types.
                     * @member {Array.<syft_proto.execution.v1.INestedTypeWrapper>} nested_types
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @instance
                     */
                    TypeList.prototype.nested_types = $util.emptyArray;

                    /**
                     * Creates a new TypeList instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeList=} [properties] Properties to set
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeList} TypeList instance
                     */
                    TypeList.create = function create(properties) {
                        return new TypeList(properties);
                    };

                    /**
                     * Encodes the specified TypeList message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeList.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeList} message TypeList message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeList.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nested_types != null && message.nested_types.length)
                            for (var i = 0; i < message.nested_types.length; ++i)
                                $root.syft_proto.execution.v1.NestedTypeWrapper.encode(message.nested_types[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified TypeList message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeList.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeList} message TypeList message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeList.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TypeList message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeList} TypeList
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeList.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.nested_types && message.nested_types.length))
                                    message.nested_types = [];
                                message.nested_types.push($root.syft_proto.execution.v1.NestedTypeWrapper.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TypeList message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeList} TypeList
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeList.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TypeList message.
                     * @function verify
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TypeList.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nested_types != null && message.hasOwnProperty("nested_types")) {
                            if (!Array.isArray(message.nested_types))
                                return "nested_types: array expected";
                            for (var i = 0; i < message.nested_types.length; ++i) {
                                var error = $root.syft_proto.execution.v1.NestedTypeWrapper.verify(message.nested_types[i]);
                                if (error)
                                    return "nested_types." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a TypeList message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeList} TypeList
                     */
                    TypeList.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList)
                            return object;
                        var message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList();
                        if (object.nested_types) {
                            if (!Array.isArray(object.nested_types))
                                throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeList.nested_types: array expected");
                            message.nested_types = [];
                            for (var i = 0; i < object.nested_types.length; ++i) {
                                if (typeof object.nested_types[i] !== "object")
                                    throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeList.nested_types: object expected");
                                message.nested_types[i] = $root.syft_proto.execution.v1.NestedTypeWrapper.fromObject(object.nested_types[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TypeList message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.TypeList} message TypeList
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TypeList.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.nested_types = [];
                        if (message.nested_types && message.nested_types.length) {
                            object.nested_types = [];
                            for (var j = 0; j < message.nested_types.length; ++j)
                                object.nested_types[j] = $root.syft_proto.execution.v1.NestedTypeWrapper.toObject(message.nested_types[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this TypeList to JSON.
                     * @function toJSON
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TypeList.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return TypeList;
                })();

                NestedTypeWrapper.TypeTuple = (function() {

                    /**
                     * Properties of a TypeTuple.
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper
                     * @interface ITypeTuple
                     * @property {Array.<syft_proto.execution.v1.INestedTypeWrapper>|null} [nested_types] TypeTuple nested_types
                     */

                    /**
                     * Constructs a new TypeTuple.
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper
                     * @classdesc Represents a TypeTuple.
                     * @implements ITypeTuple
                     * @constructor
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple=} [properties] Properties to set
                     */
                    function TypeTuple(properties) {
                        this.nested_types = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TypeTuple nested_types.
                     * @member {Array.<syft_proto.execution.v1.INestedTypeWrapper>} nested_types
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @instance
                     */
                    TypeTuple.prototype.nested_types = $util.emptyArray;

                    /**
                     * Creates a new TypeTuple instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple=} [properties] Properties to set
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} TypeTuple instance
                     */
                    TypeTuple.create = function create(properties) {
                        return new TypeTuple(properties);
                    };

                    /**
                     * Encodes the specified TypeTuple message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple} message TypeTuple message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeTuple.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nested_types != null && message.nested_types.length)
                            for (var i = 0; i < message.nested_types.length; ++i)
                                $root.syft_proto.execution.v1.NestedTypeWrapper.encode(message.nested_types[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified TypeTuple message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple} message TypeTuple message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeTuple.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TypeTuple message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} TypeTuple
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeTuple.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.nested_types && message.nested_types.length))
                                    message.nested_types = [];
                                message.nested_types.push($root.syft_proto.execution.v1.NestedTypeWrapper.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TypeTuple message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} TypeTuple
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeTuple.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TypeTuple message.
                     * @function verify
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TypeTuple.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nested_types != null && message.hasOwnProperty("nested_types")) {
                            if (!Array.isArray(message.nested_types))
                                return "nested_types: array expected";
                            for (var i = 0; i < message.nested_types.length; ++i) {
                                var error = $root.syft_proto.execution.v1.NestedTypeWrapper.verify(message.nested_types[i]);
                                if (error)
                                    return "nested_types." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a TypeTuple message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} TypeTuple
                     */
                    TypeTuple.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple)
                            return object;
                        var message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple();
                        if (object.nested_types) {
                            if (!Array.isArray(object.nested_types))
                                throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.nested_types: array expected");
                            message.nested_types = [];
                            for (var i = 0; i < object.nested_types.length; ++i) {
                                if (typeof object.nested_types[i] !== "object")
                                    throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.nested_types: object expected");
                                message.nested_types[i] = $root.syft_proto.execution.v1.NestedTypeWrapper.fromObject(object.nested_types[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TypeTuple message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} message TypeTuple
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TypeTuple.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.nested_types = [];
                        if (message.nested_types && message.nested_types.length) {
                            object.nested_types = [];
                            for (var j = 0; j < message.nested_types.length; ++j)
                                object.nested_types[j] = $root.syft_proto.execution.v1.NestedTypeWrapper.toObject(message.nested_types[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this TypeTuple to JSON.
                     * @function toJSON
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TypeTuple.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return TypeTuple;
                })();

                NestedTypeWrapper.TypeMap = (function() {

                    /**
                     * Properties of a TypeMap.
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper
                     * @interface ITypeMap
                     * @property {Object.<string,syft_proto.execution.v1.INestedTypeWrapper>|null} [nested_types] TypeMap nested_types
                     */

                    /**
                     * Constructs a new TypeMap.
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper
                     * @classdesc Represents a TypeMap.
                     * @implements ITypeMap
                     * @constructor
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap=} [properties] Properties to set
                     */
                    function TypeMap(properties) {
                        this.nested_types = {};
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TypeMap nested_types.
                     * @member {Object.<string,syft_proto.execution.v1.INestedTypeWrapper>} nested_types
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @instance
                     */
                    TypeMap.prototype.nested_types = $util.emptyObject;

                    /**
                     * Creates a new TypeMap instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap=} [properties] Properties to set
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} TypeMap instance
                     */
                    TypeMap.create = function create(properties) {
                        return new TypeMap(properties);
                    };

                    /**
                     * Encodes the specified TypeMap message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeMap.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap} message TypeMap message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeMap.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nested_types != null && message.hasOwnProperty("nested_types"))
                            for (var keys = Object.keys(message.nested_types), i = 0; i < keys.length; ++i) {
                                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                                $root.syft_proto.execution.v1.NestedTypeWrapper.encode(message.nested_types[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                            }
                        return writer;
                    };

                    /**
                     * Encodes the specified TypeMap message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeMap.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap} message TypeMap message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeMap.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TypeMap message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} TypeMap
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeMap.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap(), key;
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                reader.skip().pos++;
                                if (message.nested_types === $util.emptyObject)
                                    message.nested_types = {};
                                key = reader.string();
                                reader.pos++;
                                message.nested_types[key] = $root.syft_proto.execution.v1.NestedTypeWrapper.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TypeMap message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} TypeMap
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeMap.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TypeMap message.
                     * @function verify
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TypeMap.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nested_types != null && message.hasOwnProperty("nested_types")) {
                            if (!$util.isObject(message.nested_types))
                                return "nested_types: object expected";
                            var key = Object.keys(message.nested_types);
                            for (var i = 0; i < key.length; ++i) {
                                var error = $root.syft_proto.execution.v1.NestedTypeWrapper.verify(message.nested_types[key[i]]);
                                if (error)
                                    return "nested_types." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a TypeMap message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} TypeMap
                     */
                    TypeMap.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap)
                            return object;
                        var message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap();
                        if (object.nested_types) {
                            if (typeof object.nested_types !== "object")
                                throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeMap.nested_types: object expected");
                            message.nested_types = {};
                            for (var keys = Object.keys(object.nested_types), i = 0; i < keys.length; ++i) {
                                if (typeof object.nested_types[keys[i]] !== "object")
                                    throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeMap.nested_types: object expected");
                                message.nested_types[keys[i]] = $root.syft_proto.execution.v1.NestedTypeWrapper.fromObject(object.nested_types[keys[i]]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TypeMap message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} message TypeMap
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TypeMap.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.objects || options.defaults)
                            object.nested_types = {};
                        var keys2;
                        if (message.nested_types && (keys2 = Object.keys(message.nested_types)).length) {
                            object.nested_types = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.nested_types[keys2[j]] = $root.syft_proto.execution.v1.NestedTypeWrapper.toObject(message.nested_types[keys2[j]], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this TypeMap to JSON.
                     * @function toJSON
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TypeMap.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return TypeMap;
                })();

                NestedTypeWrapper.TypeContainer = (function() {

                    /**
                     * Properties of a TypeContainer.
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper
                     * @interface ITypeContainer
                     * @property {syft_proto.execution.v1.IInputTypeDescriptor|null} [nested_type] TypeContainer nested_type
                     * @property {syft_proto.execution.v1.NestedTypeWrapper.ITypeList|null} [nested_type_list] TypeContainer nested_type_list
                     * @property {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple|null} [nested_type_tuple] TypeContainer nested_type_tuple
                     * @property {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap|null} [nested_type_dict] TypeContainer nested_type_dict
                     */

                    /**
                     * Constructs a new TypeContainer.
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper
                     * @classdesc Represents a TypeContainer.
                     * @implements ITypeContainer
                     * @constructor
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer=} [properties] Properties to set
                     */
                    function TypeContainer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TypeContainer nested_type.
                     * @member {syft_proto.execution.v1.IInputTypeDescriptor|null|undefined} nested_type
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @instance
                     */
                    TypeContainer.prototype.nested_type = null;

                    /**
                     * TypeContainer nested_type_list.
                     * @member {syft_proto.execution.v1.NestedTypeWrapper.ITypeList|null|undefined} nested_type_list
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @instance
                     */
                    TypeContainer.prototype.nested_type_list = null;

                    /**
                     * TypeContainer nested_type_tuple.
                     * @member {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple|null|undefined} nested_type_tuple
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @instance
                     */
                    TypeContainer.prototype.nested_type_tuple = null;

                    /**
                     * TypeContainer nested_type_dict.
                     * @member {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap|null|undefined} nested_type_dict
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @instance
                     */
                    TypeContainer.prototype.nested_type_dict = null;

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * TypeContainer nested_container.
                     * @member {"nested_type"|"nested_type_list"|"nested_type_tuple"|"nested_type_dict"|undefined} nested_container
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @instance
                     */
                    Object.defineProperty(TypeContainer.prototype, "nested_container", {
                        get: $util.oneOfGetter($oneOfFields = ["nested_type", "nested_type_list", "nested_type_tuple", "nested_type_dict"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new TypeContainer instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer=} [properties] Properties to set
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} TypeContainer instance
                     */
                    TypeContainer.create = function create(properties) {
                        return new TypeContainer(properties);
                    };

                    /**
                     * Encodes the specified TypeContainer message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer} message TypeContainer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeContainer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nested_type != null && message.hasOwnProperty("nested_type"))
                            $root.syft_proto.execution.v1.InputTypeDescriptor.encode(message.nested_type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.nested_type_list != null && message.hasOwnProperty("nested_type_list"))
                            $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.encode(message.nested_type_list, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.nested_type_tuple != null && message.hasOwnProperty("nested_type_tuple"))
                            $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.encode(message.nested_type_tuple, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.nested_type_dict != null && message.hasOwnProperty("nested_type_dict"))
                            $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.encode(message.nested_type_dict, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified TypeContainer message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer} message TypeContainer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeContainer.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TypeContainer message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} TypeContainer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeContainer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.nested_type = $root.syft_proto.execution.v1.InputTypeDescriptor.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.nested_type_list = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.nested_type_tuple = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.nested_type_dict = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TypeContainer message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} TypeContainer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeContainer.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TypeContainer message.
                     * @function verify
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TypeContainer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                            properties.nested_container = 1;
                            {
                                var error = $root.syft_proto.execution.v1.InputTypeDescriptor.verify(message.nested_type);
                                if (error)
                                    return "nested_type." + error;
                            }
                        }
                        if (message.nested_type_list != null && message.hasOwnProperty("nested_type_list")) {
                            if (properties.nested_container === 1)
                                return "nested_container: multiple values";
                            properties.nested_container = 1;
                            {
                                var error = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.verify(message.nested_type_list);
                                if (error)
                                    return "nested_type_list." + error;
                            }
                        }
                        if (message.nested_type_tuple != null && message.hasOwnProperty("nested_type_tuple")) {
                            if (properties.nested_container === 1)
                                return "nested_container: multiple values";
                            properties.nested_container = 1;
                            {
                                var error = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.verify(message.nested_type_tuple);
                                if (error)
                                    return "nested_type_tuple." + error;
                            }
                        }
                        if (message.nested_type_dict != null && message.hasOwnProperty("nested_type_dict")) {
                            if (properties.nested_container === 1)
                                return "nested_container: multiple values";
                            properties.nested_container = 1;
                            {
                                var error = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.verify(message.nested_type_dict);
                                if (error)
                                    return "nested_type_dict." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a TypeContainer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} TypeContainer
                     */
                    TypeContainer.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer)
                            return object;
                        var message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer();
                        if (object.nested_type != null) {
                            if (typeof object.nested_type !== "object")
                                throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.nested_type: object expected");
                            message.nested_type = $root.syft_proto.execution.v1.InputTypeDescriptor.fromObject(object.nested_type);
                        }
                        if (object.nested_type_list != null) {
                            if (typeof object.nested_type_list !== "object")
                                throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.nested_type_list: object expected");
                            message.nested_type_list = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.fromObject(object.nested_type_list);
                        }
                        if (object.nested_type_tuple != null) {
                            if (typeof object.nested_type_tuple !== "object")
                                throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.nested_type_tuple: object expected");
                            message.nested_type_tuple = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.fromObject(object.nested_type_tuple);
                        }
                        if (object.nested_type_dict != null) {
                            if (typeof object.nested_type_dict !== "object")
                                throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.nested_type_dict: object expected");
                            message.nested_type_dict = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.fromObject(object.nested_type_dict);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TypeContainer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @static
                     * @param {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} message TypeContainer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TypeContainer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                            object.nested_type = $root.syft_proto.execution.v1.InputTypeDescriptor.toObject(message.nested_type, options);
                            if (options.oneofs)
                                object.nested_container = "nested_type";
                        }
                        if (message.nested_type_list != null && message.hasOwnProperty("nested_type_list")) {
                            object.nested_type_list = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.toObject(message.nested_type_list, options);
                            if (options.oneofs)
                                object.nested_container = "nested_type_list";
                        }
                        if (message.nested_type_tuple != null && message.hasOwnProperty("nested_type_tuple")) {
                            object.nested_type_tuple = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.toObject(message.nested_type_tuple, options);
                            if (options.oneofs)
                                object.nested_container = "nested_type_tuple";
                        }
                        if (message.nested_type_dict != null && message.hasOwnProperty("nested_type_dict")) {
                            object.nested_type_dict = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.toObject(message.nested_type_dict, options);
                            if (options.oneofs)
                                object.nested_container = "nested_type_dict";
                        }
                        return object;
                    };

                    /**
                     * Converts this TypeContainer to JSON.
                     * @function toJSON
                     * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TypeContainer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return TypeContainer;
                })();

                return NestedTypeWrapper;
            })();

            v1.Protocol = (function() {

                /**
                 * Properties of a Protocol.
                 * @memberof syft_proto.execution.v1
                 * @interface IProtocol
                 * @property {syft_proto.types.syft.v1.IId|null} [id] Protocol id
                 * @property {string|null} [name] Protocol name
                 * @property {Object.<string,syft_proto.execution.v1.IRole>|null} [roles] Protocol roles
                 * @property {Array.<string>|null} [tags] Protocol tags
                 * @property {string|null} [description] Protocol description
                 */

                /**
                 * Constructs a new Protocol.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a Protocol.
                 * @implements IProtocol
                 * @constructor
                 * @param {syft_proto.execution.v1.IProtocol=} [properties] Properties to set
                 */
                function Protocol(properties) {
                    this.roles = {};
                    this.tags = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Protocol id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                 * @memberof syft_proto.execution.v1.Protocol
                 * @instance
                 */
                Protocol.prototype.id = null;

                /**
                 * Protocol name.
                 * @member {string} name
                 * @memberof syft_proto.execution.v1.Protocol
                 * @instance
                 */
                Protocol.prototype.name = "";

                /**
                 * Protocol roles.
                 * @member {Object.<string,syft_proto.execution.v1.IRole>} roles
                 * @memberof syft_proto.execution.v1.Protocol
                 * @instance
                 */
                Protocol.prototype.roles = $util.emptyObject;

                /**
                 * Protocol tags.
                 * @member {Array.<string>} tags
                 * @memberof syft_proto.execution.v1.Protocol
                 * @instance
                 */
                Protocol.prototype.tags = $util.emptyArray;

                /**
                 * Protocol description.
                 * @member {string} description
                 * @memberof syft_proto.execution.v1.Protocol
                 * @instance
                 */
                Protocol.prototype.description = "";

                /**
                 * Creates a new Protocol instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.Protocol
                 * @static
                 * @param {syft_proto.execution.v1.IProtocol=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.Protocol} Protocol instance
                 */
                Protocol.create = function create(properties) {
                    return new Protocol(properties);
                };

                /**
                 * Encodes the specified Protocol message. Does not implicitly {@link syft_proto.execution.v1.Protocol.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.Protocol
                 * @static
                 * @param {syft_proto.execution.v1.IProtocol} message Protocol message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Protocol.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.roles != null && message.hasOwnProperty("roles"))
                        for (var keys = Object.keys(message.roles), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.syft_proto.execution.v1.Role.encode(message.roles[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                    return writer;
                };

                /**
                 * Encodes the specified Protocol message, length delimited. Does not implicitly {@link syft_proto.execution.v1.Protocol.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.Protocol
                 * @static
                 * @param {syft_proto.execution.v1.IProtocol} message Protocol message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Protocol.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Protocol message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.Protocol
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.Protocol} Protocol
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Protocol.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.Protocol(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            reader.skip().pos++;
                            if (message.roles === $util.emptyObject)
                                message.roles = {};
                            key = reader.string();
                            reader.pos++;
                            message.roles[key] = $root.syft_proto.execution.v1.Role.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        case 5:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Protocol message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.Protocol
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.Protocol} Protocol
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Protocol.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Protocol message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.Protocol
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Protocol.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.roles != null && message.hasOwnProperty("roles")) {
                        if (!$util.isObject(message.roles))
                            return "roles: object expected";
                        var key = Object.keys(message.roles);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.syft_proto.execution.v1.Role.verify(message.roles[key[i]]);
                            if (error)
                                return "roles." + error;
                        }
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };

                /**
                 * Creates a Protocol message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.Protocol
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.Protocol} Protocol
                 */
                Protocol.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.Protocol)
                        return object;
                    var message = new $root.syft_proto.execution.v1.Protocol();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".syft_proto.execution.v1.Protocol.id: object expected");
                        message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.roles) {
                        if (typeof object.roles !== "object")
                            throw TypeError(".syft_proto.execution.v1.Protocol.roles: object expected");
                        message.roles = {};
                        for (var keys = Object.keys(object.roles), i = 0; i < keys.length; ++i) {
                            if (typeof object.roles[keys[i]] !== "object")
                                throw TypeError(".syft_proto.execution.v1.Protocol.roles: object expected");
                            message.roles[keys[i]] = $root.syft_proto.execution.v1.Role.fromObject(object.roles[keys[i]]);
                        }
                    }
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".syft_proto.execution.v1.Protocol.tags: array expected");
                        message.tags = [];
                        for (var i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };

                /**
                 * Creates a plain object from a Protocol message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.Protocol
                 * @static
                 * @param {syft_proto.execution.v1.Protocol} message Protocol
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Protocol.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.tags = [];
                    if (options.objects || options.defaults)
                        object.roles = {};
                    if (options.defaults) {
                        object.id = null;
                        object.name = "";
                        object.description = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    var keys2;
                    if (message.roles && (keys2 = Object.keys(message.roles)).length) {
                        object.roles = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.roles[keys2[j]] = $root.syft_proto.execution.v1.Role.toObject(message.roles[keys2[j]], options);
                    }
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (var j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };

                /**
                 * Converts this Protocol to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.Protocol
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Protocol.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return Protocol;
            })();

            v1.WorkerAction = (function() {

                /**
                 * Properties of a WorkerAction.
                 * @memberof syft_proto.execution.v1
                 * @interface IWorkerAction
                 * @property {string|null} [command] WorkerAction command
                 * @property {syft_proto.types.syft.v1.IId|null} [target_id] WorkerAction target_id
                 * @property {syft_proto.generic.pointers.v1.IPointerTensor|null} [target_pointer] WorkerAction target_pointer
                 * @property {syft_proto.execution.v1.IPlaceholderId|null} [target_placeholder_id] WorkerAction target_placeholder_id
                 * @property {syft_proto.types.torch.v1.ITorchTensor|null} [target_tensor] WorkerAction target_tensor
                 * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] WorkerAction args
                 * @property {Object.<string,syft_proto.types.syft.v1.IArg>|null} [kwargs] WorkerAction kwargs
                 * @property {Array.<syft_proto.types.syft.v1.IId>|null} [return_ids] WorkerAction return_ids
                 * @property {Array.<syft_proto.execution.v1.IPlaceholderId>|null} [return_placeholder_ids] WorkerAction return_placeholder_ids
                 */

                /**
                 * Constructs a new WorkerAction.
                 * @memberof syft_proto.execution.v1
                 * @classdesc Represents a WorkerAction.
                 * @implements IWorkerAction
                 * @constructor
                 * @param {syft_proto.execution.v1.IWorkerAction=} [properties] Properties to set
                 */
                function WorkerAction(properties) {
                    this.args = [];
                    this.kwargs = {};
                    this.return_ids = [];
                    this.return_placeholder_ids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WorkerAction command.
                 * @member {string} command
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.command = "";

                /**
                 * WorkerAction target_id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} target_id
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.target_id = null;

                /**
                 * WorkerAction target_pointer.
                 * @member {syft_proto.generic.pointers.v1.IPointerTensor|null|undefined} target_pointer
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.target_pointer = null;

                /**
                 * WorkerAction target_placeholder_id.
                 * @member {syft_proto.execution.v1.IPlaceholderId|null|undefined} target_placeholder_id
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.target_placeholder_id = null;

                /**
                 * WorkerAction target_tensor.
                 * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} target_tensor
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.target_tensor = null;

                /**
                 * WorkerAction args.
                 * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.args = $util.emptyArray;

                /**
                 * WorkerAction kwargs.
                 * @member {Object.<string,syft_proto.types.syft.v1.IArg>} kwargs
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.kwargs = $util.emptyObject;

                /**
                 * WorkerAction return_ids.
                 * @member {Array.<syft_proto.types.syft.v1.IId>} return_ids
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.return_ids = $util.emptyArray;

                /**
                 * WorkerAction return_placeholder_ids.
                 * @member {Array.<syft_proto.execution.v1.IPlaceholderId>} return_placeholder_ids
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                WorkerAction.prototype.return_placeholder_ids = $util.emptyArray;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * WorkerAction target.
                 * @member {"target_id"|"target_pointer"|"target_placeholder_id"|"target_tensor"|undefined} target
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 */
                Object.defineProperty(WorkerAction.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["target_id", "target_pointer", "target_placeholder_id", "target_tensor"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new WorkerAction instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @static
                 * @param {syft_proto.execution.v1.IWorkerAction=} [properties] Properties to set
                 * @returns {syft_proto.execution.v1.WorkerAction} WorkerAction instance
                 */
                WorkerAction.create = function create(properties) {
                    return new WorkerAction(properties);
                };

                /**
                 * Encodes the specified WorkerAction message. Does not implicitly {@link syft_proto.execution.v1.WorkerAction.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @static
                 * @param {syft_proto.execution.v1.IWorkerAction} message WorkerAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkerAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command != null && message.hasOwnProperty("command"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer"))
                        $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.target_pointer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id"))
                        $root.syft_proto.execution.v1.PlaceholderId.encode(message.target_placeholder_id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor"))
                        $root.syft_proto.types.torch.v1.TorchTensor.encode(message.target_tensor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.args != null && message.args.length)
                        for (var i = 0; i < message.args.length; ++i)
                            $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.kwargs != null && message.hasOwnProperty("kwargs"))
                        for (var keys = Object.keys(message.kwargs), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.syft_proto.types.syft.v1.Arg.encode(message.kwargs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.return_ids != null && message.return_ids.length)
                        for (var i = 0; i < message.return_ids.length; ++i)
                            $root.syft_proto.types.syft.v1.Id.encode(message.return_ids[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.return_placeholder_ids != null && message.return_placeholder_ids.length)
                        for (var i = 0; i < message.return_placeholder_ids.length; ++i)
                            $root.syft_proto.execution.v1.PlaceholderId.encode(message.return_placeholder_ids[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.target_id != null && message.hasOwnProperty("target_id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.target_id, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified WorkerAction message, length delimited. Does not implicitly {@link syft_proto.execution.v1.WorkerAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @static
                 * @param {syft_proto.execution.v1.IWorkerAction} message WorkerAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkerAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WorkerAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.execution.v1.WorkerAction} WorkerAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkerAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.WorkerAction(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command = reader.string();
                            break;
                        case 9:
                            message.target_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            reader.skip().pos++;
                            if (message.kwargs === $util.emptyObject)
                                message.kwargs = {};
                            key = reader.string();
                            reader.pos++;
                            message.kwargs[key] = $root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32());
                            break;
                        case 7:
                            if (!(message.return_ids && message.return_ids.length))
                                message.return_ids = [];
                            message.return_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.return_placeholder_ids && message.return_placeholder_ids.length))
                                message.return_placeholder_ids = [];
                            message.return_placeholder_ids.push($root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WorkerAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.execution.v1.WorkerAction} WorkerAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkerAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WorkerAction message.
                 * @function verify
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkerAction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.command != null && message.hasOwnProperty("command"))
                        if (!$util.isString(message.command))
                            return "command: string expected";
                    if (message.target_id != null && message.hasOwnProperty("target_id")) {
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.target_id);
                            if (error)
                                return "target_id." + error;
                        }
                    }
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.target_pointer);
                            if (error)
                                return "target_pointer." + error;
                        }
                    }
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.target_placeholder_id);
                            if (error)
                                return "target_placeholder_id." + error;
                        }
                    }
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.target_tensor);
                            if (error)
                                return "target_tensor." + error;
                        }
                    }
                    if (message.args != null && message.hasOwnProperty("args")) {
                        if (!Array.isArray(message.args))
                            return "args: array expected";
                        for (var i = 0; i < message.args.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                            if (error)
                                return "args." + error;
                        }
                    }
                    if (message.kwargs != null && message.hasOwnProperty("kwargs")) {
                        if (!$util.isObject(message.kwargs))
                            return "kwargs: object expected";
                        var key = Object.keys(message.kwargs);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Arg.verify(message.kwargs[key[i]]);
                            if (error)
                                return "kwargs." + error;
                        }
                    }
                    if (message.return_ids != null && message.hasOwnProperty("return_ids")) {
                        if (!Array.isArray(message.return_ids))
                            return "return_ids: array expected";
                        for (var i = 0; i < message.return_ids.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.return_ids[i]);
                            if (error)
                                return "return_ids." + error;
                        }
                    }
                    if (message.return_placeholder_ids != null && message.hasOwnProperty("return_placeholder_ids")) {
                        if (!Array.isArray(message.return_placeholder_ids))
                            return "return_placeholder_ids: array expected";
                        for (var i = 0; i < message.return_placeholder_ids.length; ++i) {
                            var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.return_placeholder_ids[i]);
                            if (error)
                                return "return_placeholder_ids." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a WorkerAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.execution.v1.WorkerAction} WorkerAction
                 */
                WorkerAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.execution.v1.WorkerAction)
                        return object;
                    var message = new $root.syft_proto.execution.v1.WorkerAction();
                    if (object.command != null)
                        message.command = String(object.command);
                    if (object.target_id != null) {
                        if (typeof object.target_id !== "object")
                            throw TypeError(".syft_proto.execution.v1.WorkerAction.target_id: object expected");
                        message.target_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.target_id);
                    }
                    if (object.target_pointer != null) {
                        if (typeof object.target_pointer !== "object")
                            throw TypeError(".syft_proto.execution.v1.WorkerAction.target_pointer: object expected");
                        message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.target_pointer);
                    }
                    if (object.target_placeholder_id != null) {
                        if (typeof object.target_placeholder_id !== "object")
                            throw TypeError(".syft_proto.execution.v1.WorkerAction.target_placeholder_id: object expected");
                        message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.target_placeholder_id);
                    }
                    if (object.target_tensor != null) {
                        if (typeof object.target_tensor !== "object")
                            throw TypeError(".syft_proto.execution.v1.WorkerAction.target_tensor: object expected");
                        message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.target_tensor);
                    }
                    if (object.args) {
                        if (!Array.isArray(object.args))
                            throw TypeError(".syft_proto.execution.v1.WorkerAction.args: array expected");
                        message.args = [];
                        for (var i = 0; i < object.args.length; ++i) {
                            if (typeof object.args[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.WorkerAction.args: object expected");
                            message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                        }
                    }
                    if (object.kwargs) {
                        if (typeof object.kwargs !== "object")
                            throw TypeError(".syft_proto.execution.v1.WorkerAction.kwargs: object expected");
                        message.kwargs = {};
                        for (var keys = Object.keys(object.kwargs), i = 0; i < keys.length; ++i) {
                            if (typeof object.kwargs[keys[i]] !== "object")
                                throw TypeError(".syft_proto.execution.v1.WorkerAction.kwargs: object expected");
                            message.kwargs[keys[i]] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.kwargs[keys[i]]);
                        }
                    }
                    if (object.return_ids) {
                        if (!Array.isArray(object.return_ids))
                            throw TypeError(".syft_proto.execution.v1.WorkerAction.return_ids: array expected");
                        message.return_ids = [];
                        for (var i = 0; i < object.return_ids.length; ++i) {
                            if (typeof object.return_ids[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.WorkerAction.return_ids: object expected");
                            message.return_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.return_ids[i]);
                        }
                    }
                    if (object.return_placeholder_ids) {
                        if (!Array.isArray(object.return_placeholder_ids))
                            throw TypeError(".syft_proto.execution.v1.WorkerAction.return_placeholder_ids: array expected");
                        message.return_placeholder_ids = [];
                        for (var i = 0; i < object.return_placeholder_ids.length; ++i) {
                            if (typeof object.return_placeholder_ids[i] !== "object")
                                throw TypeError(".syft_proto.execution.v1.WorkerAction.return_placeholder_ids: object expected");
                            message.return_placeholder_ids[i] = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.return_placeholder_ids[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a WorkerAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @static
                 * @param {syft_proto.execution.v1.WorkerAction} message WorkerAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WorkerAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.args = [];
                        object.return_ids = [];
                        object.return_placeholder_ids = [];
                    }
                    if (options.objects || options.defaults)
                        object.kwargs = {};
                    if (options.defaults)
                        object.command = "";
                    if (message.command != null && message.hasOwnProperty("command"))
                        object.command = message.command;
                    if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                        object.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.target_pointer, options);
                        if (options.oneofs)
                            object.target = "target_pointer";
                    }
                    if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                        object.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.target_placeholder_id, options);
                        if (options.oneofs)
                            object.target = "target_placeholder_id";
                    }
                    if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                        object.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.target_tensor, options);
                        if (options.oneofs)
                            object.target = "target_tensor";
                    }
                    if (message.args && message.args.length) {
                        object.args = [];
                        for (var j = 0; j < message.args.length; ++j)
                            object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                    }
                    var keys2;
                    if (message.kwargs && (keys2 = Object.keys(message.kwargs)).length) {
                        object.kwargs = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.kwargs[keys2[j]] = $root.syft_proto.types.syft.v1.Arg.toObject(message.kwargs[keys2[j]], options);
                    }
                    if (message.return_ids && message.return_ids.length) {
                        object.return_ids = [];
                        for (var j = 0; j < message.return_ids.length; ++j)
                            object.return_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.return_ids[j], options);
                    }
                    if (message.return_placeholder_ids && message.return_placeholder_ids.length) {
                        object.return_placeholder_ids = [];
                        for (var j = 0; j < message.return_placeholder_ids.length; ++j)
                            object.return_placeholder_ids[j] = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.return_placeholder_ids[j], options);
                    }
                    if (message.target_id != null && message.hasOwnProperty("target_id")) {
                        object.target_id = $root.syft_proto.types.syft.v1.Id.toObject(message.target_id, options);
                        if (options.oneofs)
                            object.target = "target_id";
                    }
                    return object;
                };

                /**
                 * Converts this WorkerAction to JSON.
                 * @function toJSON
                 * @memberof syft_proto.execution.v1.WorkerAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WorkerAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return WorkerAction;
            })();

            return v1;
        })();

        return execution;
    })();

    syft_proto.types = (function() {

        /**
         * Namespace types.
         * @memberof syft_proto
         * @namespace
         */
        var types = {};

        types.syft = (function() {

            /**
             * Namespace syft.
             * @memberof syft_proto.types
             * @namespace
             */
            var syft = {};

            syft.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof syft_proto.types.syft
                 * @namespace
                 */
                var v1 = {};

                v1.Id = (function() {

                    /**
                     * Properties of an Id.
                     * @memberof syft_proto.types.syft.v1
                     * @interface IId
                     * @property {number|Long|null} [id_int] Id id_int
                     * @property {string|null} [id_str] Id id_str
                     */

                    /**
                     * Constructs a new Id.
                     * @memberof syft_proto.types.syft.v1
                     * @classdesc Represents an Id.
                     * @implements IId
                     * @constructor
                     * @param {syft_proto.types.syft.v1.IId=} [properties] Properties to set
                     */
                    function Id(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Id id_int.
                     * @member {number|Long} id_int
                     * @memberof syft_proto.types.syft.v1.Id
                     * @instance
                     */
                    Id.prototype.id_int = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Id id_str.
                     * @member {string} id_str
                     * @memberof syft_proto.types.syft.v1.Id
                     * @instance
                     */
                    Id.prototype.id_str = "";

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * Id id.
                     * @member {"id_int"|"id_str"|undefined} id
                     * @memberof syft_proto.types.syft.v1.Id
                     * @instance
                     */
                    Object.defineProperty(Id.prototype, "id", {
                        get: $util.oneOfGetter($oneOfFields = ["id_int", "id_str"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Id instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.syft.v1.Id
                     * @static
                     * @param {syft_proto.types.syft.v1.IId=} [properties] Properties to set
                     * @returns {syft_proto.types.syft.v1.Id} Id instance
                     */
                    Id.create = function create(properties) {
                        return new Id(properties);
                    };

                    /**
                     * Encodes the specified Id message. Does not implicitly {@link syft_proto.types.syft.v1.Id.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.syft.v1.Id
                     * @static
                     * @param {syft_proto.types.syft.v1.IId} message Id message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Id.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id_int != null && message.hasOwnProperty("id_int"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id_int);
                        if (message.id_str != null && message.hasOwnProperty("id_str"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.id_str);
                        return writer;
                    };

                    /**
                     * Encodes the specified Id message, length delimited. Does not implicitly {@link syft_proto.types.syft.v1.Id.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.syft.v1.Id
                     * @static
                     * @param {syft_proto.types.syft.v1.IId} message Id message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Id.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Id message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.syft.v1.Id
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.syft.v1.Id} Id
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Id.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.syft.v1.Id();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id_int = reader.int64();
                                break;
                            case 2:
                                message.id_str = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Id message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.syft.v1.Id
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.syft.v1.Id} Id
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Id.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Id message.
                     * @function verify
                     * @memberof syft_proto.types.syft.v1.Id
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Id.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.id_int != null && message.hasOwnProperty("id_int")) {
                            properties.id = 1;
                            if (!$util.isInteger(message.id_int) && !(message.id_int && $util.isInteger(message.id_int.low) && $util.isInteger(message.id_int.high)))
                                return "id_int: integer|Long expected";
                        }
                        if (message.id_str != null && message.hasOwnProperty("id_str")) {
                            if (properties.id === 1)
                                return "id: multiple values";
                            properties.id = 1;
                            if (!$util.isString(message.id_str))
                                return "id_str: string expected";
                        }
                        return null;
                    };

                    /**
                     * Creates an Id message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.syft.v1.Id
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.syft.v1.Id} Id
                     */
                    Id.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.syft.v1.Id)
                            return object;
                        var message = new $root.syft_proto.types.syft.v1.Id();
                        if (object.id_int != null)
                            if ($util.Long)
                                (message.id_int = $util.Long.fromValue(object.id_int)).unsigned = false;
                            else if (typeof object.id_int === "string")
                                message.id_int = parseInt(object.id_int, 10);
                            else if (typeof object.id_int === "number")
                                message.id_int = object.id_int;
                            else if (typeof object.id_int === "object")
                                message.id_int = new $util.LongBits(object.id_int.low >>> 0, object.id_int.high >>> 0).toNumber();
                        if (object.id_str != null)
                            message.id_str = String(object.id_str);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Id message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.syft.v1.Id
                     * @static
                     * @param {syft_proto.types.syft.v1.Id} message Id
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Id.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.id_int != null && message.hasOwnProperty("id_int")) {
                            if (typeof message.id_int === "number")
                                object.id_int = options.longs === String ? String(message.id_int) : message.id_int;
                            else
                                object.id_int = options.longs === String ? $util.Long.prototype.toString.call(message.id_int) : options.longs === Number ? new $util.LongBits(message.id_int.low >>> 0, message.id_int.high >>> 0).toNumber() : message.id_int;
                            if (options.oneofs)
                                object.id = "id_int";
                        }
                        if (message.id_str != null && message.hasOwnProperty("id_str")) {
                            object.id_str = message.id_str;
                            if (options.oneofs)
                                object.id = "id_str";
                        }
                        return object;
                    };

                    /**
                     * Converts this Id to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.syft.v1.Id
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Id.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return Id;
                })();

                v1.Shape = (function() {

                    /**
                     * Properties of a Shape.
                     * @memberof syft_proto.types.syft.v1
                     * @interface IShape
                     * @property {Array.<number>|null} [dims] Shape dims
                     */

                    /**
                     * Constructs a new Shape.
                     * @memberof syft_proto.types.syft.v1
                     * @classdesc Represents a Shape.
                     * @implements IShape
                     * @constructor
                     * @param {syft_proto.types.syft.v1.IShape=} [properties] Properties to set
                     */
                    function Shape(properties) {
                        this.dims = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Shape dims.
                     * @member {Array.<number>} dims
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @instance
                     */
                    Shape.prototype.dims = $util.emptyArray;

                    /**
                     * Creates a new Shape instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @static
                     * @param {syft_proto.types.syft.v1.IShape=} [properties] Properties to set
                     * @returns {syft_proto.types.syft.v1.Shape} Shape instance
                     */
                    Shape.create = function create(properties) {
                        return new Shape(properties);
                    };

                    /**
                     * Encodes the specified Shape message. Does not implicitly {@link syft_proto.types.syft.v1.Shape.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @static
                     * @param {syft_proto.types.syft.v1.IShape} message Shape message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Shape.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.dims != null && message.dims.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.dims.length; ++i)
                                writer.int32(message.dims[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };

                    /**
                     * Encodes the specified Shape message, length delimited. Does not implicitly {@link syft_proto.types.syft.v1.Shape.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @static
                     * @param {syft_proto.types.syft.v1.IShape} message Shape message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Shape.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Shape message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.syft.v1.Shape} Shape
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Shape.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.syft.v1.Shape();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.dims && message.dims.length))
                                    message.dims = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.dims.push(reader.int32());
                                } else
                                    message.dims.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Shape message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.syft.v1.Shape} Shape
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Shape.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Shape message.
                     * @function verify
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Shape.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.dims != null && message.hasOwnProperty("dims")) {
                            if (!Array.isArray(message.dims))
                                return "dims: array expected";
                            for (var i = 0; i < message.dims.length; ++i)
                                if (!$util.isInteger(message.dims[i]))
                                    return "dims: integer[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Shape message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.syft.v1.Shape} Shape
                     */
                    Shape.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.syft.v1.Shape)
                            return object;
                        var message = new $root.syft_proto.types.syft.v1.Shape();
                        if (object.dims) {
                            if (!Array.isArray(object.dims))
                                throw TypeError(".syft_proto.types.syft.v1.Shape.dims: array expected");
                            message.dims = [];
                            for (var i = 0; i < object.dims.length; ++i)
                                message.dims[i] = object.dims[i] | 0;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Shape message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @static
                     * @param {syft_proto.types.syft.v1.Shape} message Shape
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Shape.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.dims = [];
                        if (message.dims && message.dims.length) {
                            object.dims = [];
                            for (var j = 0; j < message.dims.length; ++j)
                                object.dims[j] = message.dims[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Shape to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.syft.v1.Shape
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Shape.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return Shape;
                })();

                v1.Arg = (function() {

                    /**
                     * Properties of an Arg.
                     * @memberof syft_proto.types.syft.v1
                     * @interface IArg
                     * @property {boolean|null} [arg_bool] Arg arg_bool
                     * @property {number|Long|null} [arg_int] Arg arg_int
                     * @property {number|null} [arg_float] Arg arg_float
                     * @property {string|null} [arg_str] Arg arg_str
                     * @property {syft_proto.types.syft.v1.IShape|null} [arg_shape] Arg arg_shape
                     * @property {syft_proto.types.torch.v1.ITorchTensor|null} [arg_tensor] Arg arg_tensor
                     * @property {syft_proto.types.torch.v1.IParameter|null} [arg_torch_param] Arg arg_torch_param
                     * @property {syft_proto.generic.pointers.v1.IPointerTensor|null} [arg_pointer_tensor] Arg arg_pointer_tensor
                     * @property {syft_proto.execution.v1.IPlaceholder|null} [arg_placeholder] Arg arg_placeholder
                     * @property {syft_proto.execution.v1.IPlaceholderId|null} [arg_placeholder_id] Arg arg_placeholder_id
                     * @property {syft_proto.types.syft.v1.IArgList|null} [arg_list] Arg arg_list
                     */

                    /**
                     * Constructs a new Arg.
                     * @memberof syft_proto.types.syft.v1
                     * @classdesc Represents an Arg.
                     * @implements IArg
                     * @constructor
                     * @param {syft_proto.types.syft.v1.IArg=} [properties] Properties to set
                     */
                    function Arg(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Arg arg_bool.
                     * @member {boolean} arg_bool
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_bool = false;

                    /**
                     * Arg arg_int.
                     * @member {number|Long} arg_int
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_int = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Arg arg_float.
                     * @member {number} arg_float
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_float = 0;

                    /**
                     * Arg arg_str.
                     * @member {string} arg_str
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_str = "";

                    /**
                     * Arg arg_shape.
                     * @member {syft_proto.types.syft.v1.IShape|null|undefined} arg_shape
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_shape = null;

                    /**
                     * Arg arg_tensor.
                     * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} arg_tensor
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_tensor = null;

                    /**
                     * Arg arg_torch_param.
                     * @member {syft_proto.types.torch.v1.IParameter|null|undefined} arg_torch_param
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_torch_param = null;

                    /**
                     * Arg arg_pointer_tensor.
                     * @member {syft_proto.generic.pointers.v1.IPointerTensor|null|undefined} arg_pointer_tensor
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_pointer_tensor = null;

                    /**
                     * Arg arg_placeholder.
                     * @member {syft_proto.execution.v1.IPlaceholder|null|undefined} arg_placeholder
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_placeholder = null;

                    /**
                     * Arg arg_placeholder_id.
                     * @member {syft_proto.execution.v1.IPlaceholderId|null|undefined} arg_placeholder_id
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_placeholder_id = null;

                    /**
                     * Arg arg_list.
                     * @member {syft_proto.types.syft.v1.IArgList|null|undefined} arg_list
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Arg.prototype.arg_list = null;

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * Arg arg.
                     * @member {"arg_bool"|"arg_int"|"arg_float"|"arg_str"|"arg_shape"|"arg_tensor"|"arg_torch_param"|"arg_pointer_tensor"|"arg_placeholder"|"arg_placeholder_id"|"arg_list"|undefined} arg
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     */
                    Object.defineProperty(Arg.prototype, "arg", {
                        get: $util.oneOfGetter($oneOfFields = ["arg_bool", "arg_int", "arg_float", "arg_str", "arg_shape", "arg_tensor", "arg_torch_param", "arg_pointer_tensor", "arg_placeholder", "arg_placeholder_id", "arg_list"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Arg instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @static
                     * @param {syft_proto.types.syft.v1.IArg=} [properties] Properties to set
                     * @returns {syft_proto.types.syft.v1.Arg} Arg instance
                     */
                    Arg.create = function create(properties) {
                        return new Arg(properties);
                    };

                    /**
                     * Encodes the specified Arg message. Does not implicitly {@link syft_proto.types.syft.v1.Arg.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @static
                     * @param {syft_proto.types.syft.v1.IArg} message Arg message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Arg.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.arg_bool != null && message.hasOwnProperty("arg_bool"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.arg_bool);
                        if (message.arg_int != null && message.hasOwnProperty("arg_int"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.arg_int);
                        if (message.arg_float != null && message.hasOwnProperty("arg_float"))
                            writer.uint32(/* id 3, wireType 5 =*/29).float(message.arg_float);
                        if (message.arg_str != null && message.hasOwnProperty("arg_str"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.arg_str);
                        if (message.arg_shape != null && message.hasOwnProperty("arg_shape"))
                            $root.syft_proto.types.syft.v1.Shape.encode(message.arg_shape, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.arg_tensor != null && message.hasOwnProperty("arg_tensor"))
                            $root.syft_proto.types.torch.v1.TorchTensor.encode(message.arg_tensor, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.arg_torch_param != null && message.hasOwnProperty("arg_torch_param"))
                            $root.syft_proto.types.torch.v1.Parameter.encode(message.arg_torch_param, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.arg_pointer_tensor != null && message.hasOwnProperty("arg_pointer_tensor"))
                            $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.arg_pointer_tensor, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.arg_placeholder != null && message.hasOwnProperty("arg_placeholder"))
                            $root.syft_proto.execution.v1.Placeholder.encode(message.arg_placeholder, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.arg_placeholder_id != null && message.hasOwnProperty("arg_placeholder_id"))
                            $root.syft_proto.execution.v1.PlaceholderId.encode(message.arg_placeholder_id, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.arg_list != null && message.hasOwnProperty("arg_list"))
                            $root.syft_proto.types.syft.v1.ArgList.encode(message.arg_list, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Arg message, length delimited. Does not implicitly {@link syft_proto.types.syft.v1.Arg.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @static
                     * @param {syft_proto.types.syft.v1.IArg} message Arg message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Arg.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Arg message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.syft.v1.Arg} Arg
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Arg.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.syft.v1.Arg();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.arg_bool = reader.bool();
                                break;
                            case 2:
                                message.arg_int = reader.int64();
                                break;
                            case 3:
                                message.arg_float = reader.float();
                                break;
                            case 4:
                                message.arg_str = reader.string();
                                break;
                            case 5:
                                message.arg_shape = $root.syft_proto.types.syft.v1.Shape.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.arg_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.arg_torch_param = $root.syft_proto.types.torch.v1.Parameter.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.arg_pointer_tensor = $root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.arg_placeholder = $root.syft_proto.execution.v1.Placeholder.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.arg_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.arg_list = $root.syft_proto.types.syft.v1.ArgList.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Arg message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.syft.v1.Arg} Arg
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Arg.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Arg message.
                     * @function verify
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Arg.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.arg_bool != null && message.hasOwnProperty("arg_bool")) {
                            properties.arg = 1;
                            if (typeof message.arg_bool !== "boolean")
                                return "arg_bool: boolean expected";
                        }
                        if (message.arg_int != null && message.hasOwnProperty("arg_int")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            if (!$util.isInteger(message.arg_int) && !(message.arg_int && $util.isInteger(message.arg_int.low) && $util.isInteger(message.arg_int.high)))
                                return "arg_int: integer|Long expected";
                        }
                        if (message.arg_float != null && message.hasOwnProperty("arg_float")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            if (typeof message.arg_float !== "number")
                                return "arg_float: number expected";
                        }
                        if (message.arg_str != null && message.hasOwnProperty("arg_str")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            if (!$util.isString(message.arg_str))
                                return "arg_str: string expected";
                        }
                        if (message.arg_shape != null && message.hasOwnProperty("arg_shape")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            {
                                var error = $root.syft_proto.types.syft.v1.Shape.verify(message.arg_shape);
                                if (error)
                                    return "arg_shape." + error;
                            }
                        }
                        if (message.arg_tensor != null && message.hasOwnProperty("arg_tensor")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            {
                                var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.arg_tensor);
                                if (error)
                                    return "arg_tensor." + error;
                            }
                        }
                        if (message.arg_torch_param != null && message.hasOwnProperty("arg_torch_param")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            {
                                var error = $root.syft_proto.types.torch.v1.Parameter.verify(message.arg_torch_param);
                                if (error)
                                    return "arg_torch_param." + error;
                            }
                        }
                        if (message.arg_pointer_tensor != null && message.hasOwnProperty("arg_pointer_tensor")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            {
                                var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.arg_pointer_tensor);
                                if (error)
                                    return "arg_pointer_tensor." + error;
                            }
                        }
                        if (message.arg_placeholder != null && message.hasOwnProperty("arg_placeholder")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            {
                                var error = $root.syft_proto.execution.v1.Placeholder.verify(message.arg_placeholder);
                                if (error)
                                    return "arg_placeholder." + error;
                            }
                        }
                        if (message.arg_placeholder_id != null && message.hasOwnProperty("arg_placeholder_id")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            {
                                var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.arg_placeholder_id);
                                if (error)
                                    return "arg_placeholder_id." + error;
                            }
                        }
                        if (message.arg_list != null && message.hasOwnProperty("arg_list")) {
                            if (properties.arg === 1)
                                return "arg: multiple values";
                            properties.arg = 1;
                            {
                                var error = $root.syft_proto.types.syft.v1.ArgList.verify(message.arg_list);
                                if (error)
                                    return "arg_list." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an Arg message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.syft.v1.Arg} Arg
                     */
                    Arg.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.syft.v1.Arg)
                            return object;
                        var message = new $root.syft_proto.types.syft.v1.Arg();
                        if (object.arg_bool != null)
                            message.arg_bool = Boolean(object.arg_bool);
                        if (object.arg_int != null)
                            if ($util.Long)
                                (message.arg_int = $util.Long.fromValue(object.arg_int)).unsigned = false;
                            else if (typeof object.arg_int === "string")
                                message.arg_int = parseInt(object.arg_int, 10);
                            else if (typeof object.arg_int === "number")
                                message.arg_int = object.arg_int;
                            else if (typeof object.arg_int === "object")
                                message.arg_int = new $util.LongBits(object.arg_int.low >>> 0, object.arg_int.high >>> 0).toNumber();
                        if (object.arg_float != null)
                            message.arg_float = Number(object.arg_float);
                        if (object.arg_str != null)
                            message.arg_str = String(object.arg_str);
                        if (object.arg_shape != null) {
                            if (typeof object.arg_shape !== "object")
                                throw TypeError(".syft_proto.types.syft.v1.Arg.arg_shape: object expected");
                            message.arg_shape = $root.syft_proto.types.syft.v1.Shape.fromObject(object.arg_shape);
                        }
                        if (object.arg_tensor != null) {
                            if (typeof object.arg_tensor !== "object")
                                throw TypeError(".syft_proto.types.syft.v1.Arg.arg_tensor: object expected");
                            message.arg_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.arg_tensor);
                        }
                        if (object.arg_torch_param != null) {
                            if (typeof object.arg_torch_param !== "object")
                                throw TypeError(".syft_proto.types.syft.v1.Arg.arg_torch_param: object expected");
                            message.arg_torch_param = $root.syft_proto.types.torch.v1.Parameter.fromObject(object.arg_torch_param);
                        }
                        if (object.arg_pointer_tensor != null) {
                            if (typeof object.arg_pointer_tensor !== "object")
                                throw TypeError(".syft_proto.types.syft.v1.Arg.arg_pointer_tensor: object expected");
                            message.arg_pointer_tensor = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.arg_pointer_tensor);
                        }
                        if (object.arg_placeholder != null) {
                            if (typeof object.arg_placeholder !== "object")
                                throw TypeError(".syft_proto.types.syft.v1.Arg.arg_placeholder: object expected");
                            message.arg_placeholder = $root.syft_proto.execution.v1.Placeholder.fromObject(object.arg_placeholder);
                        }
                        if (object.arg_placeholder_id != null) {
                            if (typeof object.arg_placeholder_id !== "object")
                                throw TypeError(".syft_proto.types.syft.v1.Arg.arg_placeholder_id: object expected");
                            message.arg_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.arg_placeholder_id);
                        }
                        if (object.arg_list != null) {
                            if (typeof object.arg_list !== "object")
                                throw TypeError(".syft_proto.types.syft.v1.Arg.arg_list: object expected");
                            message.arg_list = $root.syft_proto.types.syft.v1.ArgList.fromObject(object.arg_list);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Arg message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @static
                     * @param {syft_proto.types.syft.v1.Arg} message Arg
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Arg.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.arg_bool != null && message.hasOwnProperty("arg_bool")) {
                            object.arg_bool = message.arg_bool;
                            if (options.oneofs)
                                object.arg = "arg_bool";
                        }
                        if (message.arg_int != null && message.hasOwnProperty("arg_int")) {
                            if (typeof message.arg_int === "number")
                                object.arg_int = options.longs === String ? String(message.arg_int) : message.arg_int;
                            else
                                object.arg_int = options.longs === String ? $util.Long.prototype.toString.call(message.arg_int) : options.longs === Number ? new $util.LongBits(message.arg_int.low >>> 0, message.arg_int.high >>> 0).toNumber() : message.arg_int;
                            if (options.oneofs)
                                object.arg = "arg_int";
                        }
                        if (message.arg_float != null && message.hasOwnProperty("arg_float")) {
                            object.arg_float = options.json && !isFinite(message.arg_float) ? String(message.arg_float) : message.arg_float;
                            if (options.oneofs)
                                object.arg = "arg_float";
                        }
                        if (message.arg_str != null && message.hasOwnProperty("arg_str")) {
                            object.arg_str = message.arg_str;
                            if (options.oneofs)
                                object.arg = "arg_str";
                        }
                        if (message.arg_shape != null && message.hasOwnProperty("arg_shape")) {
                            object.arg_shape = $root.syft_proto.types.syft.v1.Shape.toObject(message.arg_shape, options);
                            if (options.oneofs)
                                object.arg = "arg_shape";
                        }
                        if (message.arg_tensor != null && message.hasOwnProperty("arg_tensor")) {
                            object.arg_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.arg_tensor, options);
                            if (options.oneofs)
                                object.arg = "arg_tensor";
                        }
                        if (message.arg_torch_param != null && message.hasOwnProperty("arg_torch_param")) {
                            object.arg_torch_param = $root.syft_proto.types.torch.v1.Parameter.toObject(message.arg_torch_param, options);
                            if (options.oneofs)
                                object.arg = "arg_torch_param";
                        }
                        if (message.arg_pointer_tensor != null && message.hasOwnProperty("arg_pointer_tensor")) {
                            object.arg_pointer_tensor = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.arg_pointer_tensor, options);
                            if (options.oneofs)
                                object.arg = "arg_pointer_tensor";
                        }
                        if (message.arg_placeholder != null && message.hasOwnProperty("arg_placeholder")) {
                            object.arg_placeholder = $root.syft_proto.execution.v1.Placeholder.toObject(message.arg_placeholder, options);
                            if (options.oneofs)
                                object.arg = "arg_placeholder";
                        }
                        if (message.arg_placeholder_id != null && message.hasOwnProperty("arg_placeholder_id")) {
                            object.arg_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.arg_placeholder_id, options);
                            if (options.oneofs)
                                object.arg = "arg_placeholder_id";
                        }
                        if (message.arg_list != null && message.hasOwnProperty("arg_list")) {
                            object.arg_list = $root.syft_proto.types.syft.v1.ArgList.toObject(message.arg_list, options);
                            if (options.oneofs)
                                object.arg = "arg_list";
                        }
                        return object;
                    };

                    /**
                     * Converts this Arg to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.syft.v1.Arg
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Arg.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return Arg;
                })();

                v1.ArgList = (function() {

                    /**
                     * Properties of an ArgList.
                     * @memberof syft_proto.types.syft.v1
                     * @interface IArgList
                     * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] ArgList args
                     */

                    /**
                     * Constructs a new ArgList.
                     * @memberof syft_proto.types.syft.v1
                     * @classdesc Represents an ArgList.
                     * @implements IArgList
                     * @constructor
                     * @param {syft_proto.types.syft.v1.IArgList=} [properties] Properties to set
                     */
                    function ArgList(properties) {
                        this.args = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ArgList args.
                     * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @instance
                     */
                    ArgList.prototype.args = $util.emptyArray;

                    /**
                     * Creates a new ArgList instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @static
                     * @param {syft_proto.types.syft.v1.IArgList=} [properties] Properties to set
                     * @returns {syft_proto.types.syft.v1.ArgList} ArgList instance
                     */
                    ArgList.create = function create(properties) {
                        return new ArgList(properties);
                    };

                    /**
                     * Encodes the specified ArgList message. Does not implicitly {@link syft_proto.types.syft.v1.ArgList.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @static
                     * @param {syft_proto.types.syft.v1.IArgList} message ArgList message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ArgList.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.args != null && message.args.length)
                            for (var i = 0; i < message.args.length; ++i)
                                $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ArgList message, length delimited. Does not implicitly {@link syft_proto.types.syft.v1.ArgList.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @static
                     * @param {syft_proto.types.syft.v1.IArgList} message ArgList message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ArgList.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an ArgList message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.syft.v1.ArgList} ArgList
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ArgList.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.syft.v1.ArgList();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.args && message.args.length))
                                    message.args = [];
                                message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an ArgList message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.syft.v1.ArgList} ArgList
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ArgList.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an ArgList message.
                     * @function verify
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ArgList.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.args != null && message.hasOwnProperty("args")) {
                            if (!Array.isArray(message.args))
                                return "args: array expected";
                            for (var i = 0; i < message.args.length; ++i) {
                                var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                                if (error)
                                    return "args." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an ArgList message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.syft.v1.ArgList} ArgList
                     */
                    ArgList.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.syft.v1.ArgList)
                            return object;
                        var message = new $root.syft_proto.types.syft.v1.ArgList();
                        if (object.args) {
                            if (!Array.isArray(object.args))
                                throw TypeError(".syft_proto.types.syft.v1.ArgList.args: array expected");
                            message.args = [];
                            for (var i = 0; i < object.args.length; ++i) {
                                if (typeof object.args[i] !== "object")
                                    throw TypeError(".syft_proto.types.syft.v1.ArgList.args: object expected");
                                message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an ArgList message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @static
                     * @param {syft_proto.types.syft.v1.ArgList} message ArgList
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ArgList.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.args = [];
                        if (message.args && message.args.length) {
                            object.args = [];
                            for (var j = 0; j < message.args.length; ++j)
                                object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ArgList to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.syft.v1.ArgList
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ArgList.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return ArgList;
                })();

                return v1;
            })();

            return syft;
        })();

        types.torch = (function() {

            /**
             * Namespace torch.
             * @memberof syft_proto.types
             * @namespace
             */
            var torch = {};

            torch.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof syft_proto.types.torch
                 * @namespace
                 */
                var v1 = {};

                v1.TorchTensor = (function() {

                    /**
                     * Properties of a TorchTensor.
                     * @memberof syft_proto.types.torch.v1
                     * @interface ITorchTensor
                     * @property {syft_proto.types.syft.v1.IId|null} [id] TorchTensor id
                     * @property {syft_proto.types.torch.v1.ITensorData|null} [contents_data] TorchTensor contents_data
                     * @property {Uint8Array|null} [contents_bin] TorchTensor contents_bin
                     * @property {syft_proto.types.torch.v1.ITorchTensor|null} [chain] TorchTensor chain
                     * @property {syft_proto.types.torch.v1.ITorchTensor|null} [grad_chain] TorchTensor grad_chain
                     * @property {Array.<string>|null} [tags] TorchTensor tags
                     * @property {string|null} [description] TorchTensor description
                     * @property {syft_proto.types.torch.v1.TorchTensor.Serializer|null} [serializer] TorchTensor serializer
                     */

                    /**
                     * Constructs a new TorchTensor.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a TorchTensor.
                     * @implements ITorchTensor
                     * @constructor
                     * @param {syft_proto.types.torch.v1.ITorchTensor=} [properties] Properties to set
                     */
                    function TorchTensor(properties) {
                        this.tags = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TorchTensor id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    TorchTensor.prototype.id = null;

                    /**
                     * TorchTensor contents_data.
                     * @member {syft_proto.types.torch.v1.ITensorData|null|undefined} contents_data
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    TorchTensor.prototype.contents_data = null;

                    /**
                     * TorchTensor contents_bin.
                     * @member {Uint8Array} contents_bin
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    TorchTensor.prototype.contents_bin = $util.newBuffer([]);

                    /**
                     * TorchTensor chain.
                     * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} chain
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    TorchTensor.prototype.chain = null;

                    /**
                     * TorchTensor grad_chain.
                     * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} grad_chain
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    TorchTensor.prototype.grad_chain = null;

                    /**
                     * TorchTensor tags.
                     * @member {Array.<string>} tags
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    TorchTensor.prototype.tags = $util.emptyArray;

                    /**
                     * TorchTensor description.
                     * @member {string} description
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    TorchTensor.prototype.description = "";

                    /**
                     * TorchTensor serializer.
                     * @member {syft_proto.types.torch.v1.TorchTensor.Serializer} serializer
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    TorchTensor.prototype.serializer = 0;

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * TorchTensor contents.
                     * @member {"contents_data"|"contents_bin"|undefined} contents
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     */
                    Object.defineProperty(TorchTensor.prototype, "contents", {
                        get: $util.oneOfGetter($oneOfFields = ["contents_data", "contents_bin"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new TorchTensor instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @static
                     * @param {syft_proto.types.torch.v1.ITorchTensor=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.TorchTensor} TorchTensor instance
                     */
                    TorchTensor.create = function create(properties) {
                        return new TorchTensor(properties);
                    };

                    /**
                     * Encodes the specified TorchTensor message. Does not implicitly {@link syft_proto.types.torch.v1.TorchTensor.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @static
                     * @param {syft_proto.types.torch.v1.ITorchTensor} message TorchTensor message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TorchTensor.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.contents_data != null && message.hasOwnProperty("contents_data"))
                            $root.syft_proto.types.torch.v1.TensorData.encode(message.contents_data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.contents_bin != null && message.hasOwnProperty("contents_bin"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.contents_bin);
                        if (message.chain != null && message.hasOwnProperty("chain"))
                            $root.syft_proto.types.torch.v1.TorchTensor.encode(message.chain, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.grad_chain != null && message.hasOwnProperty("grad_chain"))
                            $root.syft_proto.types.torch.v1.TorchTensor.encode(message.grad_chain, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.tags != null && message.tags.length)
                            for (var i = 0; i < message.tags.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
                        if (message.description != null && message.hasOwnProperty("description"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
                        if (message.serializer != null && message.hasOwnProperty("serializer"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.serializer);
                        return writer;
                    };

                    /**
                     * Encodes the specified TorchTensor message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.TorchTensor.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @static
                     * @param {syft_proto.types.torch.v1.ITorchTensor} message TorchTensor message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TorchTensor.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TorchTensor message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.TorchTensor} TorchTensor
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TorchTensor.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.TorchTensor();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.contents_data = $root.syft_proto.types.torch.v1.TensorData.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.contents_bin = reader.bytes();
                                break;
                            case 4:
                                message.chain = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.grad_chain = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                break;
                            case 6:
                                if (!(message.tags && message.tags.length))
                                    message.tags = [];
                                message.tags.push(reader.string());
                                break;
                            case 7:
                                message.description = reader.string();
                                break;
                            case 8:
                                message.serializer = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TorchTensor message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.TorchTensor} TorchTensor
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TorchTensor.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TorchTensor message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TorchTensor.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.id != null && message.hasOwnProperty("id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                            if (error)
                                return "id." + error;
                        }
                        if (message.contents_data != null && message.hasOwnProperty("contents_data")) {
                            properties.contents = 1;
                            {
                                var error = $root.syft_proto.types.torch.v1.TensorData.verify(message.contents_data);
                                if (error)
                                    return "contents_data." + error;
                            }
                        }
                        if (message.contents_bin != null && message.hasOwnProperty("contents_bin")) {
                            if (properties.contents === 1)
                                return "contents: multiple values";
                            properties.contents = 1;
                            if (!(message.contents_bin && typeof message.contents_bin.length === "number" || $util.isString(message.contents_bin)))
                                return "contents_bin: buffer expected";
                        }
                        if (message.chain != null && message.hasOwnProperty("chain")) {
                            var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.chain);
                            if (error)
                                return "chain." + error;
                        }
                        if (message.grad_chain != null && message.hasOwnProperty("grad_chain")) {
                            var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.grad_chain);
                            if (error)
                                return "grad_chain." + error;
                        }
                        if (message.tags != null && message.hasOwnProperty("tags")) {
                            if (!Array.isArray(message.tags))
                                return "tags: array expected";
                            for (var i = 0; i < message.tags.length; ++i)
                                if (!$util.isString(message.tags[i]))
                                    return "tags: string[] expected";
                        }
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        if (message.serializer != null && message.hasOwnProperty("serializer"))
                            switch (message.serializer) {
                            default:
                                return "serializer: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a TorchTensor message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.TorchTensor} TorchTensor
                     */
                    TorchTensor.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.TorchTensor)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.TorchTensor();
                        if (object.id != null) {
                            if (typeof object.id !== "object")
                                throw TypeError(".syft_proto.types.torch.v1.TorchTensor.id: object expected");
                            message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                        }
                        if (object.contents_data != null) {
                            if (typeof object.contents_data !== "object")
                                throw TypeError(".syft_proto.types.torch.v1.TorchTensor.contents_data: object expected");
                            message.contents_data = $root.syft_proto.types.torch.v1.TensorData.fromObject(object.contents_data);
                        }
                        if (object.contents_bin != null)
                            if (typeof object.contents_bin === "string")
                                $util.base64.decode(object.contents_bin, message.contents_bin = $util.newBuffer($util.base64.length(object.contents_bin)), 0);
                            else if (object.contents_bin.length)
                                message.contents_bin = object.contents_bin;
                        if (object.chain != null) {
                            if (typeof object.chain !== "object")
                                throw TypeError(".syft_proto.types.torch.v1.TorchTensor.chain: object expected");
                            message.chain = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.chain);
                        }
                        if (object.grad_chain != null) {
                            if (typeof object.grad_chain !== "object")
                                throw TypeError(".syft_proto.types.torch.v1.TorchTensor.grad_chain: object expected");
                            message.grad_chain = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.grad_chain);
                        }
                        if (object.tags) {
                            if (!Array.isArray(object.tags))
                                throw TypeError(".syft_proto.types.torch.v1.TorchTensor.tags: array expected");
                            message.tags = [];
                            for (var i = 0; i < object.tags.length; ++i)
                                message.tags[i] = String(object.tags[i]);
                        }
                        if (object.description != null)
                            message.description = String(object.description);
                        switch (object.serializer) {
                        case "SERIALIZER_UNSPECIFIED":
                        case 0:
                            message.serializer = 0;
                            break;
                        case "SERIALIZER_TORCH":
                        case 1:
                            message.serializer = 1;
                            break;
                        case "SERIALIZER_NUMPY":
                        case 2:
                            message.serializer = 2;
                            break;
                        case "SERIALIZER_TF":
                        case 3:
                            message.serializer = 3;
                            break;
                        case "SERIALIZER_ALL":
                        case 4:
                            message.serializer = 4;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TorchTensor message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @static
                     * @param {syft_proto.types.torch.v1.TorchTensor} message TorchTensor
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TorchTensor.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.tags = [];
                        if (options.defaults) {
                            object.id = null;
                            object.chain = null;
                            object.grad_chain = null;
                            object.description = "";
                            object.serializer = options.enums === String ? "SERIALIZER_UNSPECIFIED" : 0;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                        if (message.contents_data != null && message.hasOwnProperty("contents_data")) {
                            object.contents_data = $root.syft_proto.types.torch.v1.TensorData.toObject(message.contents_data, options);
                            if (options.oneofs)
                                object.contents = "contents_data";
                        }
                        if (message.contents_bin != null && message.hasOwnProperty("contents_bin")) {
                            object.contents_bin = options.bytes === String ? $util.base64.encode(message.contents_bin, 0, message.contents_bin.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents_bin) : message.contents_bin;
                            if (options.oneofs)
                                object.contents = "contents_bin";
                        }
                        if (message.chain != null && message.hasOwnProperty("chain"))
                            object.chain = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.chain, options);
                        if (message.grad_chain != null && message.hasOwnProperty("grad_chain"))
                            object.grad_chain = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.grad_chain, options);
                        if (message.tags && message.tags.length) {
                            object.tags = [];
                            for (var j = 0; j < message.tags.length; ++j)
                                object.tags[j] = message.tags[j];
                        }
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        if (message.serializer != null && message.hasOwnProperty("serializer"))
                            object.serializer = options.enums === String ? $root.syft_proto.types.torch.v1.TorchTensor.Serializer[message.serializer] : message.serializer;
                        return object;
                    };

                    /**
                     * Converts this TorchTensor to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.TorchTensor
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TorchTensor.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    /**
                     * Serializer enum.
                     * @name syft_proto.types.torch.v1.TorchTensor.Serializer
                     * @enum {string}
                     * @property {number} SERIALIZER_UNSPECIFIED=0 SERIALIZER_UNSPECIFIED value
                     * @property {number} SERIALIZER_TORCH=1 SERIALIZER_TORCH value
                     * @property {number} SERIALIZER_NUMPY=2 SERIALIZER_NUMPY value
                     * @property {number} SERIALIZER_TF=3 SERIALIZER_TF value
                     * @property {number} SERIALIZER_ALL=4 SERIALIZER_ALL value
                     */
                    TorchTensor.Serializer = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "SERIALIZER_UNSPECIFIED"] = 0;
                        values[valuesById[1] = "SERIALIZER_TORCH"] = 1;
                        values[valuesById[2] = "SERIALIZER_NUMPY"] = 2;
                        values[valuesById[3] = "SERIALIZER_TF"] = 3;
                        values[valuesById[4] = "SERIALIZER_ALL"] = 4;
                        return values;
                    })();

                    return TorchTensor;
                })();

                v1.TensorData = (function() {

                    /**
                     * Properties of a TensorData.
                     * @memberof syft_proto.types.torch.v1
                     * @interface ITensorData
                     * @property {syft_proto.types.torch.v1.ISize|null} [shape] TensorData shape
                     * @property {string|null} [dtype] TensorData dtype
                     * @property {boolean|null} [is_quantized] TensorData is_quantized
                     * @property {number|null} [scale] TensorData scale
                     * @property {number|null} [zero_point] TensorData zero_point
                     * @property {Array.<number>|null} [contents_uint8] TensorData contents_uint8
                     * @property {Array.<number>|null} [contents_int8] TensorData contents_int8
                     * @property {Array.<number>|null} [contents_int16] TensorData contents_int16
                     * @property {Array.<number>|null} [contents_int32] TensorData contents_int32
                     * @property {Array.<number|Long>|null} [contents_int64] TensorData contents_int64
                     * @property {Array.<number>|null} [contents_float16] TensorData contents_float16
                     * @property {Array.<number>|null} [contents_float32] TensorData contents_float32
                     * @property {Array.<number>|null} [contents_float64] TensorData contents_float64
                     * @property {Array.<boolean>|null} [contents_bool] TensorData contents_bool
                     * @property {Array.<number>|null} [contents_qint8] TensorData contents_qint8
                     * @property {Array.<number>|null} [contents_quint8] TensorData contents_quint8
                     * @property {Array.<number>|null} [contents_qint32] TensorData contents_qint32
                     * @property {Array.<number>|null} [contents_bfloat16] TensorData contents_bfloat16
                     */

                    /**
                     * Constructs a new TensorData.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a TensorData.
                     * @implements ITensorData
                     * @constructor
                     * @param {syft_proto.types.torch.v1.ITensorData=} [properties] Properties to set
                     */
                    function TensorData(properties) {
                        this.contents_uint8 = [];
                        this.contents_int8 = [];
                        this.contents_int16 = [];
                        this.contents_int32 = [];
                        this.contents_int64 = [];
                        this.contents_float16 = [];
                        this.contents_float32 = [];
                        this.contents_float64 = [];
                        this.contents_bool = [];
                        this.contents_qint8 = [];
                        this.contents_quint8 = [];
                        this.contents_qint32 = [];
                        this.contents_bfloat16 = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TensorData shape.
                     * @member {syft_proto.types.torch.v1.ISize|null|undefined} shape
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.shape = null;

                    /**
                     * TensorData dtype.
                     * @member {string} dtype
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.dtype = "";

                    /**
                     * TensorData is_quantized.
                     * @member {boolean} is_quantized
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.is_quantized = false;

                    /**
                     * TensorData scale.
                     * @member {number} scale
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.scale = 0;

                    /**
                     * TensorData zero_point.
                     * @member {number} zero_point
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.zero_point = 0;

                    /**
                     * TensorData contents_uint8.
                     * @member {Array.<number>} contents_uint8
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_uint8 = $util.emptyArray;

                    /**
                     * TensorData contents_int8.
                     * @member {Array.<number>} contents_int8
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_int8 = $util.emptyArray;

                    /**
                     * TensorData contents_int16.
                     * @member {Array.<number>} contents_int16
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_int16 = $util.emptyArray;

                    /**
                     * TensorData contents_int32.
                     * @member {Array.<number>} contents_int32
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_int32 = $util.emptyArray;

                    /**
                     * TensorData contents_int64.
                     * @member {Array.<number|Long>} contents_int64
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_int64 = $util.emptyArray;

                    /**
                     * TensorData contents_float16.
                     * @member {Array.<number>} contents_float16
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_float16 = $util.emptyArray;

                    /**
                     * TensorData contents_float32.
                     * @member {Array.<number>} contents_float32
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_float32 = $util.emptyArray;

                    /**
                     * TensorData contents_float64.
                     * @member {Array.<number>} contents_float64
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_float64 = $util.emptyArray;

                    /**
                     * TensorData contents_bool.
                     * @member {Array.<boolean>} contents_bool
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_bool = $util.emptyArray;

                    /**
                     * TensorData contents_qint8.
                     * @member {Array.<number>} contents_qint8
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_qint8 = $util.emptyArray;

                    /**
                     * TensorData contents_quint8.
                     * @member {Array.<number>} contents_quint8
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_quint8 = $util.emptyArray;

                    /**
                     * TensorData contents_qint32.
                     * @member {Array.<number>} contents_qint32
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_qint32 = $util.emptyArray;

                    /**
                     * TensorData contents_bfloat16.
                     * @member {Array.<number>} contents_bfloat16
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     */
                    TensorData.prototype.contents_bfloat16 = $util.emptyArray;

                    /**
                     * Creates a new TensorData instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @static
                     * @param {syft_proto.types.torch.v1.ITensorData=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.TensorData} TensorData instance
                     */
                    TensorData.create = function create(properties) {
                        return new TensorData(properties);
                    };

                    /**
                     * Encodes the specified TensorData message. Does not implicitly {@link syft_proto.types.torch.v1.TensorData.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @static
                     * @param {syft_proto.types.torch.v1.ITensorData} message TensorData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TensorData.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.shape != null && message.hasOwnProperty("shape"))
                            $root.syft_proto.types.torch.v1.Size.encode(message.shape, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.dtype != null && message.hasOwnProperty("dtype"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.dtype);
                        if (message.is_quantized != null && message.hasOwnProperty("is_quantized"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_quantized);
                        if (message.scale != null && message.hasOwnProperty("scale"))
                            writer.uint32(/* id 4, wireType 5 =*/37).float(message.scale);
                        if (message.zero_point != null && message.hasOwnProperty("zero_point"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.zero_point);
                        if (message.contents_uint8 != null && message.contents_uint8.length) {
                            writer.uint32(/* id 16, wireType 2 =*/130).fork();
                            for (var i = 0; i < message.contents_uint8.length; ++i)
                                writer.uint32(message.contents_uint8[i]);
                            writer.ldelim();
                        }
                        if (message.contents_int8 != null && message.contents_int8.length) {
                            writer.uint32(/* id 17, wireType 2 =*/138).fork();
                            for (var i = 0; i < message.contents_int8.length; ++i)
                                writer.int32(message.contents_int8[i]);
                            writer.ldelim();
                        }
                        if (message.contents_int16 != null && message.contents_int16.length) {
                            writer.uint32(/* id 18, wireType 2 =*/146).fork();
                            for (var i = 0; i < message.contents_int16.length; ++i)
                                writer.int32(message.contents_int16[i]);
                            writer.ldelim();
                        }
                        if (message.contents_int32 != null && message.contents_int32.length) {
                            writer.uint32(/* id 19, wireType 2 =*/154).fork();
                            for (var i = 0; i < message.contents_int32.length; ++i)
                                writer.int32(message.contents_int32[i]);
                            writer.ldelim();
                        }
                        if (message.contents_int64 != null && message.contents_int64.length) {
                            writer.uint32(/* id 20, wireType 2 =*/162).fork();
                            for (var i = 0; i < message.contents_int64.length; ++i)
                                writer.int64(message.contents_int64[i]);
                            writer.ldelim();
                        }
                        if (message.contents_float16 != null && message.contents_float16.length) {
                            writer.uint32(/* id 21, wireType 2 =*/170).fork();
                            for (var i = 0; i < message.contents_float16.length; ++i)
                                writer.float(message.contents_float16[i]);
                            writer.ldelim();
                        }
                        if (message.contents_float32 != null && message.contents_float32.length) {
                            writer.uint32(/* id 22, wireType 2 =*/178).fork();
                            for (var i = 0; i < message.contents_float32.length; ++i)
                                writer.float(message.contents_float32[i]);
                            writer.ldelim();
                        }
                        if (message.contents_float64 != null && message.contents_float64.length) {
                            writer.uint32(/* id 23, wireType 2 =*/186).fork();
                            for (var i = 0; i < message.contents_float64.length; ++i)
                                writer.double(message.contents_float64[i]);
                            writer.ldelim();
                        }
                        if (message.contents_bool != null && message.contents_bool.length) {
                            writer.uint32(/* id 24, wireType 2 =*/194).fork();
                            for (var i = 0; i < message.contents_bool.length; ++i)
                                writer.bool(message.contents_bool[i]);
                            writer.ldelim();
                        }
                        if (message.contents_qint8 != null && message.contents_qint8.length) {
                            writer.uint32(/* id 25, wireType 2 =*/202).fork();
                            for (var i = 0; i < message.contents_qint8.length; ++i)
                                writer.sint32(message.contents_qint8[i]);
                            writer.ldelim();
                        }
                        if (message.contents_quint8 != null && message.contents_quint8.length) {
                            writer.uint32(/* id 26, wireType 2 =*/210).fork();
                            for (var i = 0; i < message.contents_quint8.length; ++i)
                                writer.uint32(message.contents_quint8[i]);
                            writer.ldelim();
                        }
                        if (message.contents_qint32 != null && message.contents_qint32.length) {
                            writer.uint32(/* id 27, wireType 2 =*/218).fork();
                            for (var i = 0; i < message.contents_qint32.length; ++i)
                                writer.sint32(message.contents_qint32[i]);
                            writer.ldelim();
                        }
                        if (message.contents_bfloat16 != null && message.contents_bfloat16.length) {
                            writer.uint32(/* id 28, wireType 2 =*/226).fork();
                            for (var i = 0; i < message.contents_bfloat16.length; ++i)
                                writer.float(message.contents_bfloat16[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };

                    /**
                     * Encodes the specified TensorData message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.TensorData.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @static
                     * @param {syft_proto.types.torch.v1.ITensorData} message TensorData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TensorData.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TensorData message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.TensorData} TensorData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TensorData.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.TensorData();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.shape = $root.syft_proto.types.torch.v1.Size.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.dtype = reader.string();
                                break;
                            case 3:
                                message.is_quantized = reader.bool();
                                break;
                            case 4:
                                message.scale = reader.float();
                                break;
                            case 5:
                                message.zero_point = reader.int32();
                                break;
                            case 16:
                                if (!(message.contents_uint8 && message.contents_uint8.length))
                                    message.contents_uint8 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_uint8.push(reader.uint32());
                                } else
                                    message.contents_uint8.push(reader.uint32());
                                break;
                            case 17:
                                if (!(message.contents_int8 && message.contents_int8.length))
                                    message.contents_int8 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_int8.push(reader.int32());
                                } else
                                    message.contents_int8.push(reader.int32());
                                break;
                            case 18:
                                if (!(message.contents_int16 && message.contents_int16.length))
                                    message.contents_int16 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_int16.push(reader.int32());
                                } else
                                    message.contents_int16.push(reader.int32());
                                break;
                            case 19:
                                if (!(message.contents_int32 && message.contents_int32.length))
                                    message.contents_int32 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_int32.push(reader.int32());
                                } else
                                    message.contents_int32.push(reader.int32());
                                break;
                            case 20:
                                if (!(message.contents_int64 && message.contents_int64.length))
                                    message.contents_int64 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_int64.push(reader.int64());
                                } else
                                    message.contents_int64.push(reader.int64());
                                break;
                            case 21:
                                if (!(message.contents_float16 && message.contents_float16.length))
                                    message.contents_float16 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_float16.push(reader.float());
                                } else
                                    message.contents_float16.push(reader.float());
                                break;
                            case 22:
                                if (!(message.contents_float32 && message.contents_float32.length))
                                    message.contents_float32 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_float32.push(reader.float());
                                } else
                                    message.contents_float32.push(reader.float());
                                break;
                            case 23:
                                if (!(message.contents_float64 && message.contents_float64.length))
                                    message.contents_float64 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_float64.push(reader.double());
                                } else
                                    message.contents_float64.push(reader.double());
                                break;
                            case 24:
                                if (!(message.contents_bool && message.contents_bool.length))
                                    message.contents_bool = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_bool.push(reader.bool());
                                } else
                                    message.contents_bool.push(reader.bool());
                                break;
                            case 25:
                                if (!(message.contents_qint8 && message.contents_qint8.length))
                                    message.contents_qint8 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_qint8.push(reader.sint32());
                                } else
                                    message.contents_qint8.push(reader.sint32());
                                break;
                            case 26:
                                if (!(message.contents_quint8 && message.contents_quint8.length))
                                    message.contents_quint8 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_quint8.push(reader.uint32());
                                } else
                                    message.contents_quint8.push(reader.uint32());
                                break;
                            case 27:
                                if (!(message.contents_qint32 && message.contents_qint32.length))
                                    message.contents_qint32 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_qint32.push(reader.sint32());
                                } else
                                    message.contents_qint32.push(reader.sint32());
                                break;
                            case 28:
                                if (!(message.contents_bfloat16 && message.contents_bfloat16.length))
                                    message.contents_bfloat16 = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.contents_bfloat16.push(reader.float());
                                } else
                                    message.contents_bfloat16.push(reader.float());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TensorData message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.TensorData} TensorData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TensorData.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TensorData message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TensorData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.shape != null && message.hasOwnProperty("shape")) {
                            var error = $root.syft_proto.types.torch.v1.Size.verify(message.shape);
                            if (error)
                                return "shape." + error;
                        }
                        if (message.dtype != null && message.hasOwnProperty("dtype"))
                            if (!$util.isString(message.dtype))
                                return "dtype: string expected";
                        if (message.is_quantized != null && message.hasOwnProperty("is_quantized"))
                            if (typeof message.is_quantized !== "boolean")
                                return "is_quantized: boolean expected";
                        if (message.scale != null && message.hasOwnProperty("scale"))
                            if (typeof message.scale !== "number")
                                return "scale: number expected";
                        if (message.zero_point != null && message.hasOwnProperty("zero_point"))
                            if (!$util.isInteger(message.zero_point))
                                return "zero_point: integer expected";
                        if (message.contents_uint8 != null && message.hasOwnProperty("contents_uint8")) {
                            if (!Array.isArray(message.contents_uint8))
                                return "contents_uint8: array expected";
                            for (var i = 0; i < message.contents_uint8.length; ++i)
                                if (!$util.isInteger(message.contents_uint8[i]))
                                    return "contents_uint8: integer[] expected";
                        }
                        if (message.contents_int8 != null && message.hasOwnProperty("contents_int8")) {
                            if (!Array.isArray(message.contents_int8))
                                return "contents_int8: array expected";
                            for (var i = 0; i < message.contents_int8.length; ++i)
                                if (!$util.isInteger(message.contents_int8[i]))
                                    return "contents_int8: integer[] expected";
                        }
                        if (message.contents_int16 != null && message.hasOwnProperty("contents_int16")) {
                            if (!Array.isArray(message.contents_int16))
                                return "contents_int16: array expected";
                            for (var i = 0; i < message.contents_int16.length; ++i)
                                if (!$util.isInteger(message.contents_int16[i]))
                                    return "contents_int16: integer[] expected";
                        }
                        if (message.contents_int32 != null && message.hasOwnProperty("contents_int32")) {
                            if (!Array.isArray(message.contents_int32))
                                return "contents_int32: array expected";
                            for (var i = 0; i < message.contents_int32.length; ++i)
                                if (!$util.isInteger(message.contents_int32[i]))
                                    return "contents_int32: integer[] expected";
                        }
                        if (message.contents_int64 != null && message.hasOwnProperty("contents_int64")) {
                            if (!Array.isArray(message.contents_int64))
                                return "contents_int64: array expected";
                            for (var i = 0; i < message.contents_int64.length; ++i)
                                if (!$util.isInteger(message.contents_int64[i]) && !(message.contents_int64[i] && $util.isInteger(message.contents_int64[i].low) && $util.isInteger(message.contents_int64[i].high)))
                                    return "contents_int64: integer|Long[] expected";
                        }
                        if (message.contents_float16 != null && message.hasOwnProperty("contents_float16")) {
                            if (!Array.isArray(message.contents_float16))
                                return "contents_float16: array expected";
                            for (var i = 0; i < message.contents_float16.length; ++i)
                                if (typeof message.contents_float16[i] !== "number")
                                    return "contents_float16: number[] expected";
                        }
                        if (message.contents_float32 != null && message.hasOwnProperty("contents_float32")) {
                            if (!Array.isArray(message.contents_float32))
                                return "contents_float32: array expected";
                            for (var i = 0; i < message.contents_float32.length; ++i)
                                if (typeof message.contents_float32[i] !== "number")
                                    return "contents_float32: number[] expected";
                        }
                        if (message.contents_float64 != null && message.hasOwnProperty("contents_float64")) {
                            if (!Array.isArray(message.contents_float64))
                                return "contents_float64: array expected";
                            for (var i = 0; i < message.contents_float64.length; ++i)
                                if (typeof message.contents_float64[i] !== "number")
                                    return "contents_float64: number[] expected";
                        }
                        if (message.contents_bool != null && message.hasOwnProperty("contents_bool")) {
                            if (!Array.isArray(message.contents_bool))
                                return "contents_bool: array expected";
                            for (var i = 0; i < message.contents_bool.length; ++i)
                                if (typeof message.contents_bool[i] !== "boolean")
                                    return "contents_bool: boolean[] expected";
                        }
                        if (message.contents_qint8 != null && message.hasOwnProperty("contents_qint8")) {
                            if (!Array.isArray(message.contents_qint8))
                                return "contents_qint8: array expected";
                            for (var i = 0; i < message.contents_qint8.length; ++i)
                                if (!$util.isInteger(message.contents_qint8[i]))
                                    return "contents_qint8: integer[] expected";
                        }
                        if (message.contents_quint8 != null && message.hasOwnProperty("contents_quint8")) {
                            if (!Array.isArray(message.contents_quint8))
                                return "contents_quint8: array expected";
                            for (var i = 0; i < message.contents_quint8.length; ++i)
                                if (!$util.isInteger(message.contents_quint8[i]))
                                    return "contents_quint8: integer[] expected";
                        }
                        if (message.contents_qint32 != null && message.hasOwnProperty("contents_qint32")) {
                            if (!Array.isArray(message.contents_qint32))
                                return "contents_qint32: array expected";
                            for (var i = 0; i < message.contents_qint32.length; ++i)
                                if (!$util.isInteger(message.contents_qint32[i]))
                                    return "contents_qint32: integer[] expected";
                        }
                        if (message.contents_bfloat16 != null && message.hasOwnProperty("contents_bfloat16")) {
                            if (!Array.isArray(message.contents_bfloat16))
                                return "contents_bfloat16: array expected";
                            for (var i = 0; i < message.contents_bfloat16.length; ++i)
                                if (typeof message.contents_bfloat16[i] !== "number")
                                    return "contents_bfloat16: number[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a TensorData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.TensorData} TensorData
                     */
                    TensorData.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.TensorData)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.TensorData();
                        if (object.shape != null) {
                            if (typeof object.shape !== "object")
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.shape: object expected");
                            message.shape = $root.syft_proto.types.torch.v1.Size.fromObject(object.shape);
                        }
                        if (object.dtype != null)
                            message.dtype = String(object.dtype);
                        if (object.is_quantized != null)
                            message.is_quantized = Boolean(object.is_quantized);
                        if (object.scale != null)
                            message.scale = Number(object.scale);
                        if (object.zero_point != null)
                            message.zero_point = object.zero_point | 0;
                        if (object.contents_uint8) {
                            if (!Array.isArray(object.contents_uint8))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_uint8: array expected");
                            message.contents_uint8 = [];
                            for (var i = 0; i < object.contents_uint8.length; ++i)
                                message.contents_uint8[i] = object.contents_uint8[i] >>> 0;
                        }
                        if (object.contents_int8) {
                            if (!Array.isArray(object.contents_int8))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_int8: array expected");
                            message.contents_int8 = [];
                            for (var i = 0; i < object.contents_int8.length; ++i)
                                message.contents_int8[i] = object.contents_int8[i] | 0;
                        }
                        if (object.contents_int16) {
                            if (!Array.isArray(object.contents_int16))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_int16: array expected");
                            message.contents_int16 = [];
                            for (var i = 0; i < object.contents_int16.length; ++i)
                                message.contents_int16[i] = object.contents_int16[i] | 0;
                        }
                        if (object.contents_int32) {
                            if (!Array.isArray(object.contents_int32))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_int32: array expected");
                            message.contents_int32 = [];
                            for (var i = 0; i < object.contents_int32.length; ++i)
                                message.contents_int32[i] = object.contents_int32[i] | 0;
                        }
                        if (object.contents_int64) {
                            if (!Array.isArray(object.contents_int64))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_int64: array expected");
                            message.contents_int64 = [];
                            for (var i = 0; i < object.contents_int64.length; ++i)
                                if ($util.Long)
                                    (message.contents_int64[i] = $util.Long.fromValue(object.contents_int64[i])).unsigned = false;
                                else if (typeof object.contents_int64[i] === "string")
                                    message.contents_int64[i] = parseInt(object.contents_int64[i], 10);
                                else if (typeof object.contents_int64[i] === "number")
                                    message.contents_int64[i] = object.contents_int64[i];
                                else if (typeof object.contents_int64[i] === "object")
                                    message.contents_int64[i] = new $util.LongBits(object.contents_int64[i].low >>> 0, object.contents_int64[i].high >>> 0).toNumber();
                        }
                        if (object.contents_float16) {
                            if (!Array.isArray(object.contents_float16))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_float16: array expected");
                            message.contents_float16 = [];
                            for (var i = 0; i < object.contents_float16.length; ++i)
                                message.contents_float16[i] = Number(object.contents_float16[i]);
                        }
                        if (object.contents_float32) {
                            if (!Array.isArray(object.contents_float32))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_float32: array expected");
                            message.contents_float32 = [];
                            for (var i = 0; i < object.contents_float32.length; ++i)
                                message.contents_float32[i] = Number(object.contents_float32[i]);
                        }
                        if (object.contents_float64) {
                            if (!Array.isArray(object.contents_float64))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_float64: array expected");
                            message.contents_float64 = [];
                            for (var i = 0; i < object.contents_float64.length; ++i)
                                message.contents_float64[i] = Number(object.contents_float64[i]);
                        }
                        if (object.contents_bool) {
                            if (!Array.isArray(object.contents_bool))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_bool: array expected");
                            message.contents_bool = [];
                            for (var i = 0; i < object.contents_bool.length; ++i)
                                message.contents_bool[i] = Boolean(object.contents_bool[i]);
                        }
                        if (object.contents_qint8) {
                            if (!Array.isArray(object.contents_qint8))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_qint8: array expected");
                            message.contents_qint8 = [];
                            for (var i = 0; i < object.contents_qint8.length; ++i)
                                message.contents_qint8[i] = object.contents_qint8[i] | 0;
                        }
                        if (object.contents_quint8) {
                            if (!Array.isArray(object.contents_quint8))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_quint8: array expected");
                            message.contents_quint8 = [];
                            for (var i = 0; i < object.contents_quint8.length; ++i)
                                message.contents_quint8[i] = object.contents_quint8[i] >>> 0;
                        }
                        if (object.contents_qint32) {
                            if (!Array.isArray(object.contents_qint32))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_qint32: array expected");
                            message.contents_qint32 = [];
                            for (var i = 0; i < object.contents_qint32.length; ++i)
                                message.contents_qint32[i] = object.contents_qint32[i] | 0;
                        }
                        if (object.contents_bfloat16) {
                            if (!Array.isArray(object.contents_bfloat16))
                                throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_bfloat16: array expected");
                            message.contents_bfloat16 = [];
                            for (var i = 0; i < object.contents_bfloat16.length; ++i)
                                message.contents_bfloat16[i] = Number(object.contents_bfloat16[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TensorData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @static
                     * @param {syft_proto.types.torch.v1.TensorData} message TensorData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TensorData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.contents_uint8 = [];
                            object.contents_int8 = [];
                            object.contents_int16 = [];
                            object.contents_int32 = [];
                            object.contents_int64 = [];
                            object.contents_float16 = [];
                            object.contents_float32 = [];
                            object.contents_float64 = [];
                            object.contents_bool = [];
                            object.contents_qint8 = [];
                            object.contents_quint8 = [];
                            object.contents_qint32 = [];
                            object.contents_bfloat16 = [];
                        }
                        if (options.defaults) {
                            object.shape = null;
                            object.dtype = "";
                            object.is_quantized = false;
                            object.scale = 0;
                            object.zero_point = 0;
                        }
                        if (message.shape != null && message.hasOwnProperty("shape"))
                            object.shape = $root.syft_proto.types.torch.v1.Size.toObject(message.shape, options);
                        if (message.dtype != null && message.hasOwnProperty("dtype"))
                            object.dtype = message.dtype;
                        if (message.is_quantized != null && message.hasOwnProperty("is_quantized"))
                            object.is_quantized = message.is_quantized;
                        if (message.scale != null && message.hasOwnProperty("scale"))
                            object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
                        if (message.zero_point != null && message.hasOwnProperty("zero_point"))
                            object.zero_point = message.zero_point;
                        if (message.contents_uint8 && message.contents_uint8.length) {
                            object.contents_uint8 = [];
                            for (var j = 0; j < message.contents_uint8.length; ++j)
                                object.contents_uint8[j] = message.contents_uint8[j];
                        }
                        if (message.contents_int8 && message.contents_int8.length) {
                            object.contents_int8 = [];
                            for (var j = 0; j < message.contents_int8.length; ++j)
                                object.contents_int8[j] = message.contents_int8[j];
                        }
                        if (message.contents_int16 && message.contents_int16.length) {
                            object.contents_int16 = [];
                            for (var j = 0; j < message.contents_int16.length; ++j)
                                object.contents_int16[j] = message.contents_int16[j];
                        }
                        if (message.contents_int32 && message.contents_int32.length) {
                            object.contents_int32 = [];
                            for (var j = 0; j < message.contents_int32.length; ++j)
                                object.contents_int32[j] = message.contents_int32[j];
                        }
                        if (message.contents_int64 && message.contents_int64.length) {
                            object.contents_int64 = [];
                            for (var j = 0; j < message.contents_int64.length; ++j)
                                if (typeof message.contents_int64[j] === "number")
                                    object.contents_int64[j] = options.longs === String ? String(message.contents_int64[j]) : message.contents_int64[j];
                                else
                                    object.contents_int64[j] = options.longs === String ? $util.Long.prototype.toString.call(message.contents_int64[j]) : options.longs === Number ? new $util.LongBits(message.contents_int64[j].low >>> 0, message.contents_int64[j].high >>> 0).toNumber() : message.contents_int64[j];
                        }
                        if (message.contents_float16 && message.contents_float16.length) {
                            object.contents_float16 = [];
                            for (var j = 0; j < message.contents_float16.length; ++j)
                                object.contents_float16[j] = options.json && !isFinite(message.contents_float16[j]) ? String(message.contents_float16[j]) : message.contents_float16[j];
                        }
                        if (message.contents_float32 && message.contents_float32.length) {
                            object.contents_float32 = [];
                            for (var j = 0; j < message.contents_float32.length; ++j)
                                object.contents_float32[j] = options.json && !isFinite(message.contents_float32[j]) ? String(message.contents_float32[j]) : message.contents_float32[j];
                        }
                        if (message.contents_float64 && message.contents_float64.length) {
                            object.contents_float64 = [];
                            for (var j = 0; j < message.contents_float64.length; ++j)
                                object.contents_float64[j] = options.json && !isFinite(message.contents_float64[j]) ? String(message.contents_float64[j]) : message.contents_float64[j];
                        }
                        if (message.contents_bool && message.contents_bool.length) {
                            object.contents_bool = [];
                            for (var j = 0; j < message.contents_bool.length; ++j)
                                object.contents_bool[j] = message.contents_bool[j];
                        }
                        if (message.contents_qint8 && message.contents_qint8.length) {
                            object.contents_qint8 = [];
                            for (var j = 0; j < message.contents_qint8.length; ++j)
                                object.contents_qint8[j] = message.contents_qint8[j];
                        }
                        if (message.contents_quint8 && message.contents_quint8.length) {
                            object.contents_quint8 = [];
                            for (var j = 0; j < message.contents_quint8.length; ++j)
                                object.contents_quint8[j] = message.contents_quint8[j];
                        }
                        if (message.contents_qint32 && message.contents_qint32.length) {
                            object.contents_qint32 = [];
                            for (var j = 0; j < message.contents_qint32.length; ++j)
                                object.contents_qint32[j] = message.contents_qint32[j];
                        }
                        if (message.contents_bfloat16 && message.contents_bfloat16.length) {
                            object.contents_bfloat16 = [];
                            for (var j = 0; j < message.contents_bfloat16.length; ++j)
                                object.contents_bfloat16[j] = options.json && !isFinite(message.contents_bfloat16[j]) ? String(message.contents_bfloat16[j]) : message.contents_bfloat16[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this TensorData to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.TensorData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TensorData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return TensorData;
                })();

                v1.Size = (function() {

                    /**
                     * Properties of a Size.
                     * @memberof syft_proto.types.torch.v1
                     * @interface ISize
                     * @property {Array.<number>|null} [dims] Size dims
                     */

                    /**
                     * Constructs a new Size.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a Size.
                     * @implements ISize
                     * @constructor
                     * @param {syft_proto.types.torch.v1.ISize=} [properties] Properties to set
                     */
                    function Size(properties) {
                        this.dims = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Size dims.
                     * @member {Array.<number>} dims
                     * @memberof syft_proto.types.torch.v1.Size
                     * @instance
                     */
                    Size.prototype.dims = $util.emptyArray;

                    /**
                     * Creates a new Size instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.Size
                     * @static
                     * @param {syft_proto.types.torch.v1.ISize=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.Size} Size instance
                     */
                    Size.create = function create(properties) {
                        return new Size(properties);
                    };

                    /**
                     * Encodes the specified Size message. Does not implicitly {@link syft_proto.types.torch.v1.Size.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.Size
                     * @static
                     * @param {syft_proto.types.torch.v1.ISize} message Size message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Size.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.dims != null && message.dims.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.dims.length; ++i)
                                writer.int32(message.dims[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };

                    /**
                     * Encodes the specified Size message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.Size.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.Size
                     * @static
                     * @param {syft_proto.types.torch.v1.ISize} message Size message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Size.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Size message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.Size
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.Size} Size
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Size.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.Size();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.dims && message.dims.length))
                                    message.dims = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.dims.push(reader.int32());
                                } else
                                    message.dims.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Size message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.Size
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.Size} Size
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Size.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Size message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.Size
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Size.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.dims != null && message.hasOwnProperty("dims")) {
                            if (!Array.isArray(message.dims))
                                return "dims: array expected";
                            for (var i = 0; i < message.dims.length; ++i)
                                if (!$util.isInteger(message.dims[i]))
                                    return "dims: integer[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Size message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.Size
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.Size} Size
                     */
                    Size.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.Size)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.Size();
                        if (object.dims) {
                            if (!Array.isArray(object.dims))
                                throw TypeError(".syft_proto.types.torch.v1.Size.dims: array expected");
                            message.dims = [];
                            for (var i = 0; i < object.dims.length; ++i)
                                message.dims[i] = object.dims[i] | 0;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Size message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.Size
                     * @static
                     * @param {syft_proto.types.torch.v1.Size} message Size
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Size.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.dims = [];
                        if (message.dims && message.dims.length) {
                            object.dims = [];
                            for (var j = 0; j < message.dims.length; ++j)
                                object.dims[j] = message.dims[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Size to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.Size
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Size.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return Size;
                })();

                v1.Parameter = (function() {

                    /**
                     * Properties of a Parameter.
                     * @memberof syft_proto.types.torch.v1
                     * @interface IParameter
                     * @property {syft_proto.types.syft.v1.IId|null} [id] Parameter id
                     * @property {syft_proto.types.torch.v1.ITorchTensor|null} [tensor] Parameter tensor
                     * @property {boolean|null} [requires_grad] Parameter requires_grad
                     * @property {syft_proto.types.torch.v1.ITorchTensor|null} [grad] Parameter grad
                     */

                    /**
                     * Constructs a new Parameter.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a Parameter.
                     * @implements IParameter
                     * @constructor
                     * @param {syft_proto.types.torch.v1.IParameter=} [properties] Properties to set
                     */
                    function Parameter(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Parameter id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @instance
                     */
                    Parameter.prototype.id = null;

                    /**
                     * Parameter tensor.
                     * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} tensor
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @instance
                     */
                    Parameter.prototype.tensor = null;

                    /**
                     * Parameter requires_grad.
                     * @member {boolean} requires_grad
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @instance
                     */
                    Parameter.prototype.requires_grad = false;

                    /**
                     * Parameter grad.
                     * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} grad
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @instance
                     */
                    Parameter.prototype.grad = null;

                    /**
                     * Creates a new Parameter instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @static
                     * @param {syft_proto.types.torch.v1.IParameter=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.Parameter} Parameter instance
                     */
                    Parameter.create = function create(properties) {
                        return new Parameter(properties);
                    };

                    /**
                     * Encodes the specified Parameter message. Does not implicitly {@link syft_proto.types.torch.v1.Parameter.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @static
                     * @param {syft_proto.types.torch.v1.IParameter} message Parameter message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Parameter.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.tensor != null && message.hasOwnProperty("tensor"))
                            $root.syft_proto.types.torch.v1.TorchTensor.encode(message.tensor, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.requires_grad != null && message.hasOwnProperty("requires_grad"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.requires_grad);
                        if (message.grad != null && message.hasOwnProperty("grad"))
                            $root.syft_proto.types.torch.v1.TorchTensor.encode(message.grad, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Parameter message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.Parameter.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @static
                     * @param {syft_proto.types.torch.v1.IParameter} message Parameter message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Parameter.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Parameter message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.Parameter} Parameter
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Parameter.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.Parameter();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.requires_grad = reader.bool();
                                break;
                            case 4:
                                message.grad = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Parameter message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.Parameter} Parameter
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Parameter.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Parameter message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Parameter.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                            if (error)
                                return "id." + error;
                        }
                        if (message.tensor != null && message.hasOwnProperty("tensor")) {
                            var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.tensor);
                            if (error)
                                return "tensor." + error;
                        }
                        if (message.requires_grad != null && message.hasOwnProperty("requires_grad"))
                            if (typeof message.requires_grad !== "boolean")
                                return "requires_grad: boolean expected";
                        if (message.grad != null && message.hasOwnProperty("grad")) {
                            var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.grad);
                            if (error)
                                return "grad." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Parameter message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.Parameter} Parameter
                     */
                    Parameter.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.Parameter)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.Parameter();
                        if (object.id != null) {
                            if (typeof object.id !== "object")
                                throw TypeError(".syft_proto.types.torch.v1.Parameter.id: object expected");
                            message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                        }
                        if (object.tensor != null) {
                            if (typeof object.tensor !== "object")
                                throw TypeError(".syft_proto.types.torch.v1.Parameter.tensor: object expected");
                            message.tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.tensor);
                        }
                        if (object.requires_grad != null)
                            message.requires_grad = Boolean(object.requires_grad);
                        if (object.grad != null) {
                            if (typeof object.grad !== "object")
                                throw TypeError(".syft_proto.types.torch.v1.Parameter.grad: object expected");
                            message.grad = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.grad);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Parameter message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @static
                     * @param {syft_proto.types.torch.v1.Parameter} message Parameter
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Parameter.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = null;
                            object.tensor = null;
                            object.requires_grad = false;
                            object.grad = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                        if (message.tensor != null && message.hasOwnProperty("tensor"))
                            object.tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.tensor, options);
                        if (message.requires_grad != null && message.hasOwnProperty("requires_grad"))
                            object.requires_grad = message.requires_grad;
                        if (message.grad != null && message.hasOwnProperty("grad"))
                            object.grad = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.grad, options);
                        return object;
                    };

                    /**
                     * Converts this Parameter to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.Parameter
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Parameter.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return Parameter;
                })();

                v1.CFunction = (function() {

                    /**
                     * Properties of a CFunction.
                     * @memberof syft_proto.types.torch.v1
                     * @interface ICFunction
                     * @property {Uint8Array|null} [obj] CFunction obj
                     */

                    /**
                     * Constructs a new CFunction.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a CFunction.
                     * @implements ICFunction
                     * @constructor
                     * @param {syft_proto.types.torch.v1.ICFunction=} [properties] Properties to set
                     */
                    function CFunction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CFunction obj.
                     * @member {Uint8Array} obj
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @instance
                     */
                    CFunction.prototype.obj = $util.newBuffer([]);

                    /**
                     * Creates a new CFunction instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @static
                     * @param {syft_proto.types.torch.v1.ICFunction=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.CFunction} CFunction instance
                     */
                    CFunction.create = function create(properties) {
                        return new CFunction(properties);
                    };

                    /**
                     * Encodes the specified CFunction message. Does not implicitly {@link syft_proto.types.torch.v1.CFunction.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @static
                     * @param {syft_proto.types.torch.v1.ICFunction} message CFunction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CFunction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.obj);
                        return writer;
                    };

                    /**
                     * Encodes the specified CFunction message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.CFunction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @static
                     * @param {syft_proto.types.torch.v1.ICFunction} message CFunction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CFunction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CFunction message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.CFunction} CFunction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CFunction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.CFunction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.obj = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CFunction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.CFunction} CFunction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CFunction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CFunction message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CFunction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                                return "obj: buffer expected";
                        return null;
                    };

                    /**
                     * Creates a CFunction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.CFunction} CFunction
                     */
                    CFunction.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.CFunction)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.CFunction();
                        if (object.obj != null)
                            if (typeof object.obj === "string")
                                $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                            else if (object.obj.length)
                                message.obj = object.obj;
                        return message;
                    };

                    /**
                     * Creates a plain object from a CFunction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @static
                     * @param {syft_proto.types.torch.v1.CFunction} message CFunction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CFunction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.obj = "";
                            else {
                                object.obj = [];
                                if (options.bytes !== Array)
                                    object.obj = $util.newBuffer(object.obj);
                            }
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                        return object;
                    };

                    /**
                     * Converts this CFunction to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.CFunction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CFunction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return CFunction;
                })();

                v1.Device = (function() {

                    /**
                     * Properties of a Device.
                     * @memberof syft_proto.types.torch.v1
                     * @interface IDevice
                     * @property {string|null} [type] Device type
                     */

                    /**
                     * Constructs a new Device.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a Device.
                     * @implements IDevice
                     * @constructor
                     * @param {syft_proto.types.torch.v1.IDevice=} [properties] Properties to set
                     */
                    function Device(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Device type.
                     * @member {string} type
                     * @memberof syft_proto.types.torch.v1.Device
                     * @instance
                     */
                    Device.prototype.type = "";

                    /**
                     * Creates a new Device instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.Device
                     * @static
                     * @param {syft_proto.types.torch.v1.IDevice=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.Device} Device instance
                     */
                    Device.create = function create(properties) {
                        return new Device(properties);
                    };

                    /**
                     * Encodes the specified Device message. Does not implicitly {@link syft_proto.types.torch.v1.Device.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.Device
                     * @static
                     * @param {syft_proto.types.torch.v1.IDevice} message Device message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Device.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified Device message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.Device.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.Device
                     * @static
                     * @param {syft_proto.types.torch.v1.IDevice} message Device message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Device.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Device message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.Device
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.Device} Device
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Device.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.Device();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Device message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.Device
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.Device} Device
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Device.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Device message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.Device
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Device.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };

                    /**
                     * Creates a Device message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.Device
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.Device} Device
                     */
                    Device.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.Device)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.Device();
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Device message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.Device
                     * @static
                     * @param {syft_proto.types.torch.v1.Device} message Device
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Device.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.type = "";
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };

                    /**
                     * Converts this Device to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.Device
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Device.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return Device;
                })();

                v1.TorchDType = (function() {

                    /**
                     * Properties of a TorchDType.
                     * @memberof syft_proto.types.torch.v1
                     * @interface ITorchDType
                     * @property {string|null} [torch_type] TorchDType torch_type
                     */

                    /**
                     * Constructs a new TorchDType.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a TorchDType.
                     * @implements ITorchDType
                     * @constructor
                     * @param {syft_proto.types.torch.v1.ITorchDType=} [properties] Properties to set
                     */
                    function TorchDType(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TorchDType torch_type.
                     * @member {string} torch_type
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @instance
                     */
                    TorchDType.prototype.torch_type = "";

                    /**
                     * Creates a new TorchDType instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @static
                     * @param {syft_proto.types.torch.v1.ITorchDType=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.TorchDType} TorchDType instance
                     */
                    TorchDType.create = function create(properties) {
                        return new TorchDType(properties);
                    };

                    /**
                     * Encodes the specified TorchDType message. Does not implicitly {@link syft_proto.types.torch.v1.TorchDType.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @static
                     * @param {syft_proto.types.torch.v1.ITorchDType} message TorchDType message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TorchDType.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.torch_type != null && message.hasOwnProperty("torch_type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.torch_type);
                        return writer;
                    };

                    /**
                     * Encodes the specified TorchDType message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.TorchDType.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @static
                     * @param {syft_proto.types.torch.v1.ITorchDType} message TorchDType message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TorchDType.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TorchDType message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.TorchDType} TorchDType
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TorchDType.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.TorchDType();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.torch_type = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TorchDType message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.TorchDType} TorchDType
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TorchDType.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TorchDType message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TorchDType.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.torch_type != null && message.hasOwnProperty("torch_type"))
                            if (!$util.isString(message.torch_type))
                                return "torch_type: string expected";
                        return null;
                    };

                    /**
                     * Creates a TorchDType message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.TorchDType} TorchDType
                     */
                    TorchDType.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.TorchDType)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.TorchDType();
                        if (object.torch_type != null)
                            message.torch_type = String(object.torch_type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TorchDType message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @static
                     * @param {syft_proto.types.torch.v1.TorchDType} message TorchDType
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TorchDType.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.torch_type = "";
                        if (message.torch_type != null && message.hasOwnProperty("torch_type"))
                            object.torch_type = message.torch_type;
                        return object;
                    };

                    /**
                     * Converts this TorchDType to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.TorchDType
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TorchDType.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return TorchDType;
                })();

                v1.MemoryFormat = (function() {

                    /**
                     * Properties of a MemoryFormat.
                     * @memberof syft_proto.types.torch.v1
                     * @interface IMemoryFormat
                     * @property {string|null} [memory_format_type] MemoryFormat memory_format_type
                     */

                    /**
                     * Constructs a new MemoryFormat.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a MemoryFormat.
                     * @implements IMemoryFormat
                     * @constructor
                     * @param {syft_proto.types.torch.v1.IMemoryFormat=} [properties] Properties to set
                     */
                    function MemoryFormat(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MemoryFormat memory_format_type.
                     * @member {string} memory_format_type
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @instance
                     */
                    MemoryFormat.prototype.memory_format_type = "";

                    /**
                     * Creates a new MemoryFormat instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @static
                     * @param {syft_proto.types.torch.v1.IMemoryFormat=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.MemoryFormat} MemoryFormat instance
                     */
                    MemoryFormat.create = function create(properties) {
                        return new MemoryFormat(properties);
                    };

                    /**
                     * Encodes the specified MemoryFormat message. Does not implicitly {@link syft_proto.types.torch.v1.MemoryFormat.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @static
                     * @param {syft_proto.types.torch.v1.IMemoryFormat} message MemoryFormat message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoryFormat.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.memory_format_type != null && message.hasOwnProperty("memory_format_type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.memory_format_type);
                        return writer;
                    };

                    /**
                     * Encodes the specified MemoryFormat message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.MemoryFormat.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @static
                     * @param {syft_proto.types.torch.v1.IMemoryFormat} message MemoryFormat message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoryFormat.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MemoryFormat message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.MemoryFormat} MemoryFormat
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoryFormat.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.MemoryFormat();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.memory_format_type = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MemoryFormat message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.MemoryFormat} MemoryFormat
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoryFormat.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MemoryFormat message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoryFormat.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.memory_format_type != null && message.hasOwnProperty("memory_format_type"))
                            if (!$util.isString(message.memory_format_type))
                                return "memory_format_type: string expected";
                        return null;
                    };

                    /**
                     * Creates a MemoryFormat message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.MemoryFormat} MemoryFormat
                     */
                    MemoryFormat.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.MemoryFormat)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.MemoryFormat();
                        if (object.memory_format_type != null)
                            message.memory_format_type = String(object.memory_format_type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a MemoryFormat message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @static
                     * @param {syft_proto.types.torch.v1.MemoryFormat} message MemoryFormat
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoryFormat.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.memory_format_type = "";
                        if (message.memory_format_type != null && message.hasOwnProperty("memory_format_type"))
                            object.memory_format_type = message.memory_format_type;
                        return object;
                    };

                    /**
                     * Converts this MemoryFormat to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.MemoryFormat
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoryFormat.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return MemoryFormat;
                })();

                v1.ScriptFunction = (function() {

                    /**
                     * Properties of a ScriptFunction.
                     * @memberof syft_proto.types.torch.v1
                     * @interface IScriptFunction
                     * @property {Uint8Array|null} [obj] ScriptFunction obj
                     */

                    /**
                     * Constructs a new ScriptFunction.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a ScriptFunction.
                     * @implements IScriptFunction
                     * @constructor
                     * @param {syft_proto.types.torch.v1.IScriptFunction=} [properties] Properties to set
                     */
                    function ScriptFunction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ScriptFunction obj.
                     * @member {Uint8Array} obj
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @instance
                     */
                    ScriptFunction.prototype.obj = $util.newBuffer([]);

                    /**
                     * Creates a new ScriptFunction instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @static
                     * @param {syft_proto.types.torch.v1.IScriptFunction=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.ScriptFunction} ScriptFunction instance
                     */
                    ScriptFunction.create = function create(properties) {
                        return new ScriptFunction(properties);
                    };

                    /**
                     * Encodes the specified ScriptFunction message. Does not implicitly {@link syft_proto.types.torch.v1.ScriptFunction.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @static
                     * @param {syft_proto.types.torch.v1.IScriptFunction} message ScriptFunction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScriptFunction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.obj);
                        return writer;
                    };

                    /**
                     * Encodes the specified ScriptFunction message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.ScriptFunction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @static
                     * @param {syft_proto.types.torch.v1.IScriptFunction} message ScriptFunction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScriptFunction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ScriptFunction message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.ScriptFunction} ScriptFunction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScriptFunction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.ScriptFunction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.obj = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ScriptFunction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.ScriptFunction} ScriptFunction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScriptFunction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ScriptFunction message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ScriptFunction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                                return "obj: buffer expected";
                        return null;
                    };

                    /**
                     * Creates a ScriptFunction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.ScriptFunction} ScriptFunction
                     */
                    ScriptFunction.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.ScriptFunction)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.ScriptFunction();
                        if (object.obj != null)
                            if (typeof object.obj === "string")
                                $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                            else if (object.obj.length)
                                message.obj = object.obj;
                        return message;
                    };

                    /**
                     * Creates a plain object from a ScriptFunction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @static
                     * @param {syft_proto.types.torch.v1.ScriptFunction} message ScriptFunction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ScriptFunction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.obj = "";
                            else {
                                object.obj = [];
                                if (options.bytes !== Array)
                                    object.obj = $util.newBuffer(object.obj);
                            }
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                        return object;
                    };

                    /**
                     * Converts this ScriptFunction to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.ScriptFunction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ScriptFunction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return ScriptFunction;
                })();

                v1.ScriptModule = (function() {

                    /**
                     * Properties of a ScriptModule.
                     * @memberof syft_proto.types.torch.v1
                     * @interface IScriptModule
                     * @property {Uint8Array|null} [obj] ScriptModule obj
                     */

                    /**
                     * Constructs a new ScriptModule.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a ScriptModule.
                     * @implements IScriptModule
                     * @constructor
                     * @param {syft_proto.types.torch.v1.IScriptModule=} [properties] Properties to set
                     */
                    function ScriptModule(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ScriptModule obj.
                     * @member {Uint8Array} obj
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @instance
                     */
                    ScriptModule.prototype.obj = $util.newBuffer([]);

                    /**
                     * Creates a new ScriptModule instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @static
                     * @param {syft_proto.types.torch.v1.IScriptModule=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.ScriptModule} ScriptModule instance
                     */
                    ScriptModule.create = function create(properties) {
                        return new ScriptModule(properties);
                    };

                    /**
                     * Encodes the specified ScriptModule message. Does not implicitly {@link syft_proto.types.torch.v1.ScriptModule.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @static
                     * @param {syft_proto.types.torch.v1.IScriptModule} message ScriptModule message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScriptModule.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.obj);
                        return writer;
                    };

                    /**
                     * Encodes the specified ScriptModule message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.ScriptModule.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @static
                     * @param {syft_proto.types.torch.v1.IScriptModule} message ScriptModule message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScriptModule.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ScriptModule message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.ScriptModule} ScriptModule
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScriptModule.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.ScriptModule();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.obj = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ScriptModule message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.ScriptModule} ScriptModule
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScriptModule.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ScriptModule message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ScriptModule.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                                return "obj: buffer expected";
                        return null;
                    };

                    /**
                     * Creates a ScriptModule message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.ScriptModule} ScriptModule
                     */
                    ScriptModule.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.ScriptModule)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.ScriptModule();
                        if (object.obj != null)
                            if (typeof object.obj === "string")
                                $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                            else if (object.obj.length)
                                message.obj = object.obj;
                        return message;
                    };

                    /**
                     * Creates a plain object from a ScriptModule message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @static
                     * @param {syft_proto.types.torch.v1.ScriptModule} message ScriptModule
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ScriptModule.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.obj = "";
                            else {
                                object.obj = [];
                                if (options.bytes !== Array)
                                    object.obj = $util.newBuffer(object.obj);
                            }
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                        return object;
                    };

                    /**
                     * Converts this ScriptModule to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.ScriptModule
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ScriptModule.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return ScriptModule;
                })();

                v1.TracedModule = (function() {

                    /**
                     * Properties of a TracedModule.
                     * @memberof syft_proto.types.torch.v1
                     * @interface ITracedModule
                     * @property {Uint8Array|null} [obj] TracedModule obj
                     */

                    /**
                     * Constructs a new TracedModule.
                     * @memberof syft_proto.types.torch.v1
                     * @classdesc Represents a TracedModule.
                     * @implements ITracedModule
                     * @constructor
                     * @param {syft_proto.types.torch.v1.ITracedModule=} [properties] Properties to set
                     */
                    function TracedModule(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TracedModule obj.
                     * @member {Uint8Array} obj
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @instance
                     */
                    TracedModule.prototype.obj = $util.newBuffer([]);

                    /**
                     * Creates a new TracedModule instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @static
                     * @param {syft_proto.types.torch.v1.ITracedModule=} [properties] Properties to set
                     * @returns {syft_proto.types.torch.v1.TracedModule} TracedModule instance
                     */
                    TracedModule.create = function create(properties) {
                        return new TracedModule(properties);
                    };

                    /**
                     * Encodes the specified TracedModule message. Does not implicitly {@link syft_proto.types.torch.v1.TracedModule.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @static
                     * @param {syft_proto.types.torch.v1.ITracedModule} message TracedModule message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TracedModule.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.obj);
                        return writer;
                    };

                    /**
                     * Encodes the specified TracedModule message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.TracedModule.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @static
                     * @param {syft_proto.types.torch.v1.ITracedModule} message TracedModule message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TracedModule.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TracedModule message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.types.torch.v1.TracedModule} TracedModule
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TracedModule.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.TracedModule();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.obj = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TracedModule message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.types.torch.v1.TracedModule} TracedModule
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TracedModule.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TracedModule message.
                     * @function verify
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TracedModule.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                                return "obj: buffer expected";
                        return null;
                    };

                    /**
                     * Creates a TracedModule message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.types.torch.v1.TracedModule} TracedModule
                     */
                    TracedModule.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.types.torch.v1.TracedModule)
                            return object;
                        var message = new $root.syft_proto.types.torch.v1.TracedModule();
                        if (object.obj != null)
                            if (typeof object.obj === "string")
                                $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                            else if (object.obj.length)
                                message.obj = object.obj;
                        return message;
                    };

                    /**
                     * Creates a plain object from a TracedModule message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @static
                     * @param {syft_proto.types.torch.v1.TracedModule} message TracedModule
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TracedModule.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.obj = "";
                            else {
                                object.obj = [];
                                if (options.bytes !== Array)
                                    object.obj = $util.newBuffer(object.obj);
                            }
                        if (message.obj != null && message.hasOwnProperty("obj"))
                            object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                        return object;
                    };

                    /**
                     * Converts this TracedModule to JSON.
                     * @function toJSON
                     * @memberof syft_proto.types.torch.v1.TracedModule
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TracedModule.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return TracedModule;
                })();

                return v1;
            })();

            return torch;
        })();

        return types;
    })();

    syft_proto.generic = (function() {

        /**
         * Namespace generic.
         * @memberof syft_proto
         * @namespace
         */
        var generic = {};

        generic.pointers = (function() {

            /**
             * Namespace pointers.
             * @memberof syft_proto.generic
             * @namespace
             */
            var pointers = {};

            pointers.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof syft_proto.generic.pointers
                 * @namespace
                 */
                var v1 = {};

                v1.PointerTensor = (function() {

                    /**
                     * Properties of a PointerTensor.
                     * @memberof syft_proto.generic.pointers.v1
                     * @interface IPointerTensor
                     * @property {syft_proto.types.syft.v1.IId|null} [object_id] PointerTensor object_id
                     * @property {syft_proto.types.syft.v1.IId|null} [location_id] PointerTensor location_id
                     * @property {syft_proto.types.syft.v1.IId|null} [object_id_at_location] PointerTensor object_id_at_location
                     * @property {syft_proto.types.syft.v1.IShape|null} [shape] PointerTensor shape
                     * @property {string|null} [point_to_attr] PointerTensor point_to_attr
                     * @property {boolean|null} [garbage_collect_data] PointerTensor garbage_collect_data
                     */

                    /**
                     * Constructs a new PointerTensor.
                     * @memberof syft_proto.generic.pointers.v1
                     * @classdesc Represents a PointerTensor.
                     * @implements IPointerTensor
                     * @constructor
                     * @param {syft_proto.generic.pointers.v1.IPointerTensor=} [properties] Properties to set
                     */
                    function PointerTensor(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PointerTensor object_id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @instance
                     */
                    PointerTensor.prototype.object_id = null;

                    /**
                     * PointerTensor location_id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} location_id
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @instance
                     */
                    PointerTensor.prototype.location_id = null;

                    /**
                     * PointerTensor object_id_at_location.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id_at_location
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @instance
                     */
                    PointerTensor.prototype.object_id_at_location = null;

                    /**
                     * PointerTensor shape.
                     * @member {syft_proto.types.syft.v1.IShape|null|undefined} shape
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @instance
                     */
                    PointerTensor.prototype.shape = null;

                    /**
                     * PointerTensor point_to_attr.
                     * @member {string} point_to_attr
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @instance
                     */
                    PointerTensor.prototype.point_to_attr = "";

                    /**
                     * PointerTensor garbage_collect_data.
                     * @member {boolean} garbage_collect_data
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @instance
                     */
                    PointerTensor.prototype.garbage_collect_data = false;

                    /**
                     * Creates a new PointerTensor instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerTensor=} [properties] Properties to set
                     * @returns {syft_proto.generic.pointers.v1.PointerTensor} PointerTensor instance
                     */
                    PointerTensor.create = function create(properties) {
                        return new PointerTensor(properties);
                    };

                    /**
                     * Encodes the specified PointerTensor message. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerTensor.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerTensor} message PointerTensor message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PointerTensor.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.object_id != null && message.hasOwnProperty("object_id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.location_id != null && message.hasOwnProperty("location_id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.location_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.object_id_at_location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.shape != null && message.hasOwnProperty("shape"))
                            $root.syft_proto.types.syft.v1.Shape.encode(message.shape, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.point_to_attr);
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.garbage_collect_data);
                        return writer;
                    };

                    /**
                     * Encodes the specified PointerTensor message, length delimited. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerTensor.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerTensor} message PointerTensor message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PointerTensor.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PointerTensor message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.generic.pointers.v1.PointerTensor} PointerTensor
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PointerTensor.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.generic.pointers.v1.PointerTensor();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.location_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.shape = $root.syft_proto.types.syft.v1.Shape.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.point_to_attr = reader.string();
                                break;
                            case 6:
                                message.garbage_collect_data = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PointerTensor message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.generic.pointers.v1.PointerTensor} PointerTensor
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PointerTensor.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PointerTensor message.
                     * @function verify
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PointerTensor.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.object_id != null && message.hasOwnProperty("object_id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                            if (error)
                                return "object_id." + error;
                        }
                        if (message.location_id != null && message.hasOwnProperty("location_id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_id);
                            if (error)
                                return "location_id." + error;
                        }
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id_at_location);
                            if (error)
                                return "object_id_at_location." + error;
                        }
                        if (message.shape != null && message.hasOwnProperty("shape")) {
                            var error = $root.syft_proto.types.syft.v1.Shape.verify(message.shape);
                            if (error)
                                return "shape." + error;
                        }
                        if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                            if (!$util.isString(message.point_to_attr))
                                return "point_to_attr: string expected";
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            if (typeof message.garbage_collect_data !== "boolean")
                                return "garbage_collect_data: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a PointerTensor message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.generic.pointers.v1.PointerTensor} PointerTensor
                     */
                    PointerTensor.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.generic.pointers.v1.PointerTensor)
                            return object;
                        var message = new $root.syft_proto.generic.pointers.v1.PointerTensor();
                        if (object.object_id != null) {
                            if (typeof object.object_id !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerTensor.object_id: object expected");
                            message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                        }
                        if (object.location_id != null) {
                            if (typeof object.location_id !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerTensor.location_id: object expected");
                            message.location_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_id);
                        }
                        if (object.object_id_at_location != null) {
                            if (typeof object.object_id_at_location !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerTensor.object_id_at_location: object expected");
                            message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id_at_location);
                        }
                        if (object.shape != null) {
                            if (typeof object.shape !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerTensor.shape: object expected");
                            message.shape = $root.syft_proto.types.syft.v1.Shape.fromObject(object.shape);
                        }
                        if (object.point_to_attr != null)
                            message.point_to_attr = String(object.point_to_attr);
                        if (object.garbage_collect_data != null)
                            message.garbage_collect_data = Boolean(object.garbage_collect_data);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PointerTensor message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @static
                     * @param {syft_proto.generic.pointers.v1.PointerTensor} message PointerTensor
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PointerTensor.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.object_id = null;
                            object.location_id = null;
                            object.object_id_at_location = null;
                            object.shape = null;
                            object.point_to_attr = "";
                            object.garbage_collect_data = false;
                        }
                        if (message.object_id != null && message.hasOwnProperty("object_id"))
                            object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                        if (message.location_id != null && message.hasOwnProperty("location_id"))
                            object.location_id = $root.syft_proto.types.syft.v1.Id.toObject(message.location_id, options);
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                            object.object_id_at_location = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id_at_location, options);
                        if (message.shape != null && message.hasOwnProperty("shape"))
                            object.shape = $root.syft_proto.types.syft.v1.Shape.toObject(message.shape, options);
                        if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                            object.point_to_attr = message.point_to_attr;
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            object.garbage_collect_data = message.garbage_collect_data;
                        return object;
                    };

                    /**
                     * Converts this PointerTensor to JSON.
                     * @function toJSON
                     * @memberof syft_proto.generic.pointers.v1.PointerTensor
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PointerTensor.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return PointerTensor;
                })();

                v1.ObjectPointer = (function() {

                    /**
                     * Properties of an ObjectPointer.
                     * @memberof syft_proto.generic.pointers.v1
                     * @interface IObjectPointer
                     * @property {syft_proto.types.syft.v1.IId|null} [object_id] ObjectPointer object_id
                     * @property {syft_proto.types.syft.v1.IId|null} [location_id] ObjectPointer location_id
                     * @property {syft_proto.types.syft.v1.IId|null} [object_id_at_location] ObjectPointer object_id_at_location
                     * @property {string|null} [point_to_attr] ObjectPointer point_to_attr
                     */

                    /**
                     * Constructs a new ObjectPointer.
                     * @memberof syft_proto.generic.pointers.v1
                     * @classdesc Represents an ObjectPointer.
                     * @implements IObjectPointer
                     * @constructor
                     * @param {syft_proto.generic.pointers.v1.IObjectPointer=} [properties] Properties to set
                     */
                    function ObjectPointer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ObjectPointer object_id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @instance
                     */
                    ObjectPointer.prototype.object_id = null;

                    /**
                     * ObjectPointer location_id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} location_id
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @instance
                     */
                    ObjectPointer.prototype.location_id = null;

                    /**
                     * ObjectPointer object_id_at_location.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id_at_location
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @instance
                     */
                    ObjectPointer.prototype.object_id_at_location = null;

                    /**
                     * ObjectPointer point_to_attr.
                     * @member {string} point_to_attr
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @instance
                     */
                    ObjectPointer.prototype.point_to_attr = "";

                    /**
                     * Creates a new ObjectPointer instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IObjectPointer=} [properties] Properties to set
                     * @returns {syft_proto.generic.pointers.v1.ObjectPointer} ObjectPointer instance
                     */
                    ObjectPointer.create = function create(properties) {
                        return new ObjectPointer(properties);
                    };

                    /**
                     * Encodes the specified ObjectPointer message. Does not implicitly {@link syft_proto.generic.pointers.v1.ObjectPointer.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IObjectPointer} message ObjectPointer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ObjectPointer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.object_id != null && message.hasOwnProperty("object_id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.location_id != null && message.hasOwnProperty("location_id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.location_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.object_id_at_location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.point_to_attr);
                        return writer;
                    };

                    /**
                     * Encodes the specified ObjectPointer message, length delimited. Does not implicitly {@link syft_proto.generic.pointers.v1.ObjectPointer.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IObjectPointer} message ObjectPointer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ObjectPointer.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an ObjectPointer message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.generic.pointers.v1.ObjectPointer} ObjectPointer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ObjectPointer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.generic.pointers.v1.ObjectPointer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.location_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.point_to_attr = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an ObjectPointer message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.generic.pointers.v1.ObjectPointer} ObjectPointer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ObjectPointer.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an ObjectPointer message.
                     * @function verify
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ObjectPointer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.object_id != null && message.hasOwnProperty("object_id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                            if (error)
                                return "object_id." + error;
                        }
                        if (message.location_id != null && message.hasOwnProperty("location_id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_id);
                            if (error)
                                return "location_id." + error;
                        }
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id_at_location);
                            if (error)
                                return "object_id_at_location." + error;
                        }
                        if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                            if (!$util.isString(message.point_to_attr))
                                return "point_to_attr: string expected";
                        return null;
                    };

                    /**
                     * Creates an ObjectPointer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.generic.pointers.v1.ObjectPointer} ObjectPointer
                     */
                    ObjectPointer.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.generic.pointers.v1.ObjectPointer)
                            return object;
                        var message = new $root.syft_proto.generic.pointers.v1.ObjectPointer();
                        if (object.object_id != null) {
                            if (typeof object.object_id !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.ObjectPointer.object_id: object expected");
                            message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                        }
                        if (object.location_id != null) {
                            if (typeof object.location_id !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.ObjectPointer.location_id: object expected");
                            message.location_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_id);
                        }
                        if (object.object_id_at_location != null) {
                            if (typeof object.object_id_at_location !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.ObjectPointer.object_id_at_location: object expected");
                            message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id_at_location);
                        }
                        if (object.point_to_attr != null)
                            message.point_to_attr = String(object.point_to_attr);
                        return message;
                    };

                    /**
                     * Creates a plain object from an ObjectPointer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @static
                     * @param {syft_proto.generic.pointers.v1.ObjectPointer} message ObjectPointer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ObjectPointer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.object_id = null;
                            object.location_id = null;
                            object.object_id_at_location = null;
                            object.point_to_attr = "";
                        }
                        if (message.object_id != null && message.hasOwnProperty("object_id"))
                            object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                        if (message.location_id != null && message.hasOwnProperty("location_id"))
                            object.location_id = $root.syft_proto.types.syft.v1.Id.toObject(message.location_id, options);
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                            object.object_id_at_location = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id_at_location, options);
                        if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                            object.point_to_attr = message.point_to_attr;
                        return object;
                    };

                    /**
                     * Converts this ObjectPointer to JSON.
                     * @function toJSON
                     * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ObjectPointer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return ObjectPointer;
                })();

                v1.PointerDataset = (function() {

                    /**
                     * Properties of a PointerDataset.
                     * @memberof syft_proto.generic.pointers.v1
                     * @interface IPointerDataset
                     * @property {syft_proto.types.syft.v1.IId|null} [object_id] PointerDataset object_id
                     * @property {syft_proto.types.syft.v1.IId|null} [location_id] PointerDataset location_id
                     * @property {syft_proto.types.syft.v1.IId|null} [object_id_at_location] PointerDataset object_id_at_location
                     * @property {Array.<string>|null} [tags] PointerDataset tags
                     * @property {string|null} [description] PointerDataset description
                     * @property {boolean|null} [garbage_collect_data] PointerDataset garbage_collect_data
                     */

                    /**
                     * Constructs a new PointerDataset.
                     * @memberof syft_proto.generic.pointers.v1
                     * @classdesc Represents a PointerDataset.
                     * @implements IPointerDataset
                     * @constructor
                     * @param {syft_proto.generic.pointers.v1.IPointerDataset=} [properties] Properties to set
                     */
                    function PointerDataset(properties) {
                        this.tags = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PointerDataset object_id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @instance
                     */
                    PointerDataset.prototype.object_id = null;

                    /**
                     * PointerDataset location_id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} location_id
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @instance
                     */
                    PointerDataset.prototype.location_id = null;

                    /**
                     * PointerDataset object_id_at_location.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id_at_location
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @instance
                     */
                    PointerDataset.prototype.object_id_at_location = null;

                    /**
                     * PointerDataset tags.
                     * @member {Array.<string>} tags
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @instance
                     */
                    PointerDataset.prototype.tags = $util.emptyArray;

                    /**
                     * PointerDataset description.
                     * @member {string} description
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @instance
                     */
                    PointerDataset.prototype.description = "";

                    /**
                     * PointerDataset garbage_collect_data.
                     * @member {boolean} garbage_collect_data
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @instance
                     */
                    PointerDataset.prototype.garbage_collect_data = false;

                    /**
                     * Creates a new PointerDataset instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerDataset=} [properties] Properties to set
                     * @returns {syft_proto.generic.pointers.v1.PointerDataset} PointerDataset instance
                     */
                    PointerDataset.create = function create(properties) {
                        return new PointerDataset(properties);
                    };

                    /**
                     * Encodes the specified PointerDataset message. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerDataset.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerDataset} message PointerDataset message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PointerDataset.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.object_id != null && message.hasOwnProperty("object_id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.location_id != null && message.hasOwnProperty("location_id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.location_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.object_id_at_location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.tags != null && message.tags.length)
                            for (var i = 0; i < message.tags.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                        if (message.description != null && message.hasOwnProperty("description"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.garbage_collect_data);
                        return writer;
                    };

                    /**
                     * Encodes the specified PointerDataset message, length delimited. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerDataset.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerDataset} message PointerDataset message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PointerDataset.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PointerDataset message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.generic.pointers.v1.PointerDataset} PointerDataset
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PointerDataset.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.generic.pointers.v1.PointerDataset();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.location_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 4:
                                if (!(message.tags && message.tags.length))
                                    message.tags = [];
                                message.tags.push(reader.string());
                                break;
                            case 5:
                                message.description = reader.string();
                                break;
                            case 6:
                                message.garbage_collect_data = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PointerDataset message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.generic.pointers.v1.PointerDataset} PointerDataset
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PointerDataset.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PointerDataset message.
                     * @function verify
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PointerDataset.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.object_id != null && message.hasOwnProperty("object_id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                            if (error)
                                return "object_id." + error;
                        }
                        if (message.location_id != null && message.hasOwnProperty("location_id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_id);
                            if (error)
                                return "location_id." + error;
                        }
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id_at_location);
                            if (error)
                                return "object_id_at_location." + error;
                        }
                        if (message.tags != null && message.hasOwnProperty("tags")) {
                            if (!Array.isArray(message.tags))
                                return "tags: array expected";
                            for (var i = 0; i < message.tags.length; ++i)
                                if (!$util.isString(message.tags[i]))
                                    return "tags: string[] expected";
                        }
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            if (typeof message.garbage_collect_data !== "boolean")
                                return "garbage_collect_data: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a PointerDataset message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.generic.pointers.v1.PointerDataset} PointerDataset
                     */
                    PointerDataset.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.generic.pointers.v1.PointerDataset)
                            return object;
                        var message = new $root.syft_proto.generic.pointers.v1.PointerDataset();
                        if (object.object_id != null) {
                            if (typeof object.object_id !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerDataset.object_id: object expected");
                            message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                        }
                        if (object.location_id != null) {
                            if (typeof object.location_id !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerDataset.location_id: object expected");
                            message.location_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_id);
                        }
                        if (object.object_id_at_location != null) {
                            if (typeof object.object_id_at_location !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerDataset.object_id_at_location: object expected");
                            message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id_at_location);
                        }
                        if (object.tags) {
                            if (!Array.isArray(object.tags))
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerDataset.tags: array expected");
                            message.tags = [];
                            for (var i = 0; i < object.tags.length; ++i)
                                message.tags[i] = String(object.tags[i]);
                        }
                        if (object.description != null)
                            message.description = String(object.description);
                        if (object.garbage_collect_data != null)
                            message.garbage_collect_data = Boolean(object.garbage_collect_data);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PointerDataset message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @static
                     * @param {syft_proto.generic.pointers.v1.PointerDataset} message PointerDataset
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PointerDataset.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.tags = [];
                        if (options.defaults) {
                            object.object_id = null;
                            object.location_id = null;
                            object.object_id_at_location = null;
                            object.description = "";
                            object.garbage_collect_data = false;
                        }
                        if (message.object_id != null && message.hasOwnProperty("object_id"))
                            object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                        if (message.location_id != null && message.hasOwnProperty("location_id"))
                            object.location_id = $root.syft_proto.types.syft.v1.Id.toObject(message.location_id, options);
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                            object.object_id_at_location = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id_at_location, options);
                        if (message.tags && message.tags.length) {
                            object.tags = [];
                            for (var j = 0; j < message.tags.length; ++j)
                                object.tags[j] = message.tags[j];
                        }
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            object.garbage_collect_data = message.garbage_collect_data;
                        return object;
                    };

                    /**
                     * Converts this PointerDataset to JSON.
                     * @function toJSON
                     * @memberof syft_proto.generic.pointers.v1.PointerDataset
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PointerDataset.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return PointerDataset;
                })();

                v1.PointerPlan = (function() {

                    /**
                     * Properties of a PointerPlan.
                     * @memberof syft_proto.generic.pointers.v1
                     * @interface IPointerPlan
                     * @property {syft_proto.types.syft.v1.IId|null} [object_id] PointerPlan object_id
                     * @property {syft_proto.types.syft.v1.IId|null} [location_id] PointerPlan location_id
                     * @property {syft_proto.types.syft.v1.IId|null} [object_id_at_location] PointerPlan object_id_at_location
                     * @property {Array.<string>|null} [tags] PointerPlan tags
                     * @property {boolean|null} [garbage_collect_data] PointerPlan garbage_collect_data
                     */

                    /**
                     * Constructs a new PointerPlan.
                     * @memberof syft_proto.generic.pointers.v1
                     * @classdesc Represents a PointerPlan.
                     * @implements IPointerPlan
                     * @constructor
                     * @param {syft_proto.generic.pointers.v1.IPointerPlan=} [properties] Properties to set
                     */
                    function PointerPlan(properties) {
                        this.tags = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PointerPlan object_id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @instance
                     */
                    PointerPlan.prototype.object_id = null;

                    /**
                     * PointerPlan location_id.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} location_id
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @instance
                     */
                    PointerPlan.prototype.location_id = null;

                    /**
                     * PointerPlan object_id_at_location.
                     * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id_at_location
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @instance
                     */
                    PointerPlan.prototype.object_id_at_location = null;

                    /**
                     * PointerPlan tags.
                     * @member {Array.<string>} tags
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @instance
                     */
                    PointerPlan.prototype.tags = $util.emptyArray;

                    /**
                     * PointerPlan garbage_collect_data.
                     * @member {boolean} garbage_collect_data
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @instance
                     */
                    PointerPlan.prototype.garbage_collect_data = false;

                    /**
                     * Creates a new PointerPlan instance using the specified properties.
                     * @function create
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerPlan=} [properties] Properties to set
                     * @returns {syft_proto.generic.pointers.v1.PointerPlan} PointerPlan instance
                     */
                    PointerPlan.create = function create(properties) {
                        return new PointerPlan(properties);
                    };

                    /**
                     * Encodes the specified PointerPlan message. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerPlan.verify|verify} messages.
                     * @function encode
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerPlan} message PointerPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PointerPlan.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.object_id != null && message.hasOwnProperty("object_id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.location_id != null && message.hasOwnProperty("location_id"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.location_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                            $root.syft_proto.types.syft.v1.Id.encode(message.object_id_at_location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.tags != null && message.tags.length)
                            for (var i = 0; i < message.tags.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.garbage_collect_data);
                        return writer;
                    };

                    /**
                     * Encodes the specified PointerPlan message, length delimited. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerPlan.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @static
                     * @param {syft_proto.generic.pointers.v1.IPointerPlan} message PointerPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PointerPlan.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PointerPlan message from the specified reader or buffer.
                     * @function decode
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {syft_proto.generic.pointers.v1.PointerPlan} PointerPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PointerPlan.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.generic.pointers.v1.PointerPlan();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.location_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                break;
                            case 4:
                                if (!(message.tags && message.tags.length))
                                    message.tags = [];
                                message.tags.push(reader.string());
                                break;
                            case 5:
                                message.garbage_collect_data = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PointerPlan message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {syft_proto.generic.pointers.v1.PointerPlan} PointerPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PointerPlan.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PointerPlan message.
                     * @function verify
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PointerPlan.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.object_id != null && message.hasOwnProperty("object_id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                            if (error)
                                return "object_id." + error;
                        }
                        if (message.location_id != null && message.hasOwnProperty("location_id")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_id);
                            if (error)
                                return "location_id." + error;
                        }
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location")) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id_at_location);
                            if (error)
                                return "object_id_at_location." + error;
                        }
                        if (message.tags != null && message.hasOwnProperty("tags")) {
                            if (!Array.isArray(message.tags))
                                return "tags: array expected";
                            for (var i = 0; i < message.tags.length; ++i)
                                if (!$util.isString(message.tags[i]))
                                    return "tags: string[] expected";
                        }
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            if (typeof message.garbage_collect_data !== "boolean")
                                return "garbage_collect_data: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a PointerPlan message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {syft_proto.generic.pointers.v1.PointerPlan} PointerPlan
                     */
                    PointerPlan.fromObject = function fromObject(object) {
                        if (object instanceof $root.syft_proto.generic.pointers.v1.PointerPlan)
                            return object;
                        var message = new $root.syft_proto.generic.pointers.v1.PointerPlan();
                        if (object.object_id != null) {
                            if (typeof object.object_id !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerPlan.object_id: object expected");
                            message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                        }
                        if (object.location_id != null) {
                            if (typeof object.location_id !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerPlan.location_id: object expected");
                            message.location_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_id);
                        }
                        if (object.object_id_at_location != null) {
                            if (typeof object.object_id_at_location !== "object")
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerPlan.object_id_at_location: object expected");
                            message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id_at_location);
                        }
                        if (object.tags) {
                            if (!Array.isArray(object.tags))
                                throw TypeError(".syft_proto.generic.pointers.v1.PointerPlan.tags: array expected");
                            message.tags = [];
                            for (var i = 0; i < object.tags.length; ++i)
                                message.tags[i] = String(object.tags[i]);
                        }
                        if (object.garbage_collect_data != null)
                            message.garbage_collect_data = Boolean(object.garbage_collect_data);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PointerPlan message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @static
                     * @param {syft_proto.generic.pointers.v1.PointerPlan} message PointerPlan
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PointerPlan.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.tags = [];
                        if (options.defaults) {
                            object.object_id = null;
                            object.location_id = null;
                            object.object_id_at_location = null;
                            object.garbage_collect_data = false;
                        }
                        if (message.object_id != null && message.hasOwnProperty("object_id"))
                            object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                        if (message.location_id != null && message.hasOwnProperty("location_id"))
                            object.location_id = $root.syft_proto.types.syft.v1.Id.toObject(message.location_id, options);
                        if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                            object.object_id_at_location = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id_at_location, options);
                        if (message.tags && message.tags.length) {
                            object.tags = [];
                            for (var j = 0; j < message.tags.length; ++j)
                                object.tags[j] = message.tags[j];
                        }
                        if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                            object.garbage_collect_data = message.garbage_collect_data;
                        return object;
                    };

                    /**
                     * Converts this PointerPlan to JSON.
                     * @function toJSON
                     * @memberof syft_proto.generic.pointers.v1.PointerPlan
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PointerPlan.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                    };

                    return PointerPlan;
                })();

                return v1;
            })();

            return pointers;
        })();

        return generic;
    })();

    syft_proto.frameworks = (function() {

        /**
         * Namespace frameworks.
         * @memberof syft_proto
         * @namespace
         */
        var frameworks = {};

        frameworks.torch = (function() {

            /**
             * Namespace torch.
             * @memberof syft_proto.frameworks
             * @namespace
             */
            var torch = {};

            torch.fl = (function() {

                /**
                 * Namespace fl.
                 * @memberof syft_proto.frameworks.torch
                 * @namespace
                 */
                var fl = {};

                fl.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof syft_proto.frameworks.torch.fl
                     * @namespace
                     */
                    var v1 = {};

                    v1.BaseDataset = (function() {

                        /**
                         * Properties of a BaseDataset.
                         * @memberof syft_proto.frameworks.torch.fl.v1
                         * @interface IBaseDataset
                         * @property {syft_proto.types.torch.v1.ITorchTensor|null} [data] BaseDataset data
                         * @property {syft_proto.types.torch.v1.ITorchTensor|null} [targets] BaseDataset targets
                         * @property {syft_proto.types.syft.v1.IId|null} [id] BaseDataset id
                         * @property {Array.<string>|null} [tags] BaseDataset tags
                         * @property {string|null} [description] BaseDataset description
                         * @property {syft_proto.types.torch.v1.ITorchTensor|null} [child] BaseDataset child
                         */

                        /**
                         * Constructs a new BaseDataset.
                         * @memberof syft_proto.frameworks.torch.fl.v1
                         * @classdesc Represents a BaseDataset.
                         * @implements IBaseDataset
                         * @constructor
                         * @param {syft_proto.frameworks.torch.fl.v1.IBaseDataset=} [properties] Properties to set
                         */
                        function BaseDataset(properties) {
                            this.tags = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * BaseDataset data.
                         * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} data
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @instance
                         */
                        BaseDataset.prototype.data = null;

                        /**
                         * BaseDataset targets.
                         * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} targets
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @instance
                         */
                        BaseDataset.prototype.targets = null;

                        /**
                         * BaseDataset id.
                         * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @instance
                         */
                        BaseDataset.prototype.id = null;

                        /**
                         * BaseDataset tags.
                         * @member {Array.<string>} tags
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @instance
                         */
                        BaseDataset.prototype.tags = $util.emptyArray;

                        /**
                         * BaseDataset description.
                         * @member {string} description
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @instance
                         */
                        BaseDataset.prototype.description = "";

                        /**
                         * BaseDataset child.
                         * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} child
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @instance
                         */
                        BaseDataset.prototype.child = null;

                        /**
                         * Creates a new BaseDataset instance using the specified properties.
                         * @function create
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @static
                         * @param {syft_proto.frameworks.torch.fl.v1.IBaseDataset=} [properties] Properties to set
                         * @returns {syft_proto.frameworks.torch.fl.v1.BaseDataset} BaseDataset instance
                         */
                        BaseDataset.create = function create(properties) {
                            return new BaseDataset(properties);
                        };

                        /**
                         * Encodes the specified BaseDataset message. Does not implicitly {@link syft_proto.frameworks.torch.fl.v1.BaseDataset.verify|verify} messages.
                         * @function encode
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @static
                         * @param {syft_proto.frameworks.torch.fl.v1.IBaseDataset} message BaseDataset message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BaseDataset.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.data != null && message.hasOwnProperty("data"))
                                $root.syft_proto.types.torch.v1.TorchTensor.encode(message.data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.targets != null && message.hasOwnProperty("targets"))
                                $root.syft_proto.types.torch.v1.TorchTensor.encode(message.targets, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.id != null && message.hasOwnProperty("id"))
                                $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.tags != null && message.tags.length)
                                for (var i = 0; i < message.tags.length; ++i)
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                            if (message.child != null && message.hasOwnProperty("child"))
                                $root.syft_proto.types.torch.v1.TorchTensor.encode(message.child, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified BaseDataset message, length delimited. Does not implicitly {@link syft_proto.frameworks.torch.fl.v1.BaseDataset.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @static
                         * @param {syft_proto.frameworks.torch.fl.v1.IBaseDataset} message BaseDataset message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BaseDataset.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a BaseDataset message from the specified reader or buffer.
                         * @function decode
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {syft_proto.frameworks.torch.fl.v1.BaseDataset} BaseDataset
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BaseDataset.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.frameworks.torch.fl.v1.BaseDataset();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.data = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.targets = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                    break;
                                case 3:
                                    message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                    break;
                                case 4:
                                    if (!(message.tags && message.tags.length))
                                        message.tags = [];
                                    message.tags.push(reader.string());
                                    break;
                                case 5:
                                    message.description = reader.string();
                                    break;
                                case 6:
                                    message.child = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a BaseDataset message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {syft_proto.frameworks.torch.fl.v1.BaseDataset} BaseDataset
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BaseDataset.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a BaseDataset message.
                         * @function verify
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BaseDataset.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.data != null && message.hasOwnProperty("data")) {
                                var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.data);
                                if (error)
                                    return "data." + error;
                            }
                            if (message.targets != null && message.hasOwnProperty("targets")) {
                                var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.targets);
                                if (error)
                                    return "targets." + error;
                            }
                            if (message.id != null && message.hasOwnProperty("id")) {
                                var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                                if (error)
                                    return "id." + error;
                            }
                            if (message.tags != null && message.hasOwnProperty("tags")) {
                                if (!Array.isArray(message.tags))
                                    return "tags: array expected";
                                for (var i = 0; i < message.tags.length; ++i)
                                    if (!$util.isString(message.tags[i]))
                                        return "tags: string[] expected";
                            }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            if (message.child != null && message.hasOwnProperty("child")) {
                                var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.child);
                                if (error)
                                    return "child." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a BaseDataset message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {syft_proto.frameworks.torch.fl.v1.BaseDataset} BaseDataset
                         */
                        BaseDataset.fromObject = function fromObject(object) {
                            if (object instanceof $root.syft_proto.frameworks.torch.fl.v1.BaseDataset)
                                return object;
                            var message = new $root.syft_proto.frameworks.torch.fl.v1.BaseDataset();
                            if (object.data != null) {
                                if (typeof object.data !== "object")
                                    throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.data: object expected");
                                message.data = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.data);
                            }
                            if (object.targets != null) {
                                if (typeof object.targets !== "object")
                                    throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.targets: object expected");
                                message.targets = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.targets);
                            }
                            if (object.id != null) {
                                if (typeof object.id !== "object")
                                    throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.id: object expected");
                                message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                            }
                            if (object.tags) {
                                if (!Array.isArray(object.tags))
                                    throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.tags: array expected");
                                message.tags = [];
                                for (var i = 0; i < object.tags.length; ++i)
                                    message.tags[i] = String(object.tags[i]);
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            if (object.child != null) {
                                if (typeof object.child !== "object")
                                    throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.child: object expected");
                                message.child = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.child);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a BaseDataset message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @static
                         * @param {syft_proto.frameworks.torch.fl.v1.BaseDataset} message BaseDataset
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BaseDataset.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.tags = [];
                            if (options.defaults) {
                                object.data = null;
                                object.targets = null;
                                object.id = null;
                                object.description = "";
                                object.child = null;
                            }
                            if (message.data != null && message.hasOwnProperty("data"))
                                object.data = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.data, options);
                            if (message.targets != null && message.hasOwnProperty("targets"))
                                object.targets = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.targets, options);
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                            if (message.tags && message.tags.length) {
                                object.tags = [];
                                for (var j = 0; j < message.tags.length; ++j)
                                    object.tags[j] = message.tags[j];
                            }
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            if (message.child != null && message.hasOwnProperty("child"))
                                object.child = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.child, options);
                            return object;
                        };

                        /**
                         * Converts this BaseDataset to JSON.
                         * @function toJSON
                         * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BaseDataset.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                        };

                        return BaseDataset;
                    })();

                    return v1;
                })();

                return fl;
            })();

            torch.tensors = (function() {

                /**
                 * Namespace tensors.
                 * @memberof syft_proto.frameworks.torch
                 * @namespace
                 */
                var tensors = {};

                tensors.interpreters = (function() {

                    /**
                     * Namespace interpreters.
                     * @memberof syft_proto.frameworks.torch.tensors
                     * @namespace
                     */
                    var interpreters = {};

                    interpreters.v1 = (function() {

                        /**
                         * Namespace v1.
                         * @memberof syft_proto.frameworks.torch.tensors.interpreters
                         * @namespace
                         */
                        var v1 = {};

                        v1.AdditiveSharingTensor = (function() {

                            /**
                             * Properties of an AdditiveSharingTensor.
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1
                             * @interface IAdditiveSharingTensor
                             * @property {syft_proto.types.syft.v1.IId|null} [id] AdditiveSharingTensor id
                             * @property {number|Long|null} [field_int] AdditiveSharingTensor field_int
                             * @property {string|null} [field_str] AdditiveSharingTensor field_str
                             * @property {string|null} [dtype] AdditiveSharingTensor dtype
                             * @property {syft_proto.types.syft.v1.IId|null} [crypto_provider_id] AdditiveSharingTensor crypto_provider_id
                             * @property {Array.<syft_proto.types.syft.v1.IId>|null} [location_ids] AdditiveSharingTensor location_ids
                             * @property {Array.<syft_proto.generic.pointers.v1.IPointerTensor>|null} [shares] AdditiveSharingTensor shares
                             */

                            /**
                             * Constructs a new AdditiveSharingTensor.
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1
                             * @classdesc Represents an AdditiveSharingTensor.
                             * @implements IAdditiveSharingTensor
                             * @constructor
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor=} [properties] Properties to set
                             */
                            function AdditiveSharingTensor(properties) {
                                this.location_ids = [];
                                this.shares = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * AdditiveSharingTensor id.
                             * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             */
                            AdditiveSharingTensor.prototype.id = null;

                            /**
                             * AdditiveSharingTensor field_int.
                             * @member {number|Long} field_int
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             */
                            AdditiveSharingTensor.prototype.field_int = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                            /**
                             * AdditiveSharingTensor field_str.
                             * @member {string} field_str
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             */
                            AdditiveSharingTensor.prototype.field_str = "";

                            /**
                             * AdditiveSharingTensor dtype.
                             * @member {string} dtype
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             */
                            AdditiveSharingTensor.prototype.dtype = "";

                            /**
                             * AdditiveSharingTensor crypto_provider_id.
                             * @member {syft_proto.types.syft.v1.IId|null|undefined} crypto_provider_id
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             */
                            AdditiveSharingTensor.prototype.crypto_provider_id = null;

                            /**
                             * AdditiveSharingTensor location_ids.
                             * @member {Array.<syft_proto.types.syft.v1.IId>} location_ids
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             */
                            AdditiveSharingTensor.prototype.location_ids = $util.emptyArray;

                            /**
                             * AdditiveSharingTensor shares.
                             * @member {Array.<syft_proto.generic.pointers.v1.IPointerTensor>} shares
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             */
                            AdditiveSharingTensor.prototype.shares = $util.emptyArray;

                            // OneOf field names bound to virtual getters and setters
                            var $oneOfFields;

                            /**
                             * AdditiveSharingTensor field_size.
                             * @member {"field_int"|"field_str"|undefined} field_size
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             */
                            Object.defineProperty(AdditiveSharingTensor.prototype, "field_size", {
                                get: $util.oneOfGetter($oneOfFields = ["field_int", "field_str"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Creates a new AdditiveSharingTensor instance using the specified properties.
                             * @function create
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @static
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor=} [properties] Properties to set
                             * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} AdditiveSharingTensor instance
                             */
                            AdditiveSharingTensor.create = function create(properties) {
                                return new AdditiveSharingTensor(properties);
                            };

                            /**
                             * Encodes the specified AdditiveSharingTensor message. Does not implicitly {@link syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.verify|verify} messages.
                             * @function encode
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @static
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor} message AdditiveSharingTensor message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            AdditiveSharingTensor.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.id != null && message.hasOwnProperty("id"))
                                    $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.field_int != null && message.hasOwnProperty("field_int"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.field_int);
                                if (message.field_str != null && message.hasOwnProperty("field_str"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.field_str);
                                if (message.dtype != null && message.hasOwnProperty("dtype"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.dtype);
                                if (message.crypto_provider_id != null && message.hasOwnProperty("crypto_provider_id"))
                                    $root.syft_proto.types.syft.v1.Id.encode(message.crypto_provider_id, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                                if (message.location_ids != null && message.location_ids.length)
                                    for (var i = 0; i < message.location_ids.length; ++i)
                                        $root.syft_proto.types.syft.v1.Id.encode(message.location_ids[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                                if (message.shares != null && message.shares.length)
                                    for (var i = 0; i < message.shares.length; ++i)
                                        $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.shares[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified AdditiveSharingTensor message, length delimited. Does not implicitly {@link syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @static
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor} message AdditiveSharingTensor message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            AdditiveSharingTensor.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an AdditiveSharingTensor message from the specified reader or buffer.
                             * @function decode
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} AdditiveSharingTensor
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            AdditiveSharingTensor.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.field_int = reader.int64();
                                        break;
                                    case 3:
                                        message.field_str = reader.string();
                                        break;
                                    case 4:
                                        message.dtype = reader.string();
                                        break;
                                    case 5:
                                        message.crypto_provider_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                        break;
                                    case 6:
                                        if (!(message.location_ids && message.location_ids.length))
                                            message.location_ids = [];
                                        message.location_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                                        break;
                                    case 7:
                                        if (!(message.shares && message.shares.length))
                                            message.shares = [];
                                        message.shares.push($root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an AdditiveSharingTensor message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} AdditiveSharingTensor
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            AdditiveSharingTensor.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an AdditiveSharingTensor message.
                             * @function verify
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            AdditiveSharingTensor.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                var properties = {};
                                if (message.id != null && message.hasOwnProperty("id")) {
                                    var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                                    if (error)
                                        return "id." + error;
                                }
                                if (message.field_int != null && message.hasOwnProperty("field_int")) {
                                    properties.field_size = 1;
                                    if (!$util.isInteger(message.field_int) && !(message.field_int && $util.isInteger(message.field_int.low) && $util.isInteger(message.field_int.high)))
                                        return "field_int: integer|Long expected";
                                }
                                if (message.field_str != null && message.hasOwnProperty("field_str")) {
                                    if (properties.field_size === 1)
                                        return "field_size: multiple values";
                                    properties.field_size = 1;
                                    if (!$util.isString(message.field_str))
                                        return "field_str: string expected";
                                }
                                if (message.dtype != null && message.hasOwnProperty("dtype"))
                                    if (!$util.isString(message.dtype))
                                        return "dtype: string expected";
                                if (message.crypto_provider_id != null && message.hasOwnProperty("crypto_provider_id")) {
                                    var error = $root.syft_proto.types.syft.v1.Id.verify(message.crypto_provider_id);
                                    if (error)
                                        return "crypto_provider_id." + error;
                                }
                                if (message.location_ids != null && message.hasOwnProperty("location_ids")) {
                                    if (!Array.isArray(message.location_ids))
                                        return "location_ids: array expected";
                                    for (var i = 0; i < message.location_ids.length; ++i) {
                                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_ids[i]);
                                        if (error)
                                            return "location_ids." + error;
                                    }
                                }
                                if (message.shares != null && message.hasOwnProperty("shares")) {
                                    if (!Array.isArray(message.shares))
                                        return "shares: array expected";
                                    for (var i = 0; i < message.shares.length; ++i) {
                                        var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.shares[i]);
                                        if (error)
                                            return "shares." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates an AdditiveSharingTensor message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} AdditiveSharingTensor
                             */
                            AdditiveSharingTensor.fromObject = function fromObject(object) {
                                if (object instanceof $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor)
                                    return object;
                                var message = new $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor();
                                if (object.id != null) {
                                    if (typeof object.id !== "object")
                                        throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.id: object expected");
                                    message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                                }
                                if (object.field_int != null)
                                    if ($util.Long)
                                        (message.field_int = $util.Long.fromValue(object.field_int)).unsigned = false;
                                    else if (typeof object.field_int === "string")
                                        message.field_int = parseInt(object.field_int, 10);
                                    else if (typeof object.field_int === "number")
                                        message.field_int = object.field_int;
                                    else if (typeof object.field_int === "object")
                                        message.field_int = new $util.LongBits(object.field_int.low >>> 0, object.field_int.high >>> 0).toNumber();
                                if (object.field_str != null)
                                    message.field_str = String(object.field_str);
                                if (object.dtype != null)
                                    message.dtype = String(object.dtype);
                                if (object.crypto_provider_id != null) {
                                    if (typeof object.crypto_provider_id !== "object")
                                        throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.crypto_provider_id: object expected");
                                    message.crypto_provider_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.crypto_provider_id);
                                }
                                if (object.location_ids) {
                                    if (!Array.isArray(object.location_ids))
                                        throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.location_ids: array expected");
                                    message.location_ids = [];
                                    for (var i = 0; i < object.location_ids.length; ++i) {
                                        if (typeof object.location_ids[i] !== "object")
                                            throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.location_ids: object expected");
                                        message.location_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_ids[i]);
                                    }
                                }
                                if (object.shares) {
                                    if (!Array.isArray(object.shares))
                                        throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.shares: array expected");
                                    message.shares = [];
                                    for (var i = 0; i < object.shares.length; ++i) {
                                        if (typeof object.shares[i] !== "object")
                                            throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.shares: object expected");
                                        message.shares[i] = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.shares[i]);
                                    }
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from an AdditiveSharingTensor message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @static
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} message AdditiveSharingTensor
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            AdditiveSharingTensor.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults) {
                                    object.location_ids = [];
                                    object.shares = [];
                                }
                                if (options.defaults) {
                                    object.id = null;
                                    object.dtype = "";
                                    object.crypto_provider_id = null;
                                }
                                if (message.id != null && message.hasOwnProperty("id"))
                                    object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                                if (message.field_int != null && message.hasOwnProperty("field_int")) {
                                    if (typeof message.field_int === "number")
                                        object.field_int = options.longs === String ? String(message.field_int) : message.field_int;
                                    else
                                        object.field_int = options.longs === String ? $util.Long.prototype.toString.call(message.field_int) : options.longs === Number ? new $util.LongBits(message.field_int.low >>> 0, message.field_int.high >>> 0).toNumber() : message.field_int;
                                    if (options.oneofs)
                                        object.field_size = "field_int";
                                }
                                if (message.field_str != null && message.hasOwnProperty("field_str")) {
                                    object.field_str = message.field_str;
                                    if (options.oneofs)
                                        object.field_size = "field_str";
                                }
                                if (message.dtype != null && message.hasOwnProperty("dtype"))
                                    object.dtype = message.dtype;
                                if (message.crypto_provider_id != null && message.hasOwnProperty("crypto_provider_id"))
                                    object.crypto_provider_id = $root.syft_proto.types.syft.v1.Id.toObject(message.crypto_provider_id, options);
                                if (message.location_ids && message.location_ids.length) {
                                    object.location_ids = [];
                                    for (var j = 0; j < message.location_ids.length; ++j)
                                        object.location_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.location_ids[j], options);
                                }
                                if (message.shares && message.shares.length) {
                                    object.shares = [];
                                    for (var j = 0; j < message.shares.length; ++j)
                                        object.shares[j] = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.shares[j], options);
                                }
                                return object;
                            };

                            /**
                             * Converts this AdditiveSharingTensor to JSON.
                             * @function toJSON
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            AdditiveSharingTensor.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                            };

                            return AdditiveSharingTensor;
                        })();

                        v1.FixedPrecisionTensor = (function() {

                            /**
                             * Properties of a FixedPrecisionTensor.
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1
                             * @interface IFixedPrecisionTensor
                             * @property {syft_proto.types.syft.v1.IId|null} [id] FixedPrecisionTensor id
                             * @property {string|null} [field] FixedPrecisionTensor field
                             * @property {string|null} [dtype] FixedPrecisionTensor dtype
                             * @property {number|null} [base] FixedPrecisionTensor base
                             * @property {number|null} [kappa] FixedPrecisionTensor kappa
                             * @property {number|null} [precision_fractional] FixedPrecisionTensor precision_fractional
                             * @property {Array.<string>|null} [tags] FixedPrecisionTensor tags
                             * @property {string|null} [description] FixedPrecisionTensor description
                             * @property {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor|null} [child] FixedPrecisionTensor child
                             */

                            /**
                             * Constructs a new FixedPrecisionTensor.
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1
                             * @classdesc Represents a FixedPrecisionTensor.
                             * @implements IFixedPrecisionTensor
                             * @constructor
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IFixedPrecisionTensor=} [properties] Properties to set
                             */
                            function FixedPrecisionTensor(properties) {
                                this.tags = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * FixedPrecisionTensor id.
                             * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.id = null;

                            /**
                             * FixedPrecisionTensor field.
                             * @member {string} field
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.field = "";

                            /**
                             * FixedPrecisionTensor dtype.
                             * @member {string} dtype
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.dtype = "";

                            /**
                             * FixedPrecisionTensor base.
                             * @member {number} base
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.base = 0;

                            /**
                             * FixedPrecisionTensor kappa.
                             * @member {number} kappa
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.kappa = 0;

                            /**
                             * FixedPrecisionTensor precision_fractional.
                             * @member {number} precision_fractional
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.precision_fractional = 0;

                            /**
                             * FixedPrecisionTensor tags.
                             * @member {Array.<string>} tags
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.tags = $util.emptyArray;

                            /**
                             * FixedPrecisionTensor description.
                             * @member {string} description
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.description = "";

                            /**
                             * FixedPrecisionTensor child.
                             * @member {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor|null|undefined} child
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             */
                            FixedPrecisionTensor.prototype.child = null;

                            /**
                             * Creates a new FixedPrecisionTensor instance using the specified properties.
                             * @function create
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @static
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IFixedPrecisionTensor=} [properties] Properties to set
                             * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} FixedPrecisionTensor instance
                             */
                            FixedPrecisionTensor.create = function create(properties) {
                                return new FixedPrecisionTensor(properties);
                            };

                            /**
                             * Encodes the specified FixedPrecisionTensor message. Does not implicitly {@link syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.verify|verify} messages.
                             * @function encode
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @static
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IFixedPrecisionTensor} message FixedPrecisionTensor message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            FixedPrecisionTensor.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.id != null && message.hasOwnProperty("id"))
                                    $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.field != null && message.hasOwnProperty("field"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.field);
                                if (message.dtype != null && message.hasOwnProperty("dtype"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.dtype);
                                if (message.base != null && message.hasOwnProperty("base"))
                                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.base);
                                if (message.kappa != null && message.hasOwnProperty("kappa"))
                                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.kappa);
                                if (message.precision_fractional != null && message.hasOwnProperty("precision_fractional"))
                                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.precision_fractional);
                                if (message.tags != null && message.tags.length)
                                    for (var i = 0; i < message.tags.length; ++i)
                                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.tags[i]);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.description);
                                if (message.child != null && message.hasOwnProperty("child"))
                                    $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.encode(message.child, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified FixedPrecisionTensor message, length delimited. Does not implicitly {@link syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @static
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IFixedPrecisionTensor} message FixedPrecisionTensor message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            FixedPrecisionTensor.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a FixedPrecisionTensor message from the specified reader or buffer.
                             * @function decode
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} FixedPrecisionTensor
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            FixedPrecisionTensor.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                        break;
                                    case 3:
                                        message.field = reader.string();
                                        break;
                                    case 4:
                                        message.dtype = reader.string();
                                        break;
                                    case 5:
                                        message.base = reader.int32();
                                        break;
                                    case 6:
                                        message.kappa = reader.int32();
                                        break;
                                    case 7:
                                        message.precision_fractional = reader.int32();
                                        break;
                                    case 8:
                                        if (!(message.tags && message.tags.length))
                                            message.tags = [];
                                        message.tags.push(reader.string());
                                        break;
                                    case 9:
                                        message.description = reader.string();
                                        break;
                                    case 10:
                                        message.child = $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a FixedPrecisionTensor message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} FixedPrecisionTensor
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            FixedPrecisionTensor.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a FixedPrecisionTensor message.
                             * @function verify
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            FixedPrecisionTensor.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.id != null && message.hasOwnProperty("id")) {
                                    var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                                    if (error)
                                        return "id." + error;
                                }
                                if (message.field != null && message.hasOwnProperty("field"))
                                    if (!$util.isString(message.field))
                                        return "field: string expected";
                                if (message.dtype != null && message.hasOwnProperty("dtype"))
                                    if (!$util.isString(message.dtype))
                                        return "dtype: string expected";
                                if (message.base != null && message.hasOwnProperty("base"))
                                    if (!$util.isInteger(message.base))
                                        return "base: integer expected";
                                if (message.kappa != null && message.hasOwnProperty("kappa"))
                                    if (!$util.isInteger(message.kappa))
                                        return "kappa: integer expected";
                                if (message.precision_fractional != null && message.hasOwnProperty("precision_fractional"))
                                    if (!$util.isInteger(message.precision_fractional))
                                        return "precision_fractional: integer expected";
                                if (message.tags != null && message.hasOwnProperty("tags")) {
                                    if (!Array.isArray(message.tags))
                                        return "tags: array expected";
                                    for (var i = 0; i < message.tags.length; ++i)
                                        if (!$util.isString(message.tags[i]))
                                            return "tags: string[] expected";
                                }
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                if (message.child != null && message.hasOwnProperty("child")) {
                                    var error = $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.verify(message.child);
                                    if (error)
                                        return "child." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a FixedPrecisionTensor message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} FixedPrecisionTensor
                             */
                            FixedPrecisionTensor.fromObject = function fromObject(object) {
                                if (object instanceof $root.syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor)
                                    return object;
                                var message = new $root.syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor();
                                if (object.id != null) {
                                    if (typeof object.id !== "object")
                                        throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.id: object expected");
                                    message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                                }
                                if (object.field != null)
                                    message.field = String(object.field);
                                if (object.dtype != null)
                                    message.dtype = String(object.dtype);
                                if (object.base != null)
                                    message.base = object.base | 0;
                                if (object.kappa != null)
                                    message.kappa = object.kappa | 0;
                                if (object.precision_fractional != null)
                                    message.precision_fractional = object.precision_fractional | 0;
                                if (object.tags) {
                                    if (!Array.isArray(object.tags))
                                        throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.tags: array expected");
                                    message.tags = [];
                                    for (var i = 0; i < object.tags.length; ++i)
                                        message.tags[i] = String(object.tags[i]);
                                }
                                if (object.description != null)
                                    message.description = String(object.description);
                                if (object.child != null) {
                                    if (typeof object.child !== "object")
                                        throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.child: object expected");
                                    message.child = $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.fromObject(object.child);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a FixedPrecisionTensor message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @static
                             * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} message FixedPrecisionTensor
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            FixedPrecisionTensor.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults)
                                    object.tags = [];
                                if (options.defaults) {
                                    object.id = null;
                                    object.field = "";
                                    object.dtype = "";
                                    object.base = 0;
                                    object.kappa = 0;
                                    object.precision_fractional = 0;
                                    object.description = "";
                                    object.child = null;
                                }
                                if (message.id != null && message.hasOwnProperty("id"))
                                    object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                                if (message.field != null && message.hasOwnProperty("field"))
                                    object.field = message.field;
                                if (message.dtype != null && message.hasOwnProperty("dtype"))
                                    object.dtype = message.dtype;
                                if (message.base != null && message.hasOwnProperty("base"))
                                    object.base = message.base;
                                if (message.kappa != null && message.hasOwnProperty("kappa"))
                                    object.kappa = message.kappa;
                                if (message.precision_fractional != null && message.hasOwnProperty("precision_fractional"))
                                    object.precision_fractional = message.precision_fractional;
                                if (message.tags && message.tags.length) {
                                    object.tags = [];
                                    for (var j = 0; j < message.tags.length; ++j)
                                        object.tags[j] = message.tags[j];
                                }
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                if (message.child != null && message.hasOwnProperty("child"))
                                    object.child = $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.toObject(message.child, options);
                                return object;
                            };

                            /**
                             * Converts this FixedPrecisionTensor to JSON.
                             * @function toJSON
                             * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            FixedPrecisionTensor.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                            };

                            return FixedPrecisionTensor;
                        })();

                        return v1;
                    })();

                    return interpreters;
                })();

                return tensors;
            })();

            return torch;
        })();

        return frameworks;
    })();

    syft_proto.messaging = (function() {

        /**
         * Namespace messaging.
         * @memberof syft_proto
         * @namespace
         */
        var messaging = {};

        messaging.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof syft_proto.messaging
             * @namespace
             */
            var v1 = {};

            v1.String = (function() {

                /**
                 * Properties of a String.
                 * @memberof syft_proto.messaging.v1
                 * @interface IString
                 * @property {string|null} [child] String child
                 * @property {Array.<string>|null} [tags] String tags
                 * @property {string|null} [description] String description
                 */

                /**
                 * Constructs a new String.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents a String.
                 * @implements IString
                 * @constructor
                 * @param {syft_proto.messaging.v1.IString=} [properties] Properties to set
                 */
                function String(properties) {
                    this.tags = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * String child.
                 * @member {string} child
                 * @memberof syft_proto.messaging.v1.String
                 * @instance
                 */
                String.prototype.child = "";

                /**
                 * String tags.
                 * @member {Array.<string>} tags
                 * @memberof syft_proto.messaging.v1.String
                 * @instance
                 */
                String.prototype.tags = $util.emptyArray;

                /**
                 * String description.
                 * @member {string} description
                 * @memberof syft_proto.messaging.v1.String
                 * @instance
                 */
                String.prototype.description = "";

                /**
                 * Creates a new String instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.String
                 * @static
                 * @param {syft_proto.messaging.v1.IString=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.String} String instance
                 */
                String.create = function create(properties) {
                    return new String(properties);
                };

                /**
                 * Encodes the specified String message. Does not implicitly {@link syft_proto.messaging.v1.String.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.String
                 * @static
                 * @param {syft_proto.messaging.v1.IString} message String message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                String.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.child != null && message.hasOwnProperty("child"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.child);
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.tags[i]);
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                    return writer;
                };

                /**
                 * Encodes the specified String message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.String.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.String
                 * @static
                 * @param {syft_proto.messaging.v1.IString} message String message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                String.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a String message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.String
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.String} String
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                String.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.String();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.child = reader.string();
                            break;
                        case 2:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        case 3:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a String message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.String
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.String} String
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                String.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a String message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.String
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                String.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.child != null && message.hasOwnProperty("child"))
                        if (!$util.isString(message.child))
                            return "child: string expected";
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };

                /**
                 * Creates a String message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.String
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.String} String
                 */
                String.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.String)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.String();
                    if (object.child != null)
                        message.child = String(object.child);
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".syft_proto.messaging.v1.String.tags: array expected");
                        message.tags = [];
                        for (var i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };

                /**
                 * Creates a plain object from a String message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.String
                 * @static
                 * @param {syft_proto.messaging.v1.String} message String
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                String.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.tags = [];
                    if (options.defaults) {
                        object.child = "";
                        object.description = "";
                    }
                    if (message.child != null && message.hasOwnProperty("child"))
                        object.child = message.child;
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (var j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };

                /**
                 * Converts this String to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.String
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                String.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return String;
            })();

            v1.SyftMessage = (function() {

                /**
                 * Properties of a SyftMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface ISyftMessage
                 * @property {google.protobuf.IEmpty|null} [contents_empty_msg] SyftMessage contents_empty_msg
                 * @property {syft_proto.messaging.v1.IForceObjectDeleteMessage|null} [contents_delete_msg] SyftMessage contents_delete_msg
                 * @property {syft_proto.messaging.v1.IGetShapeMessage|null} [contents_get_shape_msg] SyftMessage contents_get_shape_msg
                 * @property {syft_proto.messaging.v1.IIsNoneMessage|null} [contents_is_none_msg] SyftMessage contents_is_none_msg
                 * @property {syft_proto.messaging.v1.IObjectMessage|null} [contents_object_msg] SyftMessage contents_object_msg
                 * @property {syft_proto.messaging.v1.IObjectRequestMessage|null} [contents_object_request_msg] SyftMessage contents_object_request_msg
                 * @property {syft_proto.messaging.v1.ITensorCommandMessage|null} [contents_tensor_cmd_msg] SyftMessage contents_tensor_cmd_msg
                 * @property {syft_proto.messaging.v1.IPlanCommandMessage|null} [contents_plan_cmd_msg] SyftMessage contents_plan_cmd_msg
                 * @property {syft_proto.messaging.v1.IWorkerCommandMessage|null} [contents_worker_cmd_msg] SyftMessage contents_worker_cmd_msg
                 * @property {syft_proto.messaging.v1.ISearchMessage|null} [contents_search_msg] SyftMessage contents_search_msg
                 */

                /**
                 * Constructs a new SyftMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents a SyftMessage.
                 * @implements ISyftMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.ISyftMessage=} [properties] Properties to set
                 */
                function SyftMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SyftMessage contents_empty_msg.
                 * @member {google.protobuf.IEmpty|null|undefined} contents_empty_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_empty_msg = null;

                /**
                 * SyftMessage contents_delete_msg.
                 * @member {syft_proto.messaging.v1.IForceObjectDeleteMessage|null|undefined} contents_delete_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_delete_msg = null;

                /**
                 * SyftMessage contents_get_shape_msg.
                 * @member {syft_proto.messaging.v1.IGetShapeMessage|null|undefined} contents_get_shape_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_get_shape_msg = null;

                /**
                 * SyftMessage contents_is_none_msg.
                 * @member {syft_proto.messaging.v1.IIsNoneMessage|null|undefined} contents_is_none_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_is_none_msg = null;

                /**
                 * SyftMessage contents_object_msg.
                 * @member {syft_proto.messaging.v1.IObjectMessage|null|undefined} contents_object_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_object_msg = null;

                /**
                 * SyftMessage contents_object_request_msg.
                 * @member {syft_proto.messaging.v1.IObjectRequestMessage|null|undefined} contents_object_request_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_object_request_msg = null;

                /**
                 * SyftMessage contents_tensor_cmd_msg.
                 * @member {syft_proto.messaging.v1.ITensorCommandMessage|null|undefined} contents_tensor_cmd_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_tensor_cmd_msg = null;

                /**
                 * SyftMessage contents_plan_cmd_msg.
                 * @member {syft_proto.messaging.v1.IPlanCommandMessage|null|undefined} contents_plan_cmd_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_plan_cmd_msg = null;

                /**
                 * SyftMessage contents_worker_cmd_msg.
                 * @member {syft_proto.messaging.v1.IWorkerCommandMessage|null|undefined} contents_worker_cmd_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_worker_cmd_msg = null;

                /**
                 * SyftMessage contents_search_msg.
                 * @member {syft_proto.messaging.v1.ISearchMessage|null|undefined} contents_search_msg
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                SyftMessage.prototype.contents_search_msg = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * SyftMessage contents.
                 * @member {"contents_empty_msg"|"contents_delete_msg"|"contents_get_shape_msg"|"contents_is_none_msg"|"contents_object_msg"|"contents_object_request_msg"|"contents_tensor_cmd_msg"|"contents_plan_cmd_msg"|"contents_worker_cmd_msg"|"contents_search_msg"|undefined} contents
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 */
                Object.defineProperty(SyftMessage.prototype, "contents", {
                    get: $util.oneOfGetter($oneOfFields = ["contents_empty_msg", "contents_delete_msg", "contents_get_shape_msg", "contents_is_none_msg", "contents_object_msg", "contents_object_request_msg", "contents_tensor_cmd_msg", "contents_plan_cmd_msg", "contents_worker_cmd_msg", "contents_search_msg"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new SyftMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ISyftMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.SyftMessage} SyftMessage instance
                 */
                SyftMessage.create = function create(properties) {
                    return new SyftMessage(properties);
                };

                /**
                 * Encodes the specified SyftMessage message. Does not implicitly {@link syft_proto.messaging.v1.SyftMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ISyftMessage} message SyftMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SyftMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contents_empty_msg != null && message.hasOwnProperty("contents_empty_msg"))
                        $root.google.protobuf.Empty.encode(message.contents_empty_msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.contents_delete_msg != null && message.hasOwnProperty("contents_delete_msg"))
                        $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.encode(message.contents_delete_msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.contents_get_shape_msg != null && message.hasOwnProperty("contents_get_shape_msg"))
                        $root.syft_proto.messaging.v1.GetShapeMessage.encode(message.contents_get_shape_msg, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.contents_is_none_msg != null && message.hasOwnProperty("contents_is_none_msg"))
                        $root.syft_proto.messaging.v1.IsNoneMessage.encode(message.contents_is_none_msg, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.contents_object_msg != null && message.hasOwnProperty("contents_object_msg"))
                        $root.syft_proto.messaging.v1.ObjectMessage.encode(message.contents_object_msg, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.contents_object_request_msg != null && message.hasOwnProperty("contents_object_request_msg"))
                        $root.syft_proto.messaging.v1.ObjectRequestMessage.encode(message.contents_object_request_msg, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.contents_tensor_cmd_msg != null && message.hasOwnProperty("contents_tensor_cmd_msg"))
                        $root.syft_proto.messaging.v1.TensorCommandMessage.encode(message.contents_tensor_cmd_msg, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.contents_plan_cmd_msg != null && message.hasOwnProperty("contents_plan_cmd_msg"))
                        $root.syft_proto.messaging.v1.PlanCommandMessage.encode(message.contents_plan_cmd_msg, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.contents_worker_cmd_msg != null && message.hasOwnProperty("contents_worker_cmd_msg"))
                        $root.syft_proto.messaging.v1.WorkerCommandMessage.encode(message.contents_worker_cmd_msg, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.contents_search_msg != null && message.hasOwnProperty("contents_search_msg"))
                        $root.syft_proto.messaging.v1.SearchMessage.encode(message.contents_search_msg, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SyftMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.SyftMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ISyftMessage} message SyftMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SyftMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SyftMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.SyftMessage} SyftMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SyftMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.SyftMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contents_empty_msg = $root.google.protobuf.Empty.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.contents_delete_msg = $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.contents_get_shape_msg = $root.syft_proto.messaging.v1.GetShapeMessage.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.contents_is_none_msg = $root.syft_proto.messaging.v1.IsNoneMessage.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.contents_object_msg = $root.syft_proto.messaging.v1.ObjectMessage.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.contents_object_request_msg = $root.syft_proto.messaging.v1.ObjectRequestMessage.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.contents_tensor_cmd_msg = $root.syft_proto.messaging.v1.TensorCommandMessage.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.contents_plan_cmd_msg = $root.syft_proto.messaging.v1.PlanCommandMessage.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.contents_worker_cmd_msg = $root.syft_proto.messaging.v1.WorkerCommandMessage.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.contents_search_msg = $root.syft_proto.messaging.v1.SearchMessage.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SyftMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.SyftMessage} SyftMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SyftMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SyftMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SyftMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.contents_empty_msg != null && message.hasOwnProperty("contents_empty_msg")) {
                        properties.contents = 1;
                        {
                            var error = $root.google.protobuf.Empty.verify(message.contents_empty_msg);
                            if (error)
                                return "contents_empty_msg." + error;
                        }
                    }
                    if (message.contents_delete_msg != null && message.hasOwnProperty("contents_delete_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.verify(message.contents_delete_msg);
                            if (error)
                                return "contents_delete_msg." + error;
                        }
                    }
                    if (message.contents_get_shape_msg != null && message.hasOwnProperty("contents_get_shape_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.GetShapeMessage.verify(message.contents_get_shape_msg);
                            if (error)
                                return "contents_get_shape_msg." + error;
                        }
                    }
                    if (message.contents_is_none_msg != null && message.hasOwnProperty("contents_is_none_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.IsNoneMessage.verify(message.contents_is_none_msg);
                            if (error)
                                return "contents_is_none_msg." + error;
                        }
                    }
                    if (message.contents_object_msg != null && message.hasOwnProperty("contents_object_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.ObjectMessage.verify(message.contents_object_msg);
                            if (error)
                                return "contents_object_msg." + error;
                        }
                    }
                    if (message.contents_object_request_msg != null && message.hasOwnProperty("contents_object_request_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.ObjectRequestMessage.verify(message.contents_object_request_msg);
                            if (error)
                                return "contents_object_request_msg." + error;
                        }
                    }
                    if (message.contents_tensor_cmd_msg != null && message.hasOwnProperty("contents_tensor_cmd_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.TensorCommandMessage.verify(message.contents_tensor_cmd_msg);
                            if (error)
                                return "contents_tensor_cmd_msg." + error;
                        }
                    }
                    if (message.contents_plan_cmd_msg != null && message.hasOwnProperty("contents_plan_cmd_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.PlanCommandMessage.verify(message.contents_plan_cmd_msg);
                            if (error)
                                return "contents_plan_cmd_msg." + error;
                        }
                    }
                    if (message.contents_worker_cmd_msg != null && message.hasOwnProperty("contents_worker_cmd_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.WorkerCommandMessage.verify(message.contents_worker_cmd_msg);
                            if (error)
                                return "contents_worker_cmd_msg." + error;
                        }
                    }
                    if (message.contents_search_msg != null && message.hasOwnProperty("contents_search_msg")) {
                        if (properties.contents === 1)
                            return "contents: multiple values";
                        properties.contents = 1;
                        {
                            var error = $root.syft_proto.messaging.v1.SearchMessage.verify(message.contents_search_msg);
                            if (error)
                                return "contents_search_msg." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SyftMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.SyftMessage} SyftMessage
                 */
                SyftMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.SyftMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.SyftMessage();
                    if (object.contents_empty_msg != null) {
                        if (typeof object.contents_empty_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_empty_msg: object expected");
                        message.contents_empty_msg = $root.google.protobuf.Empty.fromObject(object.contents_empty_msg);
                    }
                    if (object.contents_delete_msg != null) {
                        if (typeof object.contents_delete_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_delete_msg: object expected");
                        message.contents_delete_msg = $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.fromObject(object.contents_delete_msg);
                    }
                    if (object.contents_get_shape_msg != null) {
                        if (typeof object.contents_get_shape_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_get_shape_msg: object expected");
                        message.contents_get_shape_msg = $root.syft_proto.messaging.v1.GetShapeMessage.fromObject(object.contents_get_shape_msg);
                    }
                    if (object.contents_is_none_msg != null) {
                        if (typeof object.contents_is_none_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_is_none_msg: object expected");
                        message.contents_is_none_msg = $root.syft_proto.messaging.v1.IsNoneMessage.fromObject(object.contents_is_none_msg);
                    }
                    if (object.contents_object_msg != null) {
                        if (typeof object.contents_object_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_object_msg: object expected");
                        message.contents_object_msg = $root.syft_proto.messaging.v1.ObjectMessage.fromObject(object.contents_object_msg);
                    }
                    if (object.contents_object_request_msg != null) {
                        if (typeof object.contents_object_request_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_object_request_msg: object expected");
                        message.contents_object_request_msg = $root.syft_proto.messaging.v1.ObjectRequestMessage.fromObject(object.contents_object_request_msg);
                    }
                    if (object.contents_tensor_cmd_msg != null) {
                        if (typeof object.contents_tensor_cmd_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_tensor_cmd_msg: object expected");
                        message.contents_tensor_cmd_msg = $root.syft_proto.messaging.v1.TensorCommandMessage.fromObject(object.contents_tensor_cmd_msg);
                    }
                    if (object.contents_plan_cmd_msg != null) {
                        if (typeof object.contents_plan_cmd_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_plan_cmd_msg: object expected");
                        message.contents_plan_cmd_msg = $root.syft_proto.messaging.v1.PlanCommandMessage.fromObject(object.contents_plan_cmd_msg);
                    }
                    if (object.contents_worker_cmd_msg != null) {
                        if (typeof object.contents_worker_cmd_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_worker_cmd_msg: object expected");
                        message.contents_worker_cmd_msg = $root.syft_proto.messaging.v1.WorkerCommandMessage.fromObject(object.contents_worker_cmd_msg);
                    }
                    if (object.contents_search_msg != null) {
                        if (typeof object.contents_search_msg !== "object")
                            throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_search_msg: object expected");
                        message.contents_search_msg = $root.syft_proto.messaging.v1.SearchMessage.fromObject(object.contents_search_msg);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SyftMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @static
                 * @param {syft_proto.messaging.v1.SyftMessage} message SyftMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SyftMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.contents_empty_msg != null && message.hasOwnProperty("contents_empty_msg")) {
                        object.contents_empty_msg = $root.google.protobuf.Empty.toObject(message.contents_empty_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_empty_msg";
                    }
                    if (message.contents_delete_msg != null && message.hasOwnProperty("contents_delete_msg")) {
                        object.contents_delete_msg = $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.toObject(message.contents_delete_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_delete_msg";
                    }
                    if (message.contents_get_shape_msg != null && message.hasOwnProperty("contents_get_shape_msg")) {
                        object.contents_get_shape_msg = $root.syft_proto.messaging.v1.GetShapeMessage.toObject(message.contents_get_shape_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_get_shape_msg";
                    }
                    if (message.contents_is_none_msg != null && message.hasOwnProperty("contents_is_none_msg")) {
                        object.contents_is_none_msg = $root.syft_proto.messaging.v1.IsNoneMessage.toObject(message.contents_is_none_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_is_none_msg";
                    }
                    if (message.contents_object_msg != null && message.hasOwnProperty("contents_object_msg")) {
                        object.contents_object_msg = $root.syft_proto.messaging.v1.ObjectMessage.toObject(message.contents_object_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_object_msg";
                    }
                    if (message.contents_object_request_msg != null && message.hasOwnProperty("contents_object_request_msg")) {
                        object.contents_object_request_msg = $root.syft_proto.messaging.v1.ObjectRequestMessage.toObject(message.contents_object_request_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_object_request_msg";
                    }
                    if (message.contents_tensor_cmd_msg != null && message.hasOwnProperty("contents_tensor_cmd_msg")) {
                        object.contents_tensor_cmd_msg = $root.syft_proto.messaging.v1.TensorCommandMessage.toObject(message.contents_tensor_cmd_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_tensor_cmd_msg";
                    }
                    if (message.contents_plan_cmd_msg != null && message.hasOwnProperty("contents_plan_cmd_msg")) {
                        object.contents_plan_cmd_msg = $root.syft_proto.messaging.v1.PlanCommandMessage.toObject(message.contents_plan_cmd_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_plan_cmd_msg";
                    }
                    if (message.contents_worker_cmd_msg != null && message.hasOwnProperty("contents_worker_cmd_msg")) {
                        object.contents_worker_cmd_msg = $root.syft_proto.messaging.v1.WorkerCommandMessage.toObject(message.contents_worker_cmd_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_worker_cmd_msg";
                    }
                    if (message.contents_search_msg != null && message.hasOwnProperty("contents_search_msg")) {
                        object.contents_search_msg = $root.syft_proto.messaging.v1.SearchMessage.toObject(message.contents_search_msg, options);
                        if (options.oneofs)
                            object.contents = "contents_search_msg";
                    }
                    return object;
                };

                /**
                 * Converts this SyftMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.SyftMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SyftMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return SyftMessage;
            })();

            v1.IsNoneMessage = (function() {

                /**
                 * Properties of an IsNoneMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface IIsNoneMessage
                 * @property {syft_proto.types.syft.v1.IId|null} [object_id] IsNoneMessage object_id
                 */

                /**
                 * Constructs a new IsNoneMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents an IsNoneMessage.
                 * @implements IIsNoneMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.IIsNoneMessage=} [properties] Properties to set
                 */
                function IsNoneMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * IsNoneMessage object_id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @instance
                 */
                IsNoneMessage.prototype.object_id = null;

                /**
                 * Creates a new IsNoneMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IIsNoneMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.IsNoneMessage} IsNoneMessage instance
                 */
                IsNoneMessage.create = function create(properties) {
                    return new IsNoneMessage(properties);
                };

                /**
                 * Encodes the specified IsNoneMessage message. Does not implicitly {@link syft_proto.messaging.v1.IsNoneMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IIsNoneMessage} message IsNoneMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IsNoneMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.object_id != null && message.hasOwnProperty("object_id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified IsNoneMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.IsNoneMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IIsNoneMessage} message IsNoneMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IsNoneMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an IsNoneMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.IsNoneMessage} IsNoneMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IsNoneMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.IsNoneMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an IsNoneMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.IsNoneMessage} IsNoneMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IsNoneMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an IsNoneMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IsNoneMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.object_id != null && message.hasOwnProperty("object_id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                        if (error)
                            return "object_id." + error;
                    }
                    return null;
                };

                /**
                 * Creates an IsNoneMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.IsNoneMessage} IsNoneMessage
                 */
                IsNoneMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.IsNoneMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.IsNoneMessage();
                    if (object.object_id != null) {
                        if (typeof object.object_id !== "object")
                            throw TypeError(".syft_proto.messaging.v1.IsNoneMessage.object_id: object expected");
                        message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an IsNoneMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IsNoneMessage} message IsNoneMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                IsNoneMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.object_id = null;
                    if (message.object_id != null && message.hasOwnProperty("object_id"))
                        object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                    return object;
                };

                /**
                 * Converts this IsNoneMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.IsNoneMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                IsNoneMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return IsNoneMessage;
            })();

            v1.ObjectMessage = (function() {

                /**
                 * Properties of an ObjectMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface IObjectMessage
                 * @property {syft_proto.types.torch.v1.ITorchTensor|null} [tensor] ObjectMessage tensor
                 */

                /**
                 * Constructs a new ObjectMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents an ObjectMessage.
                 * @implements IObjectMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.IObjectMessage=} [properties] Properties to set
                 */
                function ObjectMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ObjectMessage tensor.
                 * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} tensor
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @instance
                 */
                ObjectMessage.prototype.tensor = null;

                /**
                 * Creates a new ObjectMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IObjectMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.ObjectMessage} ObjectMessage instance
                 */
                ObjectMessage.create = function create(properties) {
                    return new ObjectMessage(properties);
                };

                /**
                 * Encodes the specified ObjectMessage message. Does not implicitly {@link syft_proto.messaging.v1.ObjectMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IObjectMessage} message ObjectMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ObjectMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tensor != null && message.hasOwnProperty("tensor"))
                        $root.syft_proto.types.torch.v1.TorchTensor.encode(message.tensor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ObjectMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.ObjectMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IObjectMessage} message ObjectMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ObjectMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ObjectMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.ObjectMessage} ObjectMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ObjectMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.ObjectMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ObjectMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.ObjectMessage} ObjectMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ObjectMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ObjectMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ObjectMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.tensor != null && message.hasOwnProperty("tensor")) {
                        var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.tensor);
                        if (error)
                            return "tensor." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ObjectMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.ObjectMessage} ObjectMessage
                 */
                ObjectMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.ObjectMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.ObjectMessage();
                    if (object.tensor != null) {
                        if (typeof object.tensor !== "object")
                            throw TypeError(".syft_proto.messaging.v1.ObjectMessage.tensor: object expected");
                        message.tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.tensor);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ObjectMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ObjectMessage} message ObjectMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ObjectMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.tensor = null;
                    if (message.tensor != null && message.hasOwnProperty("tensor"))
                        object.tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.tensor, options);
                    return object;
                };

                /**
                 * Converts this ObjectMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.ObjectMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ObjectMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return ObjectMessage;
            })();

            v1.TensorCommandMessage = (function() {

                /**
                 * Properties of a TensorCommandMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface ITensorCommandMessage
                 * @property {syft_proto.execution.v1.IComputationAction|null} [computation] TensorCommandMessage computation
                 * @property {syft_proto.execution.v1.ICommunicationAction|null} [communication] TensorCommandMessage communication
                 */

                /**
                 * Constructs a new TensorCommandMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents a TensorCommandMessage.
                 * @implements ITensorCommandMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.ITensorCommandMessage=} [properties] Properties to set
                 */
                function TensorCommandMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TensorCommandMessage computation.
                 * @member {syft_proto.execution.v1.IComputationAction|null|undefined} computation
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @instance
                 */
                TensorCommandMessage.prototype.computation = null;

                /**
                 * TensorCommandMessage communication.
                 * @member {syft_proto.execution.v1.ICommunicationAction|null|undefined} communication
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @instance
                 */
                TensorCommandMessage.prototype.communication = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * TensorCommandMessage action.
                 * @member {"computation"|"communication"|undefined} action
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @instance
                 */
                Object.defineProperty(TensorCommandMessage.prototype, "action", {
                    get: $util.oneOfGetter($oneOfFields = ["computation", "communication"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new TensorCommandMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ITensorCommandMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.TensorCommandMessage} TensorCommandMessage instance
                 */
                TensorCommandMessage.create = function create(properties) {
                    return new TensorCommandMessage(properties);
                };

                /**
                 * Encodes the specified TensorCommandMessage message. Does not implicitly {@link syft_proto.messaging.v1.TensorCommandMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ITensorCommandMessage} message TensorCommandMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TensorCommandMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.computation != null && message.hasOwnProperty("computation"))
                        $root.syft_proto.execution.v1.ComputationAction.encode(message.computation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.communication != null && message.hasOwnProperty("communication"))
                        $root.syft_proto.execution.v1.CommunicationAction.encode(message.communication, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TensorCommandMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.TensorCommandMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ITensorCommandMessage} message TensorCommandMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TensorCommandMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TensorCommandMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.TensorCommandMessage} TensorCommandMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TensorCommandMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.TensorCommandMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.computation = $root.syft_proto.execution.v1.ComputationAction.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.communication = $root.syft_proto.execution.v1.CommunicationAction.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TensorCommandMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.TensorCommandMessage} TensorCommandMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TensorCommandMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TensorCommandMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TensorCommandMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.computation != null && message.hasOwnProperty("computation")) {
                        properties.action = 1;
                        {
                            var error = $root.syft_proto.execution.v1.ComputationAction.verify(message.computation);
                            if (error)
                                return "computation." + error;
                        }
                    }
                    if (message.communication != null && message.hasOwnProperty("communication")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            var error = $root.syft_proto.execution.v1.CommunicationAction.verify(message.communication);
                            if (error)
                                return "communication." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TensorCommandMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.TensorCommandMessage} TensorCommandMessage
                 */
                TensorCommandMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.TensorCommandMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.TensorCommandMessage();
                    if (object.computation != null) {
                        if (typeof object.computation !== "object")
                            throw TypeError(".syft_proto.messaging.v1.TensorCommandMessage.computation: object expected");
                        message.computation = $root.syft_proto.execution.v1.ComputationAction.fromObject(object.computation);
                    }
                    if (object.communication != null) {
                        if (typeof object.communication !== "object")
                            throw TypeError(".syft_proto.messaging.v1.TensorCommandMessage.communication: object expected");
                        message.communication = $root.syft_proto.execution.v1.CommunicationAction.fromObject(object.communication);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TensorCommandMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.TensorCommandMessage} message TensorCommandMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TensorCommandMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.computation != null && message.hasOwnProperty("computation")) {
                        object.computation = $root.syft_proto.execution.v1.ComputationAction.toObject(message.computation, options);
                        if (options.oneofs)
                            object.action = "computation";
                    }
                    if (message.communication != null && message.hasOwnProperty("communication")) {
                        object.communication = $root.syft_proto.execution.v1.CommunicationAction.toObject(message.communication, options);
                        if (options.oneofs)
                            object.action = "communication";
                    }
                    return object;
                };

                /**
                 * Converts this TensorCommandMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.TensorCommandMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TensorCommandMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return TensorCommandMessage;
            })();

            v1.ForceObjectDeleteMessage = (function() {

                /**
                 * Properties of a ForceObjectDeleteMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface IForceObjectDeleteMessage
                 * @property {syft_proto.types.syft.v1.IId|null} [object_id] ForceObjectDeleteMessage object_id
                 */

                /**
                 * Constructs a new ForceObjectDeleteMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents a ForceObjectDeleteMessage.
                 * @implements IForceObjectDeleteMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.IForceObjectDeleteMessage=} [properties] Properties to set
                 */
                function ForceObjectDeleteMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ForceObjectDeleteMessage object_id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @instance
                 */
                ForceObjectDeleteMessage.prototype.object_id = null;

                /**
                 * Creates a new ForceObjectDeleteMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IForceObjectDeleteMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.ForceObjectDeleteMessage} ForceObjectDeleteMessage instance
                 */
                ForceObjectDeleteMessage.create = function create(properties) {
                    return new ForceObjectDeleteMessage(properties);
                };

                /**
                 * Encodes the specified ForceObjectDeleteMessage message. Does not implicitly {@link syft_proto.messaging.v1.ForceObjectDeleteMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IForceObjectDeleteMessage} message ForceObjectDeleteMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForceObjectDeleteMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.object_id != null && message.hasOwnProperty("object_id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ForceObjectDeleteMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.ForceObjectDeleteMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IForceObjectDeleteMessage} message ForceObjectDeleteMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForceObjectDeleteMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ForceObjectDeleteMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.ForceObjectDeleteMessage} ForceObjectDeleteMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForceObjectDeleteMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.ForceObjectDeleteMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ForceObjectDeleteMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.ForceObjectDeleteMessage} ForceObjectDeleteMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForceObjectDeleteMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ForceObjectDeleteMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ForceObjectDeleteMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.object_id != null && message.hasOwnProperty("object_id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                        if (error)
                            return "object_id." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ForceObjectDeleteMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.ForceObjectDeleteMessage} ForceObjectDeleteMessage
                 */
                ForceObjectDeleteMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.ForceObjectDeleteMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.ForceObjectDeleteMessage();
                    if (object.object_id != null) {
                        if (typeof object.object_id !== "object")
                            throw TypeError(".syft_proto.messaging.v1.ForceObjectDeleteMessage.object_id: object expected");
                        message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ForceObjectDeleteMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ForceObjectDeleteMessage} message ForceObjectDeleteMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ForceObjectDeleteMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.object_id = null;
                    if (message.object_id != null && message.hasOwnProperty("object_id"))
                        object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                    return object;
                };

                /**
                 * Converts this ForceObjectDeleteMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ForceObjectDeleteMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return ForceObjectDeleteMessage;
            })();

            v1.GetShapeMessage = (function() {

                /**
                 * Properties of a GetShapeMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface IGetShapeMessage
                 * @property {syft_proto.types.syft.v1.IId|null} [object_id] GetShapeMessage object_id
                 */

                /**
                 * Constructs a new GetShapeMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents a GetShapeMessage.
                 * @implements IGetShapeMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.IGetShapeMessage=} [properties] Properties to set
                 */
                function GetShapeMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetShapeMessage object_id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @instance
                 */
                GetShapeMessage.prototype.object_id = null;

                /**
                 * Creates a new GetShapeMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IGetShapeMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.GetShapeMessage} GetShapeMessage instance
                 */
                GetShapeMessage.create = function create(properties) {
                    return new GetShapeMessage(properties);
                };

                /**
                 * Encodes the specified GetShapeMessage message. Does not implicitly {@link syft_proto.messaging.v1.GetShapeMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IGetShapeMessage} message GetShapeMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetShapeMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.object_id != null && message.hasOwnProperty("object_id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GetShapeMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.GetShapeMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IGetShapeMessage} message GetShapeMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetShapeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetShapeMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.GetShapeMessage} GetShapeMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetShapeMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.GetShapeMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetShapeMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.GetShapeMessage} GetShapeMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetShapeMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetShapeMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetShapeMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.object_id != null && message.hasOwnProperty("object_id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                        if (error)
                            return "object_id." + error;
                    }
                    return null;
                };

                /**
                 * Creates a GetShapeMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.GetShapeMessage} GetShapeMessage
                 */
                GetShapeMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.GetShapeMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.GetShapeMessage();
                    if (object.object_id != null) {
                        if (typeof object.object_id !== "object")
                            throw TypeError(".syft_proto.messaging.v1.GetShapeMessage.object_id: object expected");
                        message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetShapeMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @static
                 * @param {syft_proto.messaging.v1.GetShapeMessage} message GetShapeMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetShapeMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.object_id = null;
                    if (message.object_id != null && message.hasOwnProperty("object_id"))
                        object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                    return object;
                };

                /**
                 * Converts this GetShapeMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.GetShapeMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetShapeMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return GetShapeMessage;
            })();

            v1.ObjectRequestMessage = (function() {

                /**
                 * Properties of an ObjectRequestMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface IObjectRequestMessage
                 * @property {syft_proto.types.syft.v1.IId|null} [object_id] ObjectRequestMessage object_id
                 * @property {string|null} [reason] ObjectRequestMessage reason
                 */

                /**
                 * Constructs a new ObjectRequestMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents an ObjectRequestMessage.
                 * @implements IObjectRequestMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.IObjectRequestMessage=} [properties] Properties to set
                 */
                function ObjectRequestMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ObjectRequestMessage object_id.
                 * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @instance
                 */
                ObjectRequestMessage.prototype.object_id = null;

                /**
                 * ObjectRequestMessage reason.
                 * @member {string} reason
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @instance
                 */
                ObjectRequestMessage.prototype.reason = "";

                /**
                 * Creates a new ObjectRequestMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IObjectRequestMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.ObjectRequestMessage} ObjectRequestMessage instance
                 */
                ObjectRequestMessage.create = function create(properties) {
                    return new ObjectRequestMessage(properties);
                };

                /**
                 * Encodes the specified ObjectRequestMessage message. Does not implicitly {@link syft_proto.messaging.v1.ObjectRequestMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IObjectRequestMessage} message ObjectRequestMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ObjectRequestMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.object_id != null && message.hasOwnProperty("object_id"))
                        $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
                    return writer;
                };

                /**
                 * Encodes the specified ObjectRequestMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.ObjectRequestMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IObjectRequestMessage} message ObjectRequestMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ObjectRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ObjectRequestMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.ObjectRequestMessage} ObjectRequestMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ObjectRequestMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.ObjectRequestMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.reason = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ObjectRequestMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.ObjectRequestMessage} ObjectRequestMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ObjectRequestMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ObjectRequestMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ObjectRequestMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.object_id != null && message.hasOwnProperty("object_id")) {
                        var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                        if (error)
                            return "object_id." + error;
                    }
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    return null;
                };

                /**
                 * Creates an ObjectRequestMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.ObjectRequestMessage} ObjectRequestMessage
                 */
                ObjectRequestMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.ObjectRequestMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.ObjectRequestMessage();
                    if (object.object_id != null) {
                        if (typeof object.object_id !== "object")
                            throw TypeError(".syft_proto.messaging.v1.ObjectRequestMessage.object_id: object expected");
                        message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                    }
                    if (object.reason != null)
                        message.reason = String(object.reason);
                    return message;
                };

                /**
                 * Creates a plain object from an ObjectRequestMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ObjectRequestMessage} message ObjectRequestMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ObjectRequestMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.object_id = null;
                        object.reason = "";
                    }
                    if (message.object_id != null && message.hasOwnProperty("object_id"))
                        object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = message.reason;
                    return object;
                };

                /**
                 * Converts this ObjectRequestMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ObjectRequestMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return ObjectRequestMessage;
            })();

            v1.PlanCommandMessage = (function() {

                /**
                 * Properties of a PlanCommandMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface IPlanCommandMessage
                 * @property {string|null} [command_name] PlanCommandMessage command_name
                 * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] PlanCommandMessage args
                 */

                /**
                 * Constructs a new PlanCommandMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents a PlanCommandMessage.
                 * @implements IPlanCommandMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.IPlanCommandMessage=} [properties] Properties to set
                 */
                function PlanCommandMessage(properties) {
                    this.args = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlanCommandMessage command_name.
                 * @member {string} command_name
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @instance
                 */
                PlanCommandMessage.prototype.command_name = "";

                /**
                 * PlanCommandMessage args.
                 * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @instance
                 */
                PlanCommandMessage.prototype.args = $util.emptyArray;

                /**
                 * Creates a new PlanCommandMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IPlanCommandMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.PlanCommandMessage} PlanCommandMessage instance
                 */
                PlanCommandMessage.create = function create(properties) {
                    return new PlanCommandMessage(properties);
                };

                /**
                 * Encodes the specified PlanCommandMessage message. Does not implicitly {@link syft_proto.messaging.v1.PlanCommandMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IPlanCommandMessage} message PlanCommandMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlanCommandMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command_name != null && message.hasOwnProperty("command_name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command_name);
                    if (message.args != null && message.args.length)
                        for (var i = 0; i < message.args.length; ++i)
                            $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlanCommandMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.PlanCommandMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IPlanCommandMessage} message PlanCommandMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlanCommandMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlanCommandMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.PlanCommandMessage} PlanCommandMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlanCommandMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.PlanCommandMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command_name = reader.string();
                            break;
                        case 2:
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlanCommandMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.PlanCommandMessage} PlanCommandMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlanCommandMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlanCommandMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlanCommandMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.command_name != null && message.hasOwnProperty("command_name"))
                        if (!$util.isString(message.command_name))
                            return "command_name: string expected";
                    if (message.args != null && message.hasOwnProperty("args")) {
                        if (!Array.isArray(message.args))
                            return "args: array expected";
                        for (var i = 0; i < message.args.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                            if (error)
                                return "args." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PlanCommandMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.PlanCommandMessage} PlanCommandMessage
                 */
                PlanCommandMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.PlanCommandMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.PlanCommandMessage();
                    if (object.command_name != null)
                        message.command_name = String(object.command_name);
                    if (object.args) {
                        if (!Array.isArray(object.args))
                            throw TypeError(".syft_proto.messaging.v1.PlanCommandMessage.args: array expected");
                        message.args = [];
                        for (var i = 0; i < object.args.length; ++i) {
                            if (typeof object.args[i] !== "object")
                                throw TypeError(".syft_proto.messaging.v1.PlanCommandMessage.args: object expected");
                            message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlanCommandMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.PlanCommandMessage} message PlanCommandMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlanCommandMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.args = [];
                    if (options.defaults)
                        object.command_name = "";
                    if (message.command_name != null && message.hasOwnProperty("command_name"))
                        object.command_name = message.command_name;
                    if (message.args && message.args.length) {
                        object.args = [];
                        for (var j = 0; j < message.args.length; ++j)
                            object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this PlanCommandMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.PlanCommandMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlanCommandMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return PlanCommandMessage;
            })();

            v1.WorkerCommandMessage = (function() {

                /**
                 * Properties of a WorkerCommandMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface IWorkerCommandMessage
                 * @property {string|null} [command_name] WorkerCommandMessage command_name
                 * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] WorkerCommandMessage args
                 */

                /**
                 * Constructs a new WorkerCommandMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents a WorkerCommandMessage.
                 * @implements IWorkerCommandMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.IWorkerCommandMessage=} [properties] Properties to set
                 */
                function WorkerCommandMessage(properties) {
                    this.args = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WorkerCommandMessage command_name.
                 * @member {string} command_name
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @instance
                 */
                WorkerCommandMessage.prototype.command_name = "";

                /**
                 * WorkerCommandMessage args.
                 * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @instance
                 */
                WorkerCommandMessage.prototype.args = $util.emptyArray;

                /**
                 * Creates a new WorkerCommandMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IWorkerCommandMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.WorkerCommandMessage} WorkerCommandMessage instance
                 */
                WorkerCommandMessage.create = function create(properties) {
                    return new WorkerCommandMessage(properties);
                };

                /**
                 * Encodes the specified WorkerCommandMessage message. Does not implicitly {@link syft_proto.messaging.v1.WorkerCommandMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IWorkerCommandMessage} message WorkerCommandMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkerCommandMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command_name != null && message.hasOwnProperty("command_name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command_name);
                    if (message.args != null && message.args.length)
                        for (var i = 0; i < message.args.length; ++i)
                            $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified WorkerCommandMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.WorkerCommandMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.IWorkerCommandMessage} message WorkerCommandMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkerCommandMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WorkerCommandMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.WorkerCommandMessage} WorkerCommandMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkerCommandMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.WorkerCommandMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command_name = reader.string();
                            break;
                        case 2:
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WorkerCommandMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.WorkerCommandMessage} WorkerCommandMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkerCommandMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WorkerCommandMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkerCommandMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.command_name != null && message.hasOwnProperty("command_name"))
                        if (!$util.isString(message.command_name))
                            return "command_name: string expected";
                    if (message.args != null && message.hasOwnProperty("args")) {
                        if (!Array.isArray(message.args))
                            return "args: array expected";
                        for (var i = 0; i < message.args.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                            if (error)
                                return "args." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a WorkerCommandMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.WorkerCommandMessage} WorkerCommandMessage
                 */
                WorkerCommandMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.WorkerCommandMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.WorkerCommandMessage();
                    if (object.command_name != null)
                        message.command_name = String(object.command_name);
                    if (object.args) {
                        if (!Array.isArray(object.args))
                            throw TypeError(".syft_proto.messaging.v1.WorkerCommandMessage.args: array expected");
                        message.args = [];
                        for (var i = 0; i < object.args.length; ++i) {
                            if (typeof object.args[i] !== "object")
                                throw TypeError(".syft_proto.messaging.v1.WorkerCommandMessage.args: object expected");
                            message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a WorkerCommandMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @static
                 * @param {syft_proto.messaging.v1.WorkerCommandMessage} message WorkerCommandMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WorkerCommandMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.args = [];
                    if (options.defaults)
                        object.command_name = "";
                    if (message.command_name != null && message.hasOwnProperty("command_name"))
                        object.command_name = message.command_name;
                    if (message.args && message.args.length) {
                        object.args = [];
                        for (var j = 0; j < message.args.length; ++j)
                            object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this WorkerCommandMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WorkerCommandMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return WorkerCommandMessage;
            })();

            v1.SearchMessage = (function() {

                /**
                 * Properties of a SearchMessage.
                 * @memberof syft_proto.messaging.v1
                 * @interface ISearchMessage
                 * @property {Array.<syft_proto.types.syft.v1.IId>|null} [query] SearchMessage query
                 */

                /**
                 * Constructs a new SearchMessage.
                 * @memberof syft_proto.messaging.v1
                 * @classdesc Represents a SearchMessage.
                 * @implements ISearchMessage
                 * @constructor
                 * @param {syft_proto.messaging.v1.ISearchMessage=} [properties] Properties to set
                 */
                function SearchMessage(properties) {
                    this.query = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchMessage query.
                 * @member {Array.<syft_proto.types.syft.v1.IId>} query
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @instance
                 */
                SearchMessage.prototype.query = $util.emptyArray;

                /**
                 * Creates a new SearchMessage instance using the specified properties.
                 * @function create
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ISearchMessage=} [properties] Properties to set
                 * @returns {syft_proto.messaging.v1.SearchMessage} SearchMessage instance
                 */
                SearchMessage.create = function create(properties) {
                    return new SearchMessage(properties);
                };

                /**
                 * Encodes the specified SearchMessage message. Does not implicitly {@link syft_proto.messaging.v1.SearchMessage.verify|verify} messages.
                 * @function encode
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ISearchMessage} message SearchMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SearchMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.query != null && message.query.length)
                        for (var i = 0; i < message.query.length; ++i)
                            $root.syft_proto.types.syft.v1.Id.encode(message.query[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SearchMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.SearchMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @static
                 * @param {syft_proto.messaging.v1.ISearchMessage} message SearchMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SearchMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SearchMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {syft_proto.messaging.v1.SearchMessage} SearchMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SearchMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.SearchMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.query && message.query.length))
                                message.query = [];
                            message.query.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SearchMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {syft_proto.messaging.v1.SearchMessage} SearchMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SearchMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SearchMessage message.
                 * @function verify
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.query != null && message.hasOwnProperty("query")) {
                        if (!Array.isArray(message.query))
                            return "query: array expected";
                        for (var i = 0; i < message.query.length; ++i) {
                            var error = $root.syft_proto.types.syft.v1.Id.verify(message.query[i]);
                            if (error)
                                return "query." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SearchMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {syft_proto.messaging.v1.SearchMessage} SearchMessage
                 */
                SearchMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.syft_proto.messaging.v1.SearchMessage)
                        return object;
                    var message = new $root.syft_proto.messaging.v1.SearchMessage();
                    if (object.query) {
                        if (!Array.isArray(object.query))
                            throw TypeError(".syft_proto.messaging.v1.SearchMessage.query: array expected");
                        message.query = [];
                        for (var i = 0; i < object.query.length; ++i) {
                            if (typeof object.query[i] !== "object")
                                throw TypeError(".syft_proto.messaging.v1.SearchMessage.query: object expected");
                            message.query[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.query[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SearchMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @static
                 * @param {syft_proto.messaging.v1.SearchMessage} message SearchMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.query = [];
                    if (message.query && message.query.length) {
                        object.query = [];
                        for (var j = 0; j < message.query.length; ++j)
                            object.query[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.query[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SearchMessage to JSON.
                 * @function toJSON
                 * @memberof syft_proto.messaging.v1.SearchMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                };

                return SearchMessage;
            })();

            return v1;
        })();

        return messaging;
    })();

    return syft_proto;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
            };

            return Empty;
        })();

        return protobuf;
    })();

    return google;
})();

var protobuf = $root;

getCjsExportFromNamespace(proto$1);

var protobuf$1 = protobuf;

var Protocol = /*#__PURE__*/function () {
  function Protocol(id, tags, description, planAssigments, workersResolved) {
    _classCallCheck(this, Protocol);

    this.id = id;
    this.tags = tags;
    this.description = description;
    this.plans = planAssigments;
    this.workersResolved = workersResolved;
  }

  _createClass(Protocol, null, [{
    key: "unbufferize",
    value: function unbufferize(worker, pb) {
      var planAssignments = [];

      if (pb.plan_assignments) {
        pb.plan_assignments.forEach(function (item) {
          planAssignments.push([getPbId(item.worker_id), getPbId(item.plan_id)]);
        });
      }

      return new Protocol(getPbId(pb.id), pb.tags, pb.description, planAssignments, pb.workers_resolved);
    }
  }]);

  return Protocol;
}();

/**
 * PySyft Plan.
 */

var Plan = /*#__PURE__*/function () {
  /**
   * @hideconstructor
   */
  function Plan(id, name) {
    var role = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var tags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var description = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, Plan);

    this.id = id;
    this.name = name;
    this.role = role;
    this.tags = tags;
    this.description = description;
  }
  /**
   * @private
   * @returns {Plan}
   */


  _createClass(Plan, [{
    key: "execute",

    /**
     * Executes the Plan and returns its output.
     *
     * The order, type and number of arguments must match to arguments defined in the PySyft Plan.
     *
     * @param {Syft} worker
     * @param {...(tf.Tensor|number)} data
     * @returns {Promise<Array.<tf.Tensor>>}
     */
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(worker) {
        var _this$role;

        var _len,
            data,
            _key,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                for (_len = _args.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  data[_key - 1] = _args[_key];
                }

                return _context.abrupt("return", (_this$role = this.role).execute.apply(_this$role, [worker].concat(data)));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function execute(_x) {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
  }], [{
    key: "unbufferize",
    value: function unbufferize$1(worker, pb) {
      var id = getPbId(pb.id);
      return new Plan(id, pb.name, unbufferize(worker, pb.role), pb.tags, pb.description);
    }
  }]);

  return Plan;
}();

var ObjectRegistry = /*#__PURE__*/function () {
  function ObjectRegistry() {
    _classCallCheck(this, ObjectRegistry);

    this.objects = {};
    this.gc = {};
  }

  _createClass(ObjectRegistry, [{
    key: "set",
    value: function set(id, obj) {
      var gc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (this.objects[id] instanceof tf.Tensor) {
        this.objects[id].dispose();
        delete this.objects[id];
      }

      this.objects[id] = obj;
      this.gc[id] = gc;
    }
  }, {
    key: "setGc",
    value: function setGc(id, gc) {
      this.gc[id] = gc;
    }
  }, {
    key: "get",
    value: function get(id) {
      return this.objects[id];
    }
  }, {
    key: "has",
    value: function has(id) {
      return Object.hasOwnProperty.call(this.objects, id);
    }
  }, {
    key: "clear",
    value: function clear() {
      for (var _i = 0, _Object$keys = Object.keys(this.objects); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];

        if (this.gc[key] && this.objects[key] instanceof tf.Tensor) {
          this.objects[key].dispose();
        }
      }

      this.objects = {};
      this.gc = {};
    }
  }, {
    key: "load",
    value: function load(objectRegistry) {
      for (var _i2 = 0, _Object$keys2 = Object.keys(objectRegistry.objects); _i2 < _Object$keys2.length; _i2++) {
        var key = _Object$keys2[_i2];
        this.set(key, objectRegistry.get(key));
      }
    }
  }]);

  return ObjectRegistry;
}();

var Role = /*#__PURE__*/function () {
  function Role(id) {
    var actions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var placeholders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var input_placeholder_ids = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
    var output_placeholder_ids = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
    var tags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
    var description = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

    _classCallCheck(this, Role);

    this.id = id;
    this.actions = actions;
    this.state = state;
    this.placeholders = placeholders;
    this.input_placeholder_ids = input_placeholder_ids;
    this.output_placeholder_ids = output_placeholder_ids;
    this.tags = tags;
    this.description = description;
  }

  _createClass(Role, [{
    key: "findPlaceholders",
    value: function findPlaceholders(tagRegex) {
      return this.placeholders.filter(function (placeholder) {
        return placeholder.tags && placeholder.tags.some(function (tag) {
          return tagRegex.test(tag);
        });
      });
    }
  }, {
    key: "getInputPlaceholders",
    value: function getInputPlaceholders() {
      var _this = this;

      return this.input_placeholder_ids.map(function (id) {
        return _this.placeholders[id];
      });
    }
  }, {
    key: "getOutputPlaceholders",
    value: function getOutputPlaceholders() {
      var _this2 = this;

      return this.output_placeholder_ids.map(function (id) {
        return _this2.placeholders[id];
      });
    }
    /**
     * Execute the Role with given worker
     * @param {Syft} worker
     * @param data
     * @returns {Promise<Array>}
     */

  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(worker) {
        var _this3 = this;

        var planScope,
            inputPlaceholders,
            outputPlaceholders,
            argsLength,
            _len,
            data,
            _key,
            _iterator,
            _step,
            action,
            result,
            resolvedResultingTensors,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Create local scope.
                planScope = new ObjectRegistry();
                planScope.load(worker.objects);
                inputPlaceholders = this.getInputPlaceholders(), outputPlaceholders = this.getOutputPlaceholders(), argsLength = inputPlaceholders.length; // If the number of arguments supplied does not match the number of arguments required...

                for (_len = _args.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  data[_key - 1] = _args[_key];
                }

                if (!(data.length !== argsLength)) {
                  _context.next = 6;
                  break;
                }

                throw new Error(NOT_ENOUGH_ARGS(data.length, argsLength));

              case 6:
                // For each argument supplied, add them in scope
                data.forEach(function (datum, i) {
                  planScope.set(inputPlaceholders[i].id, datum);
                }); // load state tensors to worker

                if (this.state && this.state.tensors) {
                  this.state.placeholders.forEach(function (ph, idx) {
                    planScope.set(ph.id, _this3.state.tensors[idx]);
                  });
                } // Execute the plan


                _iterator = _createForOfIteratorHelper(this.actions);
                _context.prev = 9;

                _iterator.s();

              case 11:
                if ((_step = _iterator.n()).done) {
                  _context.next = 19;
                  break;
                }

                action = _step.value;
                _context.next = 15;
                return action.execute(planScope);

              case 15:
                result = _context.sent;

                // Place the result of the current operation into this.objects at the 0th item in returnIds
                // All intermediate tensors will be garbage collected by default
                if (result) {
                  if (action.returnIds.length > 0) {
                    planScope.set(action.returnIds[0], result, true);
                  } else if (action.returnPlaceholderIds.length > 0) {
                    planScope.set(action.returnPlaceholderIds[0].id, result, true);
                  }
                }

              case 17:
                _context.next = 11;
                break;

              case 19:
                _context.next = 24;
                break;

              case 21:
                _context.prev = 21;
                _context.t0 = _context["catch"](9);

                _iterator.e(_context.t0);

              case 24:
                _context.prev = 24;

                _iterator.f();

                return _context.finish(24);

              case 27:
                // Resolve all of the requested resultId's as specific by the plan
                resolvedResultingTensors = [];
                outputPlaceholders.forEach(function (placeholder) {
                  resolvedResultingTensors.push(planScope.get(placeholder.id)); // Do not gc output tensors

                  planScope.setGc(placeholder.id, false);
                }); // Cleanup intermediate plan variables.

                planScope.clear(); // Return them to the worker

                return _context.abrupt("return", resolvedResultingTensors);

              case 31:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[9, 21, 24, 27]]);
      }));

      function execute(_x) {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
  }], [{
    key: "unbufferize",
    value: function unbufferize$1(worker, pb) {
      var placeholdersArray = unbufferize(worker, pb.placeholders);

      var placeholders = {};

      var _iterator2 = _createForOfIteratorHelper(placeholdersArray),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ph = _step2.value;
          placeholders[ph.id] = ph;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return new Role(getPbId(pb.id), unbufferize(worker, pb.actions), unbufferize(worker, pb.state), placeholders, pb.input_placeholder_ids.map(getPbId), pb.output_placeholder_ids.map(getPbId), pb.tags, pb.description);
    }
  }]);

  return Role;
}();

var State$1 = /*#__PURE__*/function () {
  function State() {
    var placeholders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var tensors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, State);

    this.placeholders = placeholders;
    this.tensors = tensors;
  }

  _createClass(State, [{
    key: "getTfTensors",
    value: function getTfTensors() {
      return this.tensors.map(function (t) {
        return t.toTfTensor();
      });
    }
  }, {
    key: "bufferize",
    value: function bufferize(worker) {
      var tensorsPb = this.tensors.map(function (tensor) {
        return protobuf$1.syft_proto.execution.v1.StateTensor.create({
          torch_tensor: tensor.bufferize(worker)
        });
      });
      var placeholdersPb = this.placeholders.map(function (ph) {
        return ph.bufferize();
      });
      return protobuf$1.syft_proto.execution.v1.State.create({
        placeholders: placeholdersPb,
        tensors: tensorsPb
      });
    }
  }], [{
    key: "unbufferize",
    value: function unbufferize$1(worker, pb) {
      var tensors = pb.tensors.map(function (stateTensor) {
        // unwrap StateTensor
        return unbufferize(worker, stateTensor[stateTensor.tensor]);
      });
      return new State(unbufferize(worker, pb.placeholders), tensors);
    }
  }]);

  return State;
}();

var Message = function Message(contents) {
  _classCallCheck(this, Message);

  if (contents) {
    this.contents = contents;
  }

  this.logger = new Logger();
};
var ObjectMessage = /*#__PURE__*/function (_Message) {
  _inherits(ObjectMessage, _Message);

  var _super = _createSuper(ObjectMessage);

  function ObjectMessage(contents) {
    _classCallCheck(this, ObjectMessage);

    return _super.call(this, contents);
  }

  _createClass(ObjectMessage, null, [{
    key: "unbufferize",
    value: function unbufferize$1(worker, pb) {
      var tensor = unbufferize(worker, pb.tensor);

      return new ObjectMessage(tensor);
    }
  }]);

  return ObjectMessage;
}(Message); // TODO when types will be availbale in protobuf

/*
export class ObjectRequestMessage extends Message {
  constructor(contents) {
    super(contents);
  }
}

export class IsNoneMessage extends Message {
  constructor(contents) {
    super(contents);
  }
}

export class GetShapeMessage extends Message {
  constructor(contents) {
    super(contents);
  }
}

export class ForceObjectDeleteMessage extends Message {
  constructor(contents) {
    super(contents);
  }
}

export class SearchMessage extends Message {
  constructor(contents) {
    super(contents);
  }
}

export class PlanCommandMessage extends Message {
  constructor(commandName, message) {
    super();

    this.commandName = commandName;
    this.message = message;
  }
}
*/

var TorchTensor = /*#__PURE__*/function () {
  function TorchTensor(id, contents, shape, dtype) {
    var chain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var gradChain = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var tags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
    var description = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

    _classCallCheck(this, TorchTensor);

    this.id = id;
    this.shape = shape;
    this.dtype = dtype;
    this.contents = contents;
    this.chain = chain;
    this.gradChain = gradChain;
    this.tags = tags;
    this.description = description;
    this._tfTensor = null;
  }

  _createClass(TorchTensor, [{
    key: "toTfTensor",
    value: function toTfTensor() {
      if (!this._tfTensor) {
        this._tfTensor = tf.tensor(this.contents, this.shape, this.dtype);
      }

      return this._tfTensor;
    }
  }, {
    key: "bufferize",
    value: function bufferize()
    /* worker */
    {
      var tensorData = {
        shape: protobuf$1.syft_proto.types.torch.v1.Size.create({
          dims: this.shape
        }),
        dtype: this.dtype
      };
      tensorData["contents_".concat(this.dtype)] = this.contents;
      var pbTensorData = protobuf$1.syft_proto.types.torch.v1.TensorData.create(tensorData);
      return protobuf$1.syft_proto.types.torch.v1.TorchTensor.create({
        id: pbId(this.id),
        serializer: protobuf$1.syft_proto.types.torch.v1.TorchTensor.Serializer.SERIALIZER_ALL,
        contents_data: pbTensorData,
        tags: this.tags,
        description: this.description
      });
    }
  }], [{
    key: "unbufferize",
    value: function unbufferize$1(worker, pb) {
      if (pb.serializer !== protobuf$1.syft_proto.types.torch.v1.TorchTensor.Serializer.SERIALIZER_ALL) {
        throw new Error("Tensor serializer ".concat(pb.serializer, " is not supported in syft.js"));
      } // unwrap TensorData


      var tensorData = pb.contents_data;
      var dtype = tensorData.dtype;
      var shape = tensorData.shape.dims;
      var contents = tensorData["contents_".concat(dtype)];
      return new TorchTensor(getPbId(pb.id), contents, shape, dtype, unbufferize(worker, pb.chain), unbufferize(worker, pb.grad_chain), pb.tags, pb.description);
    }
  }, {
    key: "fromTfTensor",
    value: function () {
      var _fromTfTensor = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(tensor) {
        var flat, array, t;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                flat = tensor.flatten();
                _context.next = 3;
                return flat.array();

              case 3:
                array = _context.sent;
                flat.dispose();
                t = new TorchTensor(tensor.id, array, tensor.shape, tensor.dtype);
                t._tfTensor = tensor;
                return _context.abrupt("return", t);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function fromTfTensor(_x) {
        return _fromTfTensor.apply(this, arguments);
      }

      return fromTfTensor;
    }()
  }]);

  return TorchTensor;
}();
var TorchParameter = /*#__PURE__*/function () {
  function TorchParameter(id, tensor, requiresGrad, grad) {
    _classCallCheck(this, TorchParameter);

    this.id = id;
    this.tensor = tensor;
    this.requiresGrad = requiresGrad;
    this.grad = grad;
  }

  _createClass(TorchParameter, [{
    key: "toTfTensor",
    value: function toTfTensor() {
      return this.tensor.toTfTensor();
    }
  }], [{
    key: "unbufferize",
    value: function unbufferize$1(worker, pb) {
      return new TorchParameter(getPbId(pb.id), unbufferize(worker, pb.tensor), pb.requires_grad, unbufferize(worker, pb.grad));
    }
  }]);

  return TorchParameter;
}();

var PlaceholderId = /*#__PURE__*/function () {
  function PlaceholderId(id) {
    _classCallCheck(this, PlaceholderId);

    this.id = id;
  }

  _createClass(PlaceholderId, [{
    key: "bufferize",
    value: function bufferize()
    /* worker */
    {
      return protobuf$1.syft_proto.execution.v1.PlaceholderId.create({
        id: pbId(this.id)
      });
    }
  }], [{
    key: "unbufferize",
    value: function unbufferize(worker, pb) {
      return new PlaceholderId(getPbId(pb.id));
    }
  }]);

  return PlaceholderId;
}();
var Placeholder = /*#__PURE__*/function () {
  function Placeholder(id) {
    var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var expected_shape = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, Placeholder);

    this.id = id;
    this.tags = tags;
    this.description = description;
    this.expected_shape = expected_shape;
  }

  _createClass(Placeholder, [{
    key: "bufferize",
    value: function bufferize()
    /* worker */
    {
      return protobuf$1.syft_proto.execution.v1.Placeholder.create({
        id: pbId(this.id),
        tags: this.tags,
        description: this.description,
        expected_shape: protobuf$1.syft_proto.types.syft.v1.Shape.create(this.expected_shape)
      });
    }
  }, {
    key: "getOrderFromTags",
    value: function getOrderFromTags(prefix) {
      var regExp = new RegExp("^".concat(prefix, "-(\\d+)$"), 'i');

      var _iterator = _createForOfIteratorHelper(this.tags),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tag = _step.value;
          var tagMatch = regExp[Symbol.match](tag);

          if (tagMatch) {
            return Number(tagMatch[1]);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      throw new Error("Placeholder ".concat(this.id, " doesn't have order tag ").concat(prefix));
    }
  }], [{
    key: "unbufferize",
    value: function unbufferize(worker, pb) {
      var expected_shape = null;

      if (pb.expected_shape && Array.isArray(pb.expected_shape.dims) && pb.expected_shape.dims.length > 0) {
        // Unwrap Shape
        expected_shape = pb.expected_shape.dims;
      }

      return new Placeholder(getPbId(pb.id), pb.tags || [], pb.description, expected_shape);
    }
  }]);

  return Placeholder;
}();

// Create a class to represent pointer tensors
// Add all the attributes that are serialized, just as for range and slice
var PointerTensor = function PointerTensor(id, idAtLocation, locationId, pointToAttr, shape, garbageCollectData) {
  _classCallCheck(this, PointerTensor);

  this.id = id;
  this.idAtLocation = idAtLocation;
  this.locationId = locationId;
  this.pointToAttr = pointToAttr;
  this.shape = shape;
  this.garbageCollectData = garbageCollectData;
};

var NORMALIZATION_REGEX = /[a-zA-Z]/g;

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _nonIterableRest$1();
}

function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
}

function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray$1(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit$1(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var torch = {
	sum: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"sum"
			],
			name: "sum",
			tfjs: "sum",
			tf: "sum"
		}
	],
	relu: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "inplace",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"relu"
			],
			name: "relu",
			tfjs: "relu",
			tf: "relu"
		}
	],
	conv2d: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "weight",
					kwarg: false,
					opt: false
				},
				{
					name: "bias",
					kwarg: true,
					opt: true
				},
				{
					name: "stride",
					kwarg: true,
					opt: true
				},
				{
					name: "padding",
					kwarg: true,
					opt: true,
					tf: "padding"
				},
				{
					name: "dilation",
					kwarg: true,
					opt: true
				},
				{
					name: "groups",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"conv2d"
			],
			name: "conv2d",
			tfjs: "conv2d",
			tf: "conv2d"
		}
	],
	conv3d: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "weight",
					kwarg: false,
					opt: false
				},
				{
					name: "bias",
					kwarg: true,
					opt: true
				},
				{
					name: "stride",
					kwarg: true,
					opt: true
				},
				{
					name: "padding",
					kwarg: true,
					opt: true,
					tf: "padding"
				},
				{
					name: "dilation",
					kwarg: true,
					opt: true
				},
				{
					name: "groups",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"conv3d"
			],
			name: "conv3d",
			tfjs: "conv3d",
			tf: "conv3d"
		}
	],
	gather: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "index",
					kwarg: false,
					opt: false
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				},
				{
					name: "sparse_grad",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"gather"
			],
			name: "gather",
			tfjs: "gather",
			tf: "gather"
		}
	],
	grad: [
		{
			args: [
				{
					name: "outputs",
					kwarg: false,
					opt: false
				},
				{
					name: "inputs",
					kwarg: false,
					opt: false
				},
				{
					name: "grad_outputs",
					kwarg: true,
					opt: true
				},
				{
					name: "retain_graph",
					kwarg: true,
					opt: true
				},
				{
					name: "create_graph",
					kwarg: true,
					opt: true
				},
				{
					name: "only_inputs",
					kwarg: true,
					opt: true
				},
				{
					name: "allow_unused",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"autograd",
				"grad"
			],
			name: "grad",
			tfjs: "grad"
		}
	],
	conv1d: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "weight",
					kwarg: false,
					opt: false
				},
				{
					name: "bias",
					kwarg: true,
					opt: true
				},
				{
					name: "stride",
					kwarg: true,
					opt: true,
					tfjs: "stride"
				},
				{
					name: "padding",
					kwarg: true,
					opt: true,
					tf: "padding"
				},
				{
					name: "dilation",
					kwarg: true,
					opt: true,
					tfjs: "dilation"
				},
				{
					name: "groups",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"conv1d"
			],
			name: "conv1d",
			tfjs: "conv1d",
			tf: "conv1d"
		}
	],
	all: [
		{
			args: [
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"all"
			],
			name: "all",
			tfjs: "all",
			tf: "all"
		}
	],
	any: [
		{
			args: [
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"any"
			],
			name: "any",
			tfjs: "any",
			tf: "any"
		}
	],
	relu6: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "inplace",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"relu6"
			],
			name: "relu6",
			tfjs: "relu6",
			tf: "relu6"
		}
	],
	elu: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "alpha",
					kwarg: true,
					opt: true,
					tf: "alpha"
				},
				{
					name: "inplace",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"elu"
			],
			name: "elu",
			tfjs: "elu",
			tf: "elu"
		}
	],
	selu: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "inplace",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"selu"
			],
			name: "selu",
			tfjs: "selu",
			tf: "selu"
		}
	],
	prelu: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "weight",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"prelu"
			],
			name: "prelu",
			tfjs: "prelu",
			tf: "prelu"
		}
	],
	logsigmoid: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"logsigmoid"
			],
			name: "logsigmoid",
			tfjs: "logsigmoid"
		}
	],
	softplus: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "beta",
					kwarg: true,
					opt: true
				},
				{
					name: "threshold",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"softplus"
			],
			name: "softplus",
			tfjs: "softplus",
			tf: "softplus"
		}
	],
	softmax: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: true,
					opt: true,
					tfjs: "dim"
				},
				{
					name: "_stacklevel",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"softmax"
			],
			name: "softmax",
			tfjs: "softmax",
			tf: "softmax"
		}
	],
	tanh: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"tanh"
			],
			name: "tanh",
			tfjs: "tanh",
			tf: "tanh"
		}
	],
	sigmoid: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"sigmoid"
			],
			name: "sigmoid",
			tfjs: "sigmoid",
			tf: "sigmoid"
		}
	],
	dropout: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "p",
					kwarg: true,
					opt: true
				},
				{
					name: "training",
					kwarg: true,
					opt: true
				},
				{
					name: "inplace",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"dropout"
			],
			name: "dropout",
			tfjs: "dropout",
			tf: "dropout"
		}
	],
	embedding: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "weight",
					kwarg: false,
					opt: false
				},
				{
					name: "padding_idx",
					kwarg: true,
					opt: true
				},
				{
					name: "max_norm",
					kwarg: true,
					opt: true
				},
				{
					name: "norm_type",
					kwarg: true,
					opt: true
				},
				{
					name: "scale_grad_by_freq",
					kwarg: true,
					opt: true
				},
				{
					name: "sparse",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"embedding"
			],
			name: "embedding",
			tfjs: "embedding",
			tf: "embedding"
		}
	],
	identity: [
		{
			args: [
				{
					name: "module",
					kwarg: false,
					opt: false
				},
				{
					name: "name",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"torch",
				"nn",
				"utils",
				"prune",
				"identity"
			],
			name: "identity",
			tfjs: "identity",
			tf: "identity"
		}
	],
	tensor: [
		{
			args: [
				{
					name: "data",
					kwarg: false,
					opt: false
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true,
					tfjs: "dtype",
					tf: "dtype"
				},
				{
					name: "device",
					kwarg: true,
					opt: true
				},
				{
					name: "requires_grad",
					kwarg: true,
					opt: true
				},
				{
					name: "pin_memory",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"tensor"
			],
			name: "tensor",
			tfjs: "tensor",
			tf: "tensor"
		}
	],
	zeros: [
		{
			args: [
				{
					name: "",
					kwarg: false,
					opt: false
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true,
					tf: "dtype"
				},
				{
					name: "layout",
					kwarg: true,
					opt: true
				},
				{
					name: "device",
					kwarg: true,
					opt: true
				},
				{
					name: "requires_grad",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"zeros"
			],
			name: "zeros",
			tfjs: "zeros",
			tf: "zeros"
		}
	],
	ones: [
		{
			args: [
				{
					name: "",
					kwarg: false,
					opt: false
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true,
					tf: "dtype"
				},
				{
					name: "layout",
					kwarg: true,
					opt: true
				},
				{
					name: "device",
					kwarg: true,
					opt: true
				},
				{
					name: "requires_grad",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"ones"
			],
			name: "ones",
			tfjs: "ones",
			tf: "ones"
		}
	],
	range: [
		{
			args: [
				{
					name: "end",
					kwarg: false,
					opt: false
				},
				{
					name: "start",
					kwarg: true,
					opt: true,
					tfjs: "start"
				},
				{
					name: "step",
					kwarg: true,
					opt: true,
					tfjs: "step"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true,
					tfjs: "dtype",
					tf: "dtype"
				},
				{
					name: "layout",
					kwarg: true,
					opt: true
				},
				{
					name: "device",
					kwarg: true,
					opt: true
				},
				{
					name: "requires_grad",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"range"
			],
			name: "range",
			tfjs: "range",
			tf: "range"
		}
	],
	linspace: [
		{
			args: [
				{
					name: "start",
					kwarg: false,
					opt: false,
					tfjs: "start",
					tf: "start"
				},
				{
					name: "end",
					kwarg: false,
					opt: false
				},
				{
					name: "steps",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true
				},
				{
					name: "layout",
					kwarg: true,
					opt: true
				},
				{
					name: "device",
					kwarg: true,
					opt: true
				},
				{
					name: "requires_grad",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"linspace"
			],
			name: "linspace",
			tfjs: "linspace",
			tf: "linspace"
		}
	],
	eye: [
		{
			args: [
				{
					name: "n",
					kwarg: false,
					opt: false
				},
				{
					name: "m",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true,
					tfjs: "dtype",
					tf: "dtype"
				},
				{
					name: "layout",
					kwarg: true,
					opt: true
				},
				{
					name: "device",
					kwarg: true,
					opt: true
				},
				{
					name: "requires_grad",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"eye"
			],
			name: "eye",
			tfjs: "eye",
			tf: "eye"
		}
	],
	pad: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "pad",
					kwarg: false,
					opt: false
				},
				{
					name: "mode",
					kwarg: true,
					opt: true,
					tf: "mode"
				},
				{
					name: "value",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"nn",
				"functional",
				"pad"
			],
			name: "pad",
			tfjs: "pad",
			tf: "pad"
		}
	],
	reshape: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "shape",
					kwarg: false,
					opt: false,
					tf: "shape"
				}
			],
			attrs: [
				"torch",
				"reshape"
			],
			name: "reshape",
			tfjs: "reshape",
			tf: "reshape"
		}
	],
	split: [
		{
			args: [
				{
					name: "tensor",
					kwarg: false,
					opt: false
				},
				{
					name: "split_size_or_sections",
					kwarg: false,
					opt: false
				},
				{
					name: "dim",
					kwarg: true,
					opt: true,
					tfjs: "axis"
				}
			],
			attrs: [
				"torch",
				"split"
			],
			name: "split",
			tfjs: "split",
			tf: "split"
		}
	],
	squeeze: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a",
					tf: "input"
				},
				{
					name: "dim",
					kwarg: true,
					opt: true,
					tfjs: "axis"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"squeeze"
			],
			name: "squeeze",
			tfjs: "squeeze",
			tf: "squeeze"
		}
	],
	stack: [
		{
			args: [
				{
					name: "tensors",
					kwarg: false,
					opt: false,
					tfjs: "tensors"
				},
				{
					name: "dim",
					kwarg: true,
					opt: true,
					tfjs: "axis"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"stack"
			],
			name: "stack",
			tfjs: "stack",
			tf: "stack"
		}
	],
	t: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				}
			],
			attrs: [
				"torch",
				"t"
			],
			name: "t",
			tfjs: "transpose"
		}
	],
	take: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "index",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"torch",
				"take"
			],
			name: "take",
			tfjs: "take"
		}
	],
	transpose: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim0",
					kwarg: false,
					opt: false
				},
				{
					name: "dim1",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"torch",
				"transpose"
			],
			name: "transpose",
			tfjs: "transpose",
			tf: "transpose"
		}
	],
	where: [
		{
			args: [
				{
					name: "condition",
					kwarg: false,
					opt: false,
					tfjs: "condition",
					tf: "condition"
				}
			],
			attrs: [
				"torch",
				"where"
			],
			name: "where",
			tfjs: "where",
			tf: "where"
		}
	],
	multinomial: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "num_samples",
					kwarg: false,
					opt: false
				},
				{
					name: "",
					kwarg: false,
					opt: false
				},
				{
					name: "replacement",
					kwarg: true,
					opt: true
				},
				{
					name: "generator",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"multinomial"
			],
			name: "multinomial",
			tfjs: "multinomial"
		}
	],
	abs: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"abs"
			],
			name: "abs",
			tfjs: "abs",
			tf: "abs"
		}
	],
	acos: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"acos"
			],
			name: "acos",
			tfjs: "acos",
			tf: "acos"
		}
	],
	add: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "alpha",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"add"
			],
			name: "add",
			tfjs: "add",
			tf: "add"
		}
	],
	asin: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"asin"
			],
			name: "asin",
			tfjs: "asin",
			tf: "asin"
		}
	],
	atan: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"atan"
			],
			name: "atan",
			tfjs: "atan",
			tf: "atan"
		}
	],
	atan2: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"atan2"
			],
			name: "atan2",
			tfjs: "atan2",
			tf: "atan2"
		}
	],
	ceil: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"ceil"
			],
			name: "ceil",
			tfjs: "ceil",
			tf: "ceil"
		}
	],
	cos: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"cos"
			],
			name: "cos",
			tfjs: "cos",
			tf: "cos"
		}
	],
	cosh: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"cosh"
			],
			name: "cosh",
			tfjs: "cosh",
			tf: "cosh"
		}
	],
	div: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"div"
			],
			name: "div",
			tfjs: "div"
		}
	],
	erf: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"erf"
			],
			name: "erf",
			tfjs: "erf",
			tf: "erf"
		}
	],
	exp: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"exp"
			],
			name: "exp",
			tfjs: "exp",
			tf: "exp"
		}
	],
	expm1: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"expm1"
			],
			name: "expm1",
			tfjs: "expm1",
			tf: "expm1"
		}
	],
	floor: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"floor"
			],
			name: "floor",
			tfjs: "floor",
			tf: "floor"
		}
	],
	imag: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "input",
					tf: "input"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"imag"
			],
			name: "imag",
			tfjs: "imag",
			tf: "imag"
		}
	],
	log: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"log"
			],
			name: "log",
			tfjs: "log",
			tf: "log"
		}
	],
	log1p: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"log1p"
			],
			name: "log1p",
			tfjs: "log1p",
			tf: "log1p"
		}
	],
	mul: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"mul"
			],
			name: "mul",
			tfjs: "mul"
		}
	],
	neg: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"neg"
			],
			name: "neg",
			tfjs: "neg"
		}
	],
	pow: [
		{
			args: [
				{
					name: "self",
					kwarg: false,
					opt: false
				},
				{
					name: "exponent",
					kwarg: false,
					opt: false
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"pow"
			],
			name: "pow",
			tfjs: "pow",
			tf: "pow"
		}
	],
	real: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "input",
					tf: "input"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"real"
			],
			name: "real",
			tfjs: "real",
			tf: "real"
		}
	],
	reciprocal: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"reciprocal"
			],
			name: "reciprocal",
			tfjs: "reciprocal",
			tf: "reciprocal"
		}
	],
	round: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"round"
			],
			name: "round",
			tfjs: "round",
			tf: "round"
		}
	],
	rsqrt: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"rsqrt"
			],
			name: "rsqrt",
			tfjs: "rsqrt",
			tf: "rsqrt"
		}
	],
	sign: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"sign"
			],
			name: "sign",
			tfjs: "sign",
			tf: "sign"
		}
	],
	sin: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"sin"
			],
			name: "sin",
			tfjs: "sin",
			tf: "sin"
		}
	],
	sinh: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"sinh"
			],
			name: "sinh",
			tfjs: "sinh",
			tf: "sinh"
		}
	],
	sqrt: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"sqrt"
			],
			name: "sqrt",
			tfjs: "sqrt",
			tf: "sqrt"
		}
	],
	tan: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"tan"
			],
			name: "tan",
			tfjs: "tan",
			tf: "tan"
		}
	],
	argmax: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"argmax"
			],
			name: "argmax",
			tfjs: "argmax",
			tf: "argmax"
		}
	],
	argmin: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"argmin"
			],
			name: "argmin",
			tfjs: "argmin",
			tf: "argmin"
		}
	],
	logsumexp: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"logsumexp"
			],
			name: "logsumexp",
			tfjs: "logsumexp"
		}
	],
	mean: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"mean"
			],
			name: "mean",
			tfjs: "mean",
			tf: "mean"
		}
	],
	norm: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "p",
					kwarg: true,
					opt: true
				},
				{
					name: "dim",
					kwarg: true,
					opt: true,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"norm"
			],
			name: "norm",
			tfjs: "norm",
			tf: "norm"
		}
	],
	prod: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "keepdim",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"prod"
			],
			name: "prod",
			tfjs: "prod",
			tf: "prod"
		}
	],
	eq: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"eq"
			],
			name: "eq",
			tfjs: "equal"
		}
	],
	equal: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				}
			],
			attrs: [
				"torch",
				"equal"
			],
			name: "equal",
			tfjs: "equal",
			tf: "equal"
		}
	],
	gt: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"gt"
			],
			name: "gt",
			tfjs: "greater"
		}
	],
	isfinite: [
		{
			args: [
			],
			attrs: [
				"torch",
				"isfinite"
			],
			name: "isfinite",
			tfjs: "isfinite"
		}
	],
	isinf: [
		{
			args: [
				{
					name: "tensor",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"torch",
				"isinf"
			],
			name: "isinf",
			tfjs: "isinf"
		}
	],
	isnan: [
		{
			args: [
			],
			attrs: [
				"torch",
				"isnan"
			],
			name: "isnan",
			tfjs: "isnan"
		}
	],
	max: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"max"
			],
			name: "max",
			tfjs: "max",
			tf: "max"
		}
	],
	min: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"min"
			],
			name: "min",
			tfjs: "min",
			tf: "min"
		}
	],
	topk: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "k",
					kwarg: false,
					opt: false,
					tfjs: "k"
				},
				{
					name: "dim",
					kwarg: true,
					opt: true,
					tfjs: "axis"
				},
				{
					name: "largest",
					kwarg: true,
					opt: true
				},
				{
					name: "sorted",
					kwarg: true,
					opt: true,
					tfjs: "sorted"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"topk"
			],
			name: "topk",
			tfjs: "topk"
		}
	],
	fft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "input",
					tf: "input"
				},
				{
					name: "signal_ndim",
					kwarg: false,
					opt: false
				},
				{
					name: "normalized",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"fft"
			],
			name: "fft",
			tfjs: "fft",
			tf: "fft"
		}
	],
	ifft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "input",
					tf: "input"
				},
				{
					name: "signal_ndim",
					kwarg: false,
					opt: false
				},
				{
					name: "normalized",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"ifft"
			],
			name: "ifft",
			tfjs: "ifft",
			tf: "ifft"
		}
	],
	rfft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "input"
				},
				{
					name: "signal_ndim",
					kwarg: false,
					opt: false
				},
				{
					name: "normalized",
					kwarg: true,
					opt: true
				},
				{
					name: "onesided",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"rfft"
			],
			name: "rfft",
			tfjs: "rfft",
			tf: "rfft"
		}
	],
	irfft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "input"
				},
				{
					name: "signal_ndim",
					kwarg: false,
					opt: false
				},
				{
					name: "normalized",
					kwarg: true,
					opt: true
				},
				{
					name: "onesided",
					kwarg: true,
					opt: true
				},
				{
					name: "signal_sizes",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"irfft"
			],
			name: "irfft",
			tfjs: "irfft",
			tf: "irfft"
		}
	],
	stft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "n_fft",
					kwarg: false,
					opt: false
				},
				{
					name: "hop_length",
					kwarg: true,
					opt: true
				},
				{
					name: "win_length",
					kwarg: true,
					opt: true
				},
				{
					name: "window",
					kwarg: true,
					opt: true
				},
				{
					name: "center",
					kwarg: true,
					opt: true
				},
				{
					name: "pad_mode",
					kwarg: true,
					opt: true
				},
				{
					name: "normalized",
					kwarg: true,
					opt: true
				},
				{
					name: "onesided",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"stft"
			],
			name: "stft",
			tfjs: "stft",
			tf: "stft"
		}
	],
	cumsum: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "dim",
					kwarg: false,
					opt: false,
					tfjs: "axis"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				},
				{
					name: "dtype",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"cumsum"
			],
			name: "cumsum",
			tfjs: "cumsum",
			tf: "cumsum"
		}
	],
	flatten: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "start_dim",
					kwarg: true,
					opt: true
				},
				{
					name: "end_dim",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"flatten"
			],
			name: "flatten",
			tfjs: "flatten",
			tf: "flatten"
		}
	],
	dot: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "tensor",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"torch",
				"dot"
			],
			name: "dot",
			tfjs: "dot",
			tf: "dot"
		}
	],
	matmul: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"matmul"
			],
			name: "matmul",
			tfjs: "matmul",
			tf: "matmul"
		}
	],
	qr: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "a",
					tf: "input"
				},
				{
					name: "some",
					kwarg: true,
					opt: true
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"qr"
			],
			name: "qr",
			tfjs: "qr",
			tf: "qr"
		}
	],
	truediv: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					tfjs: "x"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "y"
				},
				{
					name: "out",
					kwarg: true,
					opt: true
				}
			],
			attrs: [
				"torch",
				"div"
			],
			name: "Truediv",
			tfjs: "div",
			tf: "truediv"
		}
	],
	sub: [
		{
			args: [
				{
					name: "value",
					kwarg: false,
					opt: false,
					tfjs: "a"
				},
				{
					name: "other",
					kwarg: false,
					opt: false,
					tfjs: "b"
				}
			],
			attrs: [
				"torch",
				"sub"
			],
			name: "sub",
			tfjs: "sub"
		}
	]
};
var tfjs = {
	tensor: [
		{
			args: [
				{
					name: "values",
					kwarg: false,
					opt: false
				},
				{
					name: "shape",
					kwarg: false,
					opt: true
				},
				{
					name: "dtype",
					kwarg: false,
					opt: true,
					torch: "dtype",
					tf: "dtype"
				}
			],
			attrs: [
				"tf",
				"tensor"
			],
			name: "tensor",
			torch: "tensor",
			tf: "tensor"
		}
	],
	eye: [
		{
			args: [
				{
					name: "numrows",
					kwarg: false,
					opt: false
				},
				{
					name: "numcolumns",
					kwarg: false,
					opt: true
				},
				{
					name: "batchshape",
					kwarg: false,
					opt: true
				},
				{
					name: "dtype",
					kwarg: false,
					opt: true,
					torch: "dtype",
					tf: "dtype"
				}
			],
			attrs: [
				"tf",
				"eye"
			],
			name: "eye",
			torch: "eye",
			tf: "eye"
		}
	],
	imag: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					torch: "input",
					tf: "input"
				}
			],
			attrs: [
				"tf",
				"imag"
			],
			name: "imag",
			torch: "imag",
			tf: "imag"
		}
	],
	linspace: [
		{
			args: [
				{
					name: "start",
					kwarg: false,
					opt: false,
					torch: "start",
					tf: "start"
				},
				{
					name: "stop",
					kwarg: false,
					opt: false,
					tf: "stop"
				},
				{
					name: "num",
					kwarg: false,
					opt: false,
					tf: "num"
				}
			],
			attrs: [
				"tf",
				"linspace"
			],
			name: "linspace",
			torch: "linspace",
			tf: "linspace"
		}
	],
	ones: [
		{
			args: [
			],
			attrs: [
				"tf",
				"initializers",
				"ones"
			],
			name: "ones",
			torch: "ones",
			tf: "ones"
		}
	],
	range: [
		{
			args: [
				{
					name: "start",
					kwarg: false,
					opt: false,
					torch: "start"
				},
				{
					name: "stop",
					kwarg: false,
					opt: false
				},
				{
					name: "step",
					kwarg: false,
					opt: true,
					torch: "step"
				},
				{
					name: "dtype",
					kwarg: false,
					opt: true,
					torch: "dtype",
					tf: "dtype"
				}
			],
			attrs: [
				"tf",
				"range"
			],
			name: "range",
			torch: "range",
			tf: "range"
		}
	],
	real: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					torch: "input",
					tf: "input"
				}
			],
			attrs: [
				"tf",
				"real"
			],
			name: "real",
			torch: "real",
			tf: "real"
		}
	],
	zeros: [
		{
			args: [
			],
			attrs: [
				"tf",
				"initializers",
				"zeros"
			],
			name: "zeros",
			torch: "zeros",
			tf: "zeros"
		}
	],
	flatten: [
		{
			args: [
				{
					name: "arr",
					kwarg: false,
					opt: false
				},
				{
					name: "result",
					kwarg: false,
					opt: true
				},
				{
					name: "skiptypedarray",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"util",
				"flatten"
			],
			name: "flatten",
			torch: "flatten",
			tf: "flatten"
		}
	],
	reshape: [
		{
			args: [
				{
					name: "args",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"layers",
				"reshape"
			],
			name: "reshape",
			torch: "reshape",
			tf: "reshape"
		}
	],
	cumsum: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "exclusive",
					kwarg: false,
					opt: true
				},
				{
					name: "reverse",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"cumsum"
			],
			name: "cumsum",
			torch: "cumsum",
			tf: "cumsum"
		}
	],
	squeeze: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				}
			],
			attrs: [
				"tf",
				"squeeze"
			],
			name: "squeeze",
			torch: "squeeze",
			tf: "squeeze"
		}
	],
	pad: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "paddings",
					kwarg: false,
					opt: false,
					tf: "paddings"
				},
				{
					name: "constantvalue",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"pad"
			],
			name: "pad",
			torch: "pad",
			tf: "pad"
		}
	],
	gather: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "indices",
					kwarg: false,
					opt: false,
					tf: "indices"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				}
			],
			attrs: [
				"tf",
				"gather"
			],
			name: "gather",
			torch: "gather",
			tf: "gather"
		}
	],
	split: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "numorsizesplits",
					kwarg: false,
					opt: false
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				}
			],
			attrs: [
				"tf",
				"split"
			],
			name: "split",
			torch: "split",
			tf: "split"
		}
	],
	stack: [
		{
			args: [
				{
					name: "tensors",
					kwarg: false,
					opt: false,
					torch: "tensors"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				}
			],
			attrs: [
				"tf",
				"stack"
			],
			name: "stack",
			torch: "stack",
			tf: "stack"
		}
	],
	multinomial: [
		{
			args: [
				{
					name: "logits",
					kwarg: false,
					opt: false
				},
				{
					name: "numsamples",
					kwarg: false,
					opt: false
				},
				{
					name: "seed",
					kwarg: false,
					opt: true
				},
				{
					name: "normalized",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"multinomial"
			],
			name: "multinomial",
			torch: "multinomial"
		}
	],
	add: [
		{
			args: [
				{
					name: "a",
					kwarg: false,
					opt: false
				},
				{
					name: "b",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"add"
			],
			name: "add",
			torch: "add",
			tf: "add"
		}
	],
	elu: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"elu"
			],
			name: "elu",
			torch: "elu",
			tf: "elu"
		}
	],
	prelu: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "alpha",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"prelu"
			],
			name: "prelu",
			torch: "prelu",
			tf: "prelu"
		}
	],
	relu: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"relu"
			],
			name: "relu",
			torch: "relu",
			tf: "relu"
		}
	],
	softmax: [
		{
			args: [
				{
					name: "logits",
					kwarg: false,
					opt: false
				},
				{
					name: "dim",
					kwarg: false,
					opt: true,
					torch: "dim"
				}
			],
			attrs: [
				"tf",
				"softmax"
			],
			name: "softmax",
			torch: "softmax",
			tf: "softmax"
		}
	],
	dropout: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "rate",
					kwarg: false,
					opt: false
				},
				{
					name: "noiseshape",
					kwarg: false,
					opt: true
				},
				{
					name: "seed",
					kwarg: false,
					opt: true,
					tf: "seed"
				}
			],
			attrs: [
				"tf",
				"dropout"
			],
			name: "dropout",
			torch: "dropout",
			tf: "dropout"
		}
	],
	embedding: [
		{
			args: [
				{
					name: "args",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"layers",
				"embedding"
			],
			name: "embedding",
			torch: "embedding",
			tf: "embedding"
		}
	],
	conv1d: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "filter",
					kwarg: false,
					opt: false
				},
				{
					name: "stride",
					kwarg: false,
					opt: false,
					torch: "stride"
				},
				{
					name: "pad",
					kwarg: false,
					opt: false
				},
				{
					name: "dataformat",
					kwarg: false,
					opt: true
				},
				{
					name: "dilation",
					kwarg: false,
					opt: true,
					torch: "dilation"
				},
				{
					name: "dimroundingmode",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"conv1d"
			],
			name: "conv1d",
			torch: "conv1d",
			tf: "conv1d"
		}
	],
	conv2d: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "filter",
					kwarg: false,
					opt: false
				},
				{
					name: "strides",
					kwarg: false,
					opt: false,
					tf: "strides"
				},
				{
					name: "pad",
					kwarg: false,
					opt: false
				},
				{
					name: "dataformat",
					kwarg: false,
					opt: true
				},
				{
					name: "dilations",
					kwarg: false,
					opt: true
				},
				{
					name: "dimroundingmode",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"conv2d"
			],
			name: "conv2d",
			torch: "conv2d",
			tf: "conv2d"
		}
	],
	conv3d: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "filter",
					kwarg: false,
					opt: false
				},
				{
					name: "strides",
					kwarg: false,
					opt: false,
					tf: "strides"
				},
				{
					name: "pad",
					kwarg: false,
					opt: false
				},
				{
					name: "dataformat",
					kwarg: false,
					opt: true
				},
				{
					name: "dilations",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"conv3d"
			],
			name: "conv3d",
			torch: "conv3d",
			tf: "conv3d"
		}
	],
	dot: [
		{
			args: [
				{
					name: "t1",
					kwarg: false,
					opt: false
				},
				{
					name: "t2",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"dot"
			],
			name: "dot",
			torch: "dot",
			tf: "dot"
		}
	],
	sub: [
		{
			args: [
				{
					name: "a",
					kwarg: false,
					opt: false
				},
				{
					name: "b",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"sub"
			],
			name: "sub",
			torch: "sub"
		}
	],
	mul: [
		{
			args: [
				{
					name: "a",
					kwarg: false,
					opt: false
				},
				{
					name: "b",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"mul"
			],
			name: "mul",
			torch: "mul"
		}
	],
	div: [
		{
			args: [
				{
					name: "a",
					kwarg: false,
					opt: false
				},
				{
					name: "b",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"div"
			],
			name: "div",
			torch: "div"
		}
	],
	pow: [
		{
			args: [
				{
					name: "base",
					kwarg: false,
					opt: false
				},
				{
					name: "exp",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"pow"
			],
			name: "pow",
			torch: "pow",
			tf: "pow"
		}
	],
	abs: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"abs"
			],
			name: "abs",
			torch: "abs",
			tf: "abs"
		}
	],
	acos: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"acos"
			],
			name: "acos",
			torch: "acos",
			tf: "acos"
		}
	],
	asin: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"asin"
			],
			name: "asin",
			torch: "asin",
			tf: "asin"
		}
	],
	atan: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"atan"
			],
			name: "atan",
			torch: "atan",
			tf: "atan"
		}
	],
	atan2: [
		{
			args: [
				{
					name: "a",
					kwarg: false,
					opt: false
				},
				{
					name: "b",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"atan2"
			],
			name: "atan2",
			torch: "atan2",
			tf: "atan2"
		}
	],
	ceil: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"ceil"
			],
			name: "ceil",
			torch: "ceil",
			tf: "ceil"
		}
	],
	cos: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"cos"
			],
			name: "cos",
			torch: "cos",
			tf: "cos"
		}
	],
	cosh: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"cosh"
			],
			name: "cosh",
			torch: "cosh",
			tf: "cosh"
		}
	],
	erf: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"erf"
			],
			name: "erf",
			torch: "erf",
			tf: "erf"
		}
	],
	exp: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"exp"
			],
			name: "exp",
			torch: "exp",
			tf: "exp"
		}
	],
	expm1: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"expm1"
			],
			name: "expm1",
			torch: "expm1",
			tf: "expm1"
		}
	],
	floor: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"floor"
			],
			name: "floor",
			torch: "floor",
			tf: "floor"
		}
	],
	isfinite: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"isFinite"
			],
			name: "isFinite",
			torch: "isfinite"
		}
	],
	isinf: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"isInf"
			],
			name: "isInf",
			torch: "isinf"
		}
	],
	isnan: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"isNaN"
			],
			name: "isNaN",
			torch: "isnan"
		}
	],
	log: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"log"
			],
			name: "log",
			torch: "log",
			tf: "log"
		}
	],
	log1p: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"log1p"
			],
			name: "log1p",
			torch: "log1p",
			tf: "log1p"
		}
	],
	logsigmoid: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"logSigmoid"
			],
			name: "logSigmoid",
			torch: "logsigmoid"
		}
	],
	neg: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"neg"
			],
			name: "neg",
			torch: "neg"
		}
	],
	reciprocal: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"reciprocal"
			],
			name: "reciprocal",
			torch: "reciprocal",
			tf: "reciprocal"
		}
	],
	relu6: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"relu6"
			],
			name: "relu6",
			torch: "relu6",
			tf: "relu6"
		}
	],
	round: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"round"
			],
			name: "round",
			torch: "round",
			tf: "round"
		}
	],
	rsqrt: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"rsqrt"
			],
			name: "rsqrt",
			torch: "rsqrt",
			tf: "rsqrt"
		}
	],
	selu: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"selu"
			],
			name: "selu",
			torch: "selu",
			tf: "selu"
		}
	],
	sigmoid: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"sigmoid"
			],
			name: "sigmoid",
			torch: "sigmoid",
			tf: "sigmoid"
		}
	],
	sign: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"sign"
			],
			name: "sign",
			torch: "sign",
			tf: "sign"
		}
	],
	sin: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"sin"
			],
			name: "sin",
			torch: "sin",
			tf: "sin"
		}
	],
	sinh: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"sinh"
			],
			name: "sinh",
			torch: "sinh",
			tf: "sinh"
		}
	],
	softplus: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"softplus"
			],
			name: "softplus",
			torch: "softplus",
			tf: "softplus"
		}
	],
	sqrt: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"sqrt"
			],
			name: "sqrt",
			torch: "sqrt",
			tf: "sqrt"
		}
	],
	tan: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"tan"
			],
			name: "tan",
			torch: "tan",
			tf: "tan"
		}
	],
	tanh: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				}
			],
			attrs: [
				"tf",
				"tanh"
			],
			name: "tanh",
			torch: "tanh",
			tf: "tanh"
		}
	],
	matmul: [
		{
			args: [
				{
					name: "a",
					kwarg: false,
					opt: false,
					tf: "a"
				},
				{
					name: "b",
					kwarg: false,
					opt: false,
					tf: "b"
				},
				{
					name: "transposea",
					kwarg: false,
					opt: true
				},
				{
					name: "transposeb",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"matMul"
			],
			name: "matMul",
			torch: "matmul",
			tf: "matmul"
		}
	],
	norm: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "ord",
					kwarg: false,
					opt: true,
					tf: "ord"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true,
					tf: "keepdims"
				}
			],
			attrs: [
				"tf",
				"norm"
			],
			name: "norm",
			torch: "norm",
			tf: "norm"
		}
	],
	transpose: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "perm",
					kwarg: false,
					opt: true,
					tf: "perm"
				}
			],
			attrs: [
				"tf",
				"transpose"
			],
			name: "transpose",
			torch: "t",
			tf: "transpose"
		}
	],
	all: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true,
					tf: "keepdims"
				}
			],
			attrs: [
				"tf",
				"all"
			],
			name: "all",
			torch: "all",
			tf: "all"
		}
	],
	any: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true,
					tf: "keepdims"
				}
			],
			attrs: [
				"tf",
				"any"
			],
			name: "any",
			torch: "any",
			tf: "any"
		}
	],
	argmax: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				}
			],
			attrs: [
				"tf",
				"argMax"
			],
			name: "argMax",
			torch: "argmax",
			tf: "argmax"
		}
	],
	argmin: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				}
			],
			attrs: [
				"tf",
				"argMin"
			],
			name: "argMin",
			torch: "argmin",
			tf: "argmin"
		}
	],
	logsumexp: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "axis",
					kwarg: false,
					opt: true
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"logSumExp"
			],
			name: "logSumExp",
			torch: "logsumexp"
		}
	],
	max: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true,
					tf: "keepdims"
				}
			],
			attrs: [
				"tf",
				"max"
			],
			name: "max",
			torch: "max",
			tf: "max"
		}
	],
	mean: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true,
					tf: "keepdims"
				}
			],
			attrs: [
				"tf",
				"mean"
			],
			name: "mean",
			torch: "mean",
			tf: "mean"
		}
	],
	min: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true,
					tf: "keepdims"
				}
			],
			attrs: [
				"tf",
				"min"
			],
			name: "min",
			torch: "min",
			tf: "min"
		}
	],
	prod: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true,
					tf: "keepdims"
				}
			],
			attrs: [
				"tf",
				"prod"
			],
			name: "prod",
			torch: "prod",
			tf: "prod"
		}
	],
	sum: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false,
					tf: "x"
				},
				{
					name: "axis",
					kwarg: false,
					opt: true,
					tf: "axis"
				},
				{
					name: "keepdims",
					kwarg: false,
					opt: true,
					tf: "keepdims"
				}
			],
			attrs: [
				"tf",
				"sum"
			],
			name: "sum",
			torch: "sum",
			tf: "sum"
		}
	],
	equal: [
		{
			args: [
				{
					name: "a",
					kwarg: false,
					opt: false
				},
				{
					name: "b",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"equal"
			],
			name: "equal",
			torch: "eq",
			tf: "equal"
		}
	],
	greater: [
		{
			args: [
				{
					name: "a",
					kwarg: false,
					opt: false
				},
				{
					name: "b",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"greater"
			],
			name: "greater",
			torch: "gt",
			tf: "greater"
		}
	],
	where: [
		{
			args: [
				{
					name: "condition",
					kwarg: false,
					opt: false,
					torch: "condition",
					tf: "condition"
				},
				{
					name: "a",
					kwarg: false,
					opt: false
				},
				{
					name: "b",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"where"
			],
			name: "where",
			torch: "where",
			tf: "where"
		}
	],
	topk: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "k",
					kwarg: false,
					opt: true,
					torch: "k"
				},
				{
					name: "sorted",
					kwarg: false,
					opt: true,
					torch: "sorted"
				}
			],
			attrs: [
				"tf",
				"topk"
			],
			name: "topk",
			torch: "topk"
		}
	],
	fft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					torch: "input",
					tf: "input"
				}
			],
			attrs: [
				"tf",
				"spectral",
				"fft"
			],
			name: "fft",
			torch: "fft",
			tf: "fft"
		}
	],
	ifft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					torch: "input",
					tf: "input"
				}
			],
			attrs: [
				"tf",
				"spectral",
				"ifft"
			],
			name: "ifft",
			torch: "ifft",
			tf: "ifft"
		}
	],
	irfft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					torch: "input"
				}
			],
			attrs: [
				"tf",
				"spectral",
				"irfft"
			],
			name: "irfft",
			torch: "irfft",
			tf: "irfft"
		}
	],
	rfft: [
		{
			args: [
				{
					name: "input",
					kwarg: false,
					opt: false,
					torch: "input"
				},
				{
					name: "fftlength",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"spectral",
				"rfft"
			],
			name: "rfft",
			torch: "rfft",
			tf: "rfft"
		}
	],
	stft: [
		{
			args: [
				{
					name: "signal",
					kwarg: false,
					opt: false
				},
				{
					name: "framelength",
					kwarg: false,
					opt: false
				},
				{
					name: "framestep",
					kwarg: false,
					opt: false
				},
				{
					name: "fftlength",
					kwarg: false,
					opt: true
				},
				{
					name: "windowfn",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"signal",
				"stft"
			],
			name: "stft",
			torch: "stft",
			tf: "stft"
		}
	],
	qr: [
		{
			args: [
				{
					name: "x",
					kwarg: false,
					opt: false
				},
				{
					name: "fullmatrices",
					kwarg: false,
					opt: true
				}
			],
			attrs: [
				"tf",
				"linalg",
				"qr"
			],
			name: "qr",
			torch: "qr",
			tf: "qr"
		}
	],
	grad: [
		{
			args: [
				{
					name: "f",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"grad"
			],
			name: "grad",
			torch: "grad"
		}
	],
	identity: [
		{
			args: [
				{
					name: "args",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"tf",
				"initializers",
				"identity"
			],
			name: "identity",
			torch: "identity",
			tf: "identity"
		}
	],
	take: [
		{
			args: [
				{
					name: "count",
					kwarg: false,
					opt: false
				}
			],
			attrs: [
				"take"
			],
			name: "take",
			torch: "take"
		}
	]
};
var mappedCommands = {
	torch: torch,
	tfjs: tfjs
};

var MISSING_ARGUMENTS = "Translation must receive an object containing \"function_name\", \"args\", and \"kwargs\"";
var NOT_TRANSLATED = "Translation must be completed before executing";
var translationMissing = function translationMissing(c) {
  return "Translation for the command ".concat(c, " is not currently supported");
};

var Command =
/*#__PURE__*/
function () {
  function Command(functionName, args, kwargs, execFn) {
    _classCallCheck$1(this, Command);

    if (!functionName || !args || !kwargs) {
      throw new Error(MISSING_ARGUMENTS);
    }

    this.functionName = functionName;
    this.args = args;
    this.kwargs = kwargs;
    this.execFn = execFn || undefined;
  }

  _createClass$1(Command, [{
    key: "executeRoutine",
    value: function executeRoutine() {
      if (typeof this.execFn === 'undefined') {
        throw new TypeError(NOT_TRANSLATED);
      }

      return this.execFn.apply(this, _toConsumableArray$1(this.args));
    }
  }]);

  return Command;
}();

var CUSTOM_IMPLEMENTATIONS = {
  torch: {
    "float": function float(cmd) {
      return {
        command: new Command('cast', [].concat(_toConsumableArray$1(cmd.args), ['float32']), cmd.kwargs),
        attrs: ['tf', 'cast']
      };
    }
  }
};

var Threepio =
/*#__PURE__*/
function () {
  function Threepio(from, to, framework, version) {
    _classCallCheck$1(this, Threepio);

    this.fromLang = from;
    this.toLang = to;
    this.version = version;
    this.mappedCommands = mappedCommands;
    this.framework = framework;
  }

  _createClass$1(Threepio, [{
    key: "_normalizeFunctionName",
    value: function _normalizeFunctionName(name, lang) {
      var result = name.match(NORMALIZATION_REGEX).join('').toLowerCase();

      if (result in this.mappedCommands[lang]) {
        return result;
      }

      throw new Error(translationMissing(name));
    }
  }, {
    key: "_orderArgs",
    value: function _orderArgs(cmd, fromInfo, toInfo) {
      var _this = this;

      var newArgs = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var _step$value = _slicedToArray$1(_step.value, 2),
              i = _step$value[0],
              arg = _step$value[1];

          var fArg = fromInfo.args[i];
          var tArgIndex = toInfo.args.findIndex(function (a) {
            return a.name === fArg[_this.toLang];
          });

          if (tArgIndex === -1) {
            newArgs.push(arg);
            return "continue";
          }

          newArgs.splice(tArgIndex, 0, arg);
        };

        for (var _iterator = cmd.args.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ret = _loop();

          if (_ret === "continue") continue;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _loop2 = function _loop2() {
        var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2),
            k = _Object$entries$_i[0],
            v = _Object$entries$_i[1];

        var fArg = fromInfo.args.filter(function (a) {
          return a.name === k;
        })[0];
        var tArgIndex = toInfo.args.findIndex(function (a) {
          return a.name === fArg[_this.toLang];
        });

        if (tArgIndex === -1) {
          // throw warning for kwarg translation missing
          console.warn("Unable to translare kwarg ".concat(k, " for command ").concat(cmd.functionName));
          return "continue";
        }

        newArgs.splice(tArgIndex, 0, v);
      };

      for (var _i = 0, _Object$entries = Object.entries(cmd.kwargs); _i < _Object$entries.length; _i++) {
        var _ret2 = _loop2();

        if (_ret2 === "continue") continue;
      }

      return newArgs;
    }
  }, {
    key: "translate",
    value: function translate(cmd) {
      var name;
      var args;
      var attrs;

      if (cmd.functionName in CUSTOM_IMPLEMENTATIONS[this.fromLang]) {
        var translation = CUSTOM_IMPLEMENTATIONS[this.fromLang][cmd.functionName](cmd);
        name = translation.command.functionName;
        attrs = translation.attrs;
        args = translation.command.args;
      } else {
        var fromInfo = this.mappedCommands[this.fromLang][this._normalizeFunctionName(cmd.functionName, this.fromLang)][0];

        var toInfo = this.mappedCommands[this.toLang][this._normalizeFunctionName(fromInfo[this.toLang], this.toLang)][0];

        name = toInfo.name;
        args = this._orderArgs(cmd, fromInfo, toInfo);
        attrs = _toConsumableArray$1(toInfo.attrs);
      }

      attrs.shift();
      var translatedCmd = this.framework;

      while (attrs.length > 0) {
        translatedCmd = translatedCmd[attrs.shift()];
      }

      return new Command(name, args, {}, translatedCmd);
    }
  }]);

  return Threepio;
}();

var threepio = new Threepio('torch', 'tfjs', tf);
var ComputationAction = /*#__PURE__*/function () {
  function ComputationAction(command, target, args, kwargs, returnIds, returnPlaceholderIds) {
    _classCallCheck(this, ComputationAction);

    this.command = command;
    this.target = target;
    this.args = args;
    this.kwargs = kwargs;
    this.returnIds = returnIds;
    this.returnPlaceholderIds = returnPlaceholderIds;
  }

  _createClass(ComputationAction, [{
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(scope) {
        var haveValuesForAllArgs, toTFTensor, getTensorByRef, pullTensorsFromArgs, args, self, resolvedArgs, functionName, _args, cmd, translation;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // A helper function for helping us determine if all PointerTensors/Placeholders inside of "this.args" also exist as tensors inside of "objects"
                haveValuesForAllArgs = function haveValuesForAllArgs(args) {
                  var enoughInfo = true;
                  args.forEach(function (arg) {
                    if (arg instanceof PointerTensor && !scope.has(arg.idAtLocation) || arg instanceof Placeholder && !scope.has(arg.id) || arg instanceof PlaceholderId && !scope.has(arg.id)) {
                      enoughInfo = false;
                    }
                  });
                  return enoughInfo;
                };

                toTFTensor = function toTFTensor(tensor) {
                  if (tensor instanceof tf.Tensor) {
                    return tensor;
                  } else if (tensor instanceof TorchTensor) {
                    return tensor.toTfTensor();
                  } else if (tensor instanceof TorchParameter) {
                    return tensor.tensor.toTfTensor();
                  } else if (typeof tensor === 'number') {
                    return tensor;
                  }

                  return null;
                };

                getTensorByRef = function getTensorByRef(reference) {
                  var tensor = null;

                  if (reference instanceof PlaceholderId) {
                    tensor = scope.get(reference.id);
                  } else if (reference instanceof Placeholder) {
                    tensor = scope.get(reference.id);
                  } else if (reference instanceof PointerTensor) {
                    tensor = scope.get(reference.idAtLocation);
                  }

                  tensor = toTFTensor(tensor);
                  return tensor;
                }; // A helper function for helping us get all operable tensors from PointerTensors inside of "this._args"


                pullTensorsFromArgs = function pullTensorsFromArgs(args) {
                  var resolvedArgs = [];
                  args.forEach(function (arg) {
                    var tensorByRef = getTensorByRef(arg);

                    if (tensorByRef) {
                      resolvedArgs.push(toTFTensor(tensorByRef));
                    } else {
                      resolvedArgs.push(toTFTensor(arg));
                    }
                  });
                  return resolvedArgs;
                }; //worker.logger.log(`Given command: ${this.command}, converted command: ${command} + ${JSON.stringify(preArgs)} + ${JSON.stringify(postArgs)}`);


                args = this.args;
                self = null;

                if (!this.target) {
                  _context.next = 10;
                  break;
                }

                // resolve "self" if it's present
                self = getTensorByRef(this.target);

                if (self) {
                  _context.next = 10;
                  break;
                }

                throw new Error(MISSING_VARIABLE());

              case 10:
                if (haveValuesForAllArgs(args)) {
                  _context.next = 12;
                  break;
                }

                throw new Error(MISSING_VARIABLE());

              case 12:
                resolvedArgs = pullTensorsFromArgs(args); // hack to support inplace tensor operation
                // TODO move to Threepio?

                if (this.command === 'add_') {
                  this.returnPlaceholderIds[0] = this.target;
                }

                _context.prev = 14;
                // Threepio
                functionName = this.command.split('.').pop();

                if (!(functionName === 'sum')) {
                  _context.next = 18;
                  break;
                }

                throw new Error("Threepio sum doesn't support keepdim");

              case 18:
                _args = self ? [self].concat(_toConsumableArray(resolvedArgs)) : _toConsumableArray(resolvedArgs);
                cmd = new Command(functionName, _args, this.kwargs);
                translation = threepio.translate(cmd);
                return _context.abrupt("return", translation.executeRoutine());

              case 24:
                _context.prev = 24;
                _context.t0 = _context["catch"](14);
                return _context.abrupt("return", legacyTorchToTF(this.command, self, resolvedArgs, this.kwargs));

              case 27:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[14, 24]]);
      }));

      function execute(_x) {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
  }], [{
    key: "unbufferize",
    value: function unbufferize$1(worker, pb) {
      return new ComputationAction(pb.command, unbufferize(worker, pb[pb.target]), unbufferize(worker, pb.args), unbufferize(worker, pb.kwargs), unbufferize(worker, pb.return_ids), unbufferize(worker, pb.return_placeholder_ids));
    }
  }]);

  return ComputationAction;
}();
/**
 * Legacy translation layer to temporarily support ops missing in Threepio
 * TODO remove it
 * @param torchCmd
 * @param self
 * @param args
 * @param kwargs
 * @returns {Promise<*>}
 */

var legacyTorchToTF = function legacyTorchToTF(torchCmd, self, args, kwargs) {
  var cmdMap = {
    dim: '@rank',
    // method to property mapping
    sum: ['sum', [], [kwargs['dim'], kwargs['keepdim']]],
    copy: 'clone',
    __rtruediv__: function __rtruediv__(self, args) {
      // rdiv is div with reversed args
      return tf.div(args[0], self);
    }
  };
  var preArgs = [];
  var postArgs = [];
  var command = '';
  var property = '';

  if (torchCmd in cmdMap) {
    command = cmdMap[torchCmd];

    if (typeof command === 'function') {
      return command(self, args, kwargs);
    }

    if (Array.isArray(command)) {
      preArgs = command[1] || [];
      postArgs = command[2] || [];
      command = command[0];
    }
  }

  if (command.match(/^@/)) {
    // this is a property on self
    property = command.substr(1);
    command = '';
  }

  if (command) {
    if (!Object.hasOwnProperty.call(tf, command)) {
      throw new Error(CANNOT_FIND_COMMAND(command));
    }

    var selfArg = self ? [self] : [];
    return tf[command].apply(tf, selfArg.concat(_toConsumableArray(preArgs), _toConsumableArray(args), _toConsumableArray(postArgs)));
  } else if (property) {
    if (!(property in self)) {
      throw new Error(CANNOT_FIND_COMMAND("object.".concat(property)));
    }

    return self[property];
  } else {
    throw new Error(CANNOT_FIND_COMMAND(torchCmd));
  }
};

var PB_CLASS_MAP, PB_TO_UNBUFFERIZER; // because of cyclic dependencies between Protocol/etc modules and protobuf module
// Protocol/etc classes are undefined at the moment when this module is imported

var initMappings = function initMappings() {
  PB_CLASS_MAP = [[Protocol, protobuf$1.syft_proto.execution.v1.Protocol], [Plan, protobuf$1.syft_proto.execution.v1.Plan], [Role, protobuf$1.syft_proto.execution.v1.Role], [State$1, protobuf$1.syft_proto.execution.v1.State], [ComputationAction, protobuf$1.syft_proto.execution.v1.ComputationAction], [Placeholder, protobuf$1.syft_proto.execution.v1.Placeholder], [PlaceholderId, protobuf$1.syft_proto.execution.v1.PlaceholderId], [ObjectMessage, protobuf$1.syft_proto.messaging.v1.ObjectMessage], [TorchTensor, protobuf$1.syft_proto.types.torch.v1.TorchTensor], [TorchParameter, protobuf$1.syft_proto.types.torch.v1.Parameter]];
  PB_TO_UNBUFFERIZER = PB_CLASS_MAP.reduce(function (map, item) {
    map[item[1]] = item[0].unbufferize;
    return map;
  }, {});
};

var long_1 = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString$1(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString$1(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString$1;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString$1(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

var unbufferize = function unbufferize(worker, pbObj) {
  if (!PB_TO_UNBUFFERIZER) {
    initMappings();
  }

  if (pbObj === undefined || pbObj === null || ['number', 'string', 'boolean'].includes(_typeof(pbObj))) {
    return pbObj;
  }

  var pbType = pbObj.constructor; // automatically unbufferize repeated fields

  if (Array.isArray(pbObj)) {
    return pbObj.map(function (item) {
      return unbufferize(worker, item);
    });
  } // automatically unbufferize map fields


  if (pbType.name === 'Object') {
    var res = {};

    for (var _i = 0, _Object$keys = Object.keys(pbObj); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      res[key] = unbufferize(worker, pbObj[key]);
    }

    return res;
  } // automatically unbufferize Id


  if (pbType === protobuf$1.syft_proto.types.syft.v1.Id) {
    return getPbId(pbObj);
  } // automatically unwrap Arg


  if (pbType === protobuf$1.syft_proto.types.syft.v1.Arg) {
    if (pbObj.arg === 'arg_int' && pbObj[pbObj.arg] instanceof long_1) {
      // protobuf int64 is represented as Long
      return pbObj[pbObj.arg].toNumber();
    } else {
      return unbufferize(worker, pbObj[pbObj.arg]);
    }
  } // automatically unwrap ArgList


  if (pbType === protobuf$1.syft_proto.types.syft.v1.ArgList) {
    return unbufferize(worker, pbObj.args);
  }

  var unbufferizer = PB_TO_UNBUFFERIZER[pbType];

  if (typeof unbufferizer === 'undefined') {
    throw new Error(NO_DETAILER(pbType.name));
  }

  return unbufferizer(worker, pbObj);
};
/**
 * Converts binary in the form of ArrayBuffer or base64 string to syft class
 * @param worker
 * @param bin
 * @param pbType
 * @returns {Object}
 */

var unserialize = function unserialize(worker, bin, pbType) {
  var buff = typeof bin === 'string' ? Buffer.from(bin, 'base64') : bin instanceof ArrayBuffer ? new Uint8Array(bin) : bin;
  var pbObj = pbType.decode(buff);
  return unbufferize(worker, pbObj);
};
/**
 * Converts syft class to protobuf-serialized binary
 * @param worker
 * @param obj
 * @returns {ArrayBuffer}
 */

var serialize = function serialize(worker, obj) {
  var pbObj = obj.bufferize(worker);
  var pbType = pbObj.constructor;
  var err = pbType.verify(pbObj);

  if (err) {
    throw new Error(err);
  }

  var bin = pbType.encode(pbObj).finish();
  return new Uint8Array(bin).buffer;
};
var getPbId = function getPbId(field) {
  // convert int64 to string
  return field[field.id].toString();
};
var pbId = function pbId(value) {
  if (typeof value === 'number') {
    return protobuf$1.syft_proto.types.syft.v1.Id.create({
      id_int: value
    });
  } else if (typeof value === 'string') {
    return protobuf$1.syft_proto.types.syft.v1.Id.create({
      id_str: value
    });
  }
};

/**
 * Model parameters as stored in the PyGrid.
 *
 * @property {Array.<tf.Tensor>} params Array of Model parameters.
 */

var SyftModel = /*#__PURE__*/function () {
  /**
   * @hideconstructor
   * @param {Object} options
   * @param {Syft} options.worker Instance of Syft client.
   * @param {ArrayBuffer} options.modelData Serialized Model parameters as returned by PyGrid.
   */
  function SyftModel(_ref) {
    var worker = _ref.worker,
        modelData = _ref.modelData;

    _classCallCheck(this, SyftModel);

    var state = unserialize(worker, modelData, protobuf$1.syft_proto.execution.v1.State);
    this.worker = worker;
    this.params = state.getTfTensors();
  }
  /**
   * Calculates difference between 2 versions of the Model parameters
   * and returns serialized `diff` that can be submitted to PyGrid.
   *
   * @param {Array.<tf.Tensor>} updatedModelParams Array of model parameters (tensors).
   * @returns {Promise<ArrayBuffer>} Protobuf-serialized `diff`.
   */


  _createClass(SyftModel, [{
    key: "createSerializedDiff",
    value: function () {
      var _createSerializedDiff = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(updatedModelParams) {
        var placeholders, tensors, i, paramDiff, state, bin;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                placeholders = [], tensors = [];
                i = 0;

              case 2:
                if (!(i < updatedModelParams.length)) {
                  _context.next = 13;
                  break;
                }

                paramDiff = this.params[i].sub(updatedModelParams[i]);
                placeholders.push(new Placeholder(i, ["#".concat(i), "#state-".concat(i)]));
                _context.t0 = tensors;
                _context.next = 8;
                return TorchTensor.fromTfTensor(paramDiff);

              case 8:
                _context.t1 = _context.sent;

                _context.t0.push.call(_context.t0, _context.t1);

              case 10:
                i++;
                _context.next = 2;
                break;

              case 13:
                state = new State$1(placeholders, tensors);
                bin = serialize(this.worker, state); // Free memory.

                tensors.forEach(function (t) {
                  return t._tfTensor.dispose();
                });
                return _context.abrupt("return", bin);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createSerializedDiff(_x) {
        return _createSerializedDiff.apply(this, arguments);
      }

      return createSerializedDiff;
    }()
  }]);

  return SyftModel;
}();

/**
 * Job represents a single training cycle done by the client.
 *
 * @property {Object.<string, Plan>} plans Plans dictionary.
 * @property {Object.<string, Protocol>} protocols [not implemented] Protocols dictionary.
 * @property {SyftModel} model Model.
 */

var Job = /*#__PURE__*/function () {
  /**
   * @hideconstructor
   * @param {object} options
   * @param {Syft} options.worker Instance of Syft client.
   * @param {string} options.modelName Model name.
   * @param {string} options.modelVersion Model version.
   * @param {GridAPIClient} options.gridClient Instance of GridAPIClient.
   */
  function Job(_ref) {
    var worker = _ref.worker,
        modelName = _ref.modelName,
        modelVersion = _ref.modelVersion,
        gridClient = _ref.gridClient;

    _classCallCheck(this, Job);

    this.worker = worker;
    this.modelName = modelName;
    this.modelVersion = modelVersion;
    this.grid = gridClient;
    this.logger = new Logger();
    this.observer = new EventObserver(); // parameters loaded from grid

    this.model = null;
    this.plans = {};
    this.protocols = {}; // holds request_key

    this.cycleParams = {};
    this.clientConfig = {};
  }
  /**
   * Registers an event listener.
   *
   * Available events: `accepted`, `rejected`, `error`.
   *
   * @param {string} event Event name.
   * @param {function} handler Event handler.
   */


  _createClass(Job, [{
    key: "on",
    value: function on(event, handler) {
      if (['accepted', 'rejected', 'error'].includes(event)) {
        this.observer.subscribe(event, handler.bind(this));
      }
    }
    /**
     * Initializes the Job with provided training cycle params.
     *
     * @private
     * @param {Object} cycleParams
     * @returns {Promise<void>}
     */

  }, {
    key: "initCycle",
    value: function () {
      var _initCycle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cycleParams) {
        var modelData, _i, _Object$keys, planName, planId, planBinary, _i2, _Object$keys2, protocolName, protocolId, protocolBinary;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.logger.log("Cycle initialization with params: ".concat(JSON.stringify(cycleParams)));
                this.cycleParams = cycleParams;
                this.clientConfig = cycleParams.client_config; // load the model

                _context.next = 5;
                return this.grid.getModel(this.worker.worker_id, cycleParams.request_key, cycleParams.model_id);

              case 5:
                modelData = _context.sent;
                this.model = new SyftModel({
                  worker: this.worker,
                  modelData: modelData
                }); // load all plans

                _i = 0, _Object$keys = Object.keys(cycleParams.plans);

              case 8:
                if (!(_i < _Object$keys.length)) {
                  _context.next = 18;
                  break;
                }

                planName = _Object$keys[_i];
                planId = cycleParams.plans[planName];
                _context.next = 13;
                return this.grid.getPlan(this.worker.worker_id, cycleParams.request_key, planId);

              case 13:
                planBinary = _context.sent;
                this.plans[planName] = unserialize(this.worker, planBinary, protobuf$1.syft_proto.execution.v1.Plan);

              case 15:
                _i++;
                _context.next = 8;
                break;

              case 18:
                _i2 = 0, _Object$keys2 = Object.keys(cycleParams.protocols);

              case 19:
                if (!(_i2 < _Object$keys2.length)) {
                  _context.next = 29;
                  break;
                }

                protocolName = _Object$keys2[_i2];
                protocolId = cycleParams.protocols[protocolName];
                _context.next = 24;
                return this.grid.getProtocol(this.worker.worker_id, cycleParams.request_key, protocolId);

              case 24:
                protocolBinary = _context.sent;
                this.protocols[protocolName] = unserialize(this.worker, protocolBinary, protobuf$1.syft_proto.execution.v1.Protocol);

              case 26:
                _i2++;
                _context.next = 19;
                break;

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initCycle(_x) {
        return _initCycle.apply(this, arguments);
      }

      return initCycle;
    }()
    /**
     * Starts the Job executing following actions:
     *  * Meters connection speed to PyGrid.
     *  * Registers into training cycle on PyGrid.
     *  * Retrieves cycle and client parameters.
     *  * Downloads Plans, Model, Protocols.
     *  * Fires `accepted` event on success.
     *
     * @fires Job#accepted
     * @fires Job#rejected
     * @fires Job#error
     * @returns {Promise<void>}
     */

  }, {
    key: "start",
    value: function () {
      var _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _yield$this$grid$getC, ping, download, upload, cycleParams;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return this.grid.getConnectionSpeed(this.worker.worker_id);

              case 3:
                _yield$this$grid$getC = _context2.sent;
                ping = _yield$this$grid$getC.ping;
                download = _yield$this$grid$getC.download;
                upload = _yield$this$grid$getC.upload;
                _context2.next = 9;
                return this.grid.requestCycle(this.worker.worker_id, this.modelName, this.modelVersion, ping, download, upload);

              case 9:
                cycleParams = _context2.sent;
                _context2.t0 = cycleParams.status;
                _context2.next = _context2.t0 === CYCLE_STATUS_ACCEPTED ? 13 : _context2.t0 === CYCLE_STATUS_REJECTED ? 18 : 21;
                break;

              case 13:
                // load model, plans, protocols, etc.
                this.logger.log("Accepted into cycle with params: ".concat(JSON.stringify(cycleParams, null, 2)));
                _context2.next = 16;
                return this.initCycle(cycleParams);

              case 16:
                /**
                 * `accepted` event.
                 * Triggered PyGrid accepts the client into training cycle.
                 *
                 * @event Job#accepted
                 * @type {Object}
                 * @property {SyftModel} model Instance of SyftModel.
                 * @property {Object} clientConfig Client configuration returned by PyGrid.
                 */
                this.observer.broadcast('accepted', {
                  model: this.model,
                  clientConfig: this.clientConfig
                });
                return _context2.abrupt("break", 22);

              case 18:
                this.logger.log("Rejected from cycle with timeout: ".concat(cycleParams.timeout));
                /**
                 * `rejected` event.
                 * Triggered when PyGrid rejects the client.
                 *
                 * @event Job#rejected
                 * @type {Object}
                 * @property {number|null} timeout Time in seconds to re-try. Empty when the FL model is not trainable anymore.
                 */

                this.observer.broadcast('rejected', {
                  timeout: cycleParams.timeout
                });
                return _context2.abrupt("break", 22);

              case 21:
                throw new Error(GRID_UNKNOWN_CYCLE_STATUS(cycleParams.status));

              case 22:
                _context2.next = 27;
                break;

              case 24:
                _context2.prev = 24;
                _context2.t1 = _context2["catch"](0);

                /**
                 * `error` event.
                 * Triggered for plethora of error conditions.
                 *
                 * @event Job#error
                 */
                this.observer.broadcast('error', _context2.t1);

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 24]]);
      }));

      function start() {
        return _start.apply(this, arguments);
      }

      return start;
    }()
    /**
     * Submits the model diff to PyGrid.
     *
     * @param {ArrayBuffer} diff Serialized difference between original and trained model parameters.
     * @returns {Promise<void>}
     */

  }, {
    key: "report",
    value: function () {
      var _report = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(diff) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.grid.submitReport(this.worker.worker_id, this.cycleParams.request_key, Buffer.from(diff).toString('base64'));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function report(_x2) {
        return _report.apply(this, arguments);
      }

      return report;
    }()
  }]);

  return Job;
}();

/**
 * Syft client for static federated learning.
 *
 * @param {Object} options
 * @param {string} options.url Full URL to PyGrid app (`ws` and `http` schemas supported).
 * @param {boolean} options.verbose Whether to enable logging and allow unsecured PyGrid connection.
 * @param {string} options.authToken PyGrid authentication token.
 * @param {Object} options.peerConfig [not implemented] WebRTC peer config used with RTCPeerConnection.
 *
 * @example
 *
 * const client = new Syft({url: "ws://localhost:5000", verbose: true})
 * const job = client.newJob({modelName: "mnist", modelVersion: "1.0.0"})
 * job.on('accepted', async (model, config) => {
 *   // execute training
 *   const [...newParams] = await this.plans['...'].execute(...)
 *   const diff = await model.createSerializedDiff(newParams)
 *   await this.report(diff)
 * })
 * job.on('rejected', (timeout) => {
 *   // re-try later or stop
 * })
 * job.on('error', (err) => {
 *   // handle errors
 * })
 * job.start()
 */

var Syft = /*#__PURE__*/function () {
  function Syft(_ref) {
    var url = _ref.url,
        verbose = _ref.verbose,
        authToken = _ref.authToken,
        peerConfig = _ref.peerConfig;

    _classCallCheck(this, Syft);

    // For creating verbose logging should the worker desire
    this.logger = new Logger('syft.js', verbose); // Forcing connection to be secure if verbose value is false.

    this.verbose = verbose;
    this.gridClient = new GridAPIClient({
      url: url,
      allowInsecureUrl: verbose
    }); // objects registry

    this.objects = new ObjectRegistry(); // For creating event listeners

    this.observer = new EventObserver();
    this.worker_id = null;
    this.peerConfig = peerConfig;
    this.authToken = authToken;
  }
  /**
   * Authenticates the client against PyGrid and instantiates new Job with given options.
   *
   * @param {Object} options
   * @param {string} options.modelName FL Model name.
   * @param {string} options.modelVersion FL Model version.
   * @returns {Promise<Job>}
   */


  _createClass(Syft, [{
    key: "newJob",
    value: function () {
      var _newJob = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {
        var modelName, modelVersion, authResponse;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                modelName = _ref2.modelName, modelVersion = _ref2.modelVersion;

                if (this.worker_id) {
                  _context.next = 6;
                  break;
                }

                _context.next = 4;
                return this.gridClient.authenticate(this.authToken);

              case 4:
                authResponse = _context.sent;
                this.worker_id = authResponse.worker_id;

              case 6:
                return _context.abrupt("return", new Job({
                  worker: this,
                  modelName: modelName,
                  modelVersion: modelVersion,
                  gridClient: this.gridClient
                }));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function newJob(_x) {
        return _newJob.apply(this, arguments);
      }

      return newJob;
    }()
  }]);

  return Syft;
}();

exports.CYCLE_STATUS_ACCEPTED = CYCLE_STATUS_ACCEPTED;
exports.CYCLE_STATUS_REJECTED = CYCLE_STATUS_REJECTED;
exports.GET_PROTOCOL = GET_PROTOCOL;
exports.SOCKET_PING = SOCKET_PING;
exports.SOCKET_STATUS = SOCKET_STATUS;
exports.Syft = Syft;
exports.WEBRTC_DATACHANNEL_BUFFER_TIMEOUT = WEBRTC_DATACHANNEL_BUFFER_TIMEOUT;
exports.WEBRTC_DATACHANNEL_CHUNK_SIZE = WEBRTC_DATACHANNEL_CHUNK_SIZE;
exports.WEBRTC_DATACHANNEL_MAX_BUFFER = WEBRTC_DATACHANNEL_MAX_BUFFER;
exports.WEBRTC_DATACHANNEL_MAX_BUFFER_TIMEOUTS = WEBRTC_DATACHANNEL_MAX_BUFFER_TIMEOUTS;
exports.WEBRTC_INTERNAL_MESSAGE = WEBRTC_INTERNAL_MESSAGE;
exports.WEBRTC_JOIN_ROOM = WEBRTC_JOIN_ROOM;
exports.WEBRTC_PEER_CONFIG = WEBRTC_PEER_CONFIG;
exports.WEBRTC_PEER_LEFT = WEBRTC_PEER_LEFT;
exports.WEBRTC_PEER_OPTIONS = WEBRTC_PEER_OPTIONS;
exports.default = Syft;
//# sourceMappingURL=index.cjs.js.map
