(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tensorflow/tfjs-core')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tensorflow/tfjs-core'], factory) :
  (global = global || self, factory(global.syft = {}, global.tf));
}(this, (function (exports, tf) { 'use strict';

  // Sockets
  var SOCKET_STATUS = 'socket-status';
  var SOCKET_PING = 'socket-ping'; // Grid

  var GET_PROTOCOL = 'get-protocol';
  var CYCLE_STATUS_ACCEPTED = 'accepted';
  var CYCLE_STATUS_REJECTED = 'rejected'; // WebRTC

  var WEBRTC_JOIN_ROOM = 'webrtc: join-room';
  var WEBRTC_INTERNAL_MESSAGE = 'webrtc: internal-message';
  var WEBRTC_PEER_LEFT = 'webrtc: peer-left'; // WebRTC: Data Channel

  var WEBRTC_DATACHANNEL_CHUNK_SIZE = 64 * 1024;
  var WEBRTC_DATACHANNEL_MAX_BUFFER = 4 * 1024 * 1024;
  var WEBRTC_DATACHANNEL_BUFFER_TIMEOUT = 2000;
  var WEBRTC_DATACHANNEL_MAX_BUFFER_TIMEOUTS = 5;
  var WEBRTC_PEER_CONFIG = {
    iceServers: [{
      urls: ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302' // FF says too many stuns are bad, don't send more than this
      ]
    }]
  };
  var WEBRTC_PEER_OPTIONS = {
    optional: [{
      DtlsSrtpKeyAgreement: true
    } // Required for connection between Chrome and Firefox
    // FF works w/o this option, but Chrome fails with it
    // { RtpDataChannels: true } // Required in Firefox to use the DataChannels API
    ]
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  /**
   * Event Observer that subscribes, unsubscribes and broadcasts events.
   *
   * @property {Object.<string, Function>} observers - Event dictionary.
   */
  var EventObserver = /*#__PURE__*/function () {
    function EventObserver() {
      classCallCheck(this, EventObserver);

      this.observers = [];
    }
    /**
     * Subscribes an event and its handler to the event dictionary.
     *
     * @param {string} type - Event type.
     * @param {Function} func - Event handler.
     * @param {number|boolean} [expires] - Expire subscription after N invocations.
     */


    createClass(EventObserver, [{
      key: "subscribe",
      value: function subscribe(type, func) {
        var expires = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        this.observers.push({
          type: type,
          func: func,
          expires: expires
        });
      }
      /**
       * Unsubscribes an event from the event dictionary.
       *
       * @param {string} eventType - Event type.
       * @param {Function} [func] - Event handler.
       */

    }, {
      key: "unsubscribe",
      value: function unsubscribe(eventType, func) {
        this.observers = this.observers.filter(function (i) {
          return eventType !== i.type && func !== i.func;
        });
      }
      /**
       * Broadcasts a specific event type.
       *
       * @param {string} eventType - Event type.
       * @param {Object} data - Data to be broadcasted.
       */

    }, {
      key: "broadcast",
      value: function broadcast(eventType, data) {
        this.observers.forEach(function (observer) {
          if (eventType === observer.type && (observer.expires === false || observer.expires > 0)) {
            if (typeof observer.expires === 'number') {
              observer.expires--;
            }

            observer.func(data);
          }
        }); // Remove expired subscriptions

        this.observers = this.observers.filter(function (i) {
          return i.expires > 0 || i.expires === false;
        });
      }
    }]);

    return EventObserver;
  }();

  // A simple logging function
  var Logger = /*#__PURE__*/function () {
    function Logger(system, verbose) {
      classCallCheck(this, Logger);

      if (!Logger.instance) {
        this.system = system;
        this.verbose = verbose;
        Logger.instance = this;
      }

      return Logger.instance;
    }

    createClass(Logger, [{
      key: "log",
      value: function log(message, data) {
        // Only log if verbose is turned on
        if (this.verbose) {
          var output = "".concat(Date.now(), ": ").concat(this.system, " - ").concat(message); // Have the passed additional data?

          if (data) {
            console.log(output, data);
          } else {
            console.log(output);
          }
        }
      }
    }]);

    return Logger;
  }();

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  var arrayWithHoles = _arrayWithHoles;

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  var iterableToArrayLimit = _iterableToArrayLimit;

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  var arrayLikeToArray = _arrayLikeToArray;

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }

  var unsupportedIterableToArray = _unsupportedIterableToArray;

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableRest = _nonIterableRest;

  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
  }

  var slicedToArray = _slicedToArray;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var runtime_1 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var runtime = (function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    function ensureDefaultToStringTag(object, defaultValue) {
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1644581#c6
      return toStringTagSymbol in object
        ? object[toStringTagSymbol]
        : object[toStringTagSymbol] = defaultValue;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = ensureDefaultToStringTag(
      GeneratorFunctionPrototype,
      "GeneratorFunction"
    );

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        prototype[method] = function(arg) {
          return this._invoke(method, arg);
        };
      });
    }

    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        ensureDefaultToStringTag(genFun, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;

      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );

      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    ensureDefaultToStringTag(Gp, "Generator");

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };

    Gp.toString = function() {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;

    function doneResult() {
      return { value: undefined$1, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined$1;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;

  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
     module.exports 
  ));

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  var regenerator = runtime_1;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var asyncToGenerator = _asyncToGenerator;

  /**
   * Creates ArrayBuffer with given size populated with random values
   * @param size {number} - Buffer size in bytes
   * @returns {ArrayBuffer}
   */
  var createRandomBuffer = /*#__PURE__*/function () {
    var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(size) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve) {
                // Uint32Array is faster, 4 times less Math.random() calls
                var int32BuffSize = Math.ceil(size / 4);
                var buff = new Uint32Array(int32BuffSize);
                var int32Max = Math.pow(2, 32);

                var randomInt32 = function randomInt32() {
                  return Math.random() * int32Max;
                }; // Don't block event loop too much, break every 1mb


                var int32ChunkSize = 1024 * 1024 / 4;

                var fillNextChunk = function fillNextChunk() {
                  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                  var stop = Math.min(offset + int32ChunkSize, int32BuffSize);

                  for (var i = offset; i < stop; i++) {
                    buff[i] = randomInt32();
                  }

                  if (stop !== int32BuffSize) {
                    setTimeout(fillNextChunk, 0, offset + int32ChunkSize);
                  } else {
                    resolve(buff.buffer);
                  }
                };

                setTimeout(fillNextChunk, 0);
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function createRandomBuffer(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  /**
   * SpeedTest is a class that contains the necessary components
   * to measure download/upload speed, and ping.
   */

  var SpeedTest = /*#__PURE__*/function () {
    /**
     * @param {string} downloadUrl
     * @param {string} uploadUrl
     * @param {string} pingUrl
     * @param {number} maxUploadSizeMb
     * @param {number} maxTestTimeSec
     */
    function SpeedTest(_ref) {
      var downloadUrl = _ref.downloadUrl,
          uploadUrl = _ref.uploadUrl,
          pingUrl = _ref.pingUrl,
          _ref$maxUploadSizeMb = _ref.maxUploadSizeMb,
          maxUploadSizeMb = _ref$maxUploadSizeMb === void 0 ? 64 : _ref$maxUploadSizeMb,
          _ref$maxTestTimeSec = _ref.maxTestTimeSec,
          maxTestTimeSec = _ref$maxTestTimeSec === void 0 ? 10 : _ref$maxTestTimeSec;

      classCallCheck(this, SpeedTest);

      this.downloadUrl = downloadUrl;
      this.uploadUrl = uploadUrl;
      this.pingUrl = pingUrl;
      this.maxUploadSizeMb = maxUploadSizeMb;
      this.maxTestTimeSec = maxTestTimeSec; // Various settings to tune.

      this.bwAvgWindow = 5;
      this.bwLowJitterThreshold = 0.05;
      this.bwMaxLowJitterConsecutiveMeasures = 5;
    }
    /**
     * Measures the time taken to make an XMLHttpRequest (xhr).
     * Gets called before the request is sent, to set up values and tools to measure time.
     * Returns a promise that gets updated when the request is sent and a response is received with no errors.
     *  If the request is successful, then the value of the promise is the time that the request took (in seconds)
     *  Else, the value is an Error
     * @param {XMLHttpRequest} xhr - XMLHttpRequest
     * @param {boolean} isUpload
     */


    createClass(SpeedTest, [{
      key: "meterXhr",
      value: function () {
        var _meterXhr = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(xhr) {
          var _this = this;

          var isUpload,
              _args = arguments;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  isUpload = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
                  return _context.abrupt("return", new Promise(function (resolve, reject) {
                    // Set up the initial values to measure time
                    var timeoutHandler = null,
                        prevTime = 0,
                        prevSize = 0,
                        avgCollector = new AvgCollector({
                      avgWindow: _this.bwAvgWindow,
                      lowJitterThreshold: _this.bwLowJitterThreshold,
                      maxLowJitterConsecutiveMeasures: _this.bwMaxLowJitterConsecutiveMeasures
                    });
                    var req = isUpload ? xhr.upload : xhr; // Update the value of the promise when the request is finished

                    var finish = function finish() {
                      var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

                      if (timeoutHandler) {
                        clearTimeout(timeoutHandler);
                      } // Clean up


                      req.onprogress = null;
                      req.onload = null;
                      req.onerror = null;
                      xhr.abort(); // Return result

                      if (!error) {
                        resolve(avgCollector.getAvg());
                      } else {
                        reject(new Error(error));
                      }
                    };

                    req.onreadystatechange = function () {
                      if (xhr.readyState === 1) {
                        // As soon as connection is opened, set speed test timeout
                        timeoutHandler = setTimeout(finish, _this.maxTestTimeSec * 1000); // Set initial time/size values

                        if (!prevTime) {
                          prevTime = Date.now() / 1000;
                          prevSize = 0;
                        }
                      }
                    };

                    req.onprogress = function (e) {
                      var // mbit
                      size = 8 * e.loaded / 1048576,
                          // seconds
                      time = Date.now() / 1000;

                      if (!prevTime) {
                        prevTime = time;
                        prevSize = size;
                        return;
                      } // Update change in time and size as the request i in progress


                      var deltaSize = size - prevSize,
                          deltaTime = time - prevTime,
                          speed = deltaSize / deltaTime;

                      if (deltaTime === 0 || !Number.isFinite(speed)) {
                        // Cap to 1Gbps
                        speed = 1000;
                      }

                      var canStop = avgCollector.collect(speed);

                      if (canStop) {
                        finish();
                      }

                      prevSize = size;
                      prevTime = time;
                    };

                    req.onload = function () {
                      finish();
                    };

                    req.onerror = function (e) {
                      finish(e);
                    };
                  }));

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function meterXhr(_x) {
          return _meterXhr.apply(this, arguments);
        }

        return meterXhr;
      }()
    }, {
      key: "getDownloadSpeed",
      value: function () {
        var _getDownloadSpeed = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var xhr, result;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  xhr = new XMLHttpRequest();
                  result = this.meterXhr(xhr);
                  xhr.open('GET', this.downloadUrl + '?' + Math.random(), true);
                  xhr.send();
                  return _context2.abrupt("return", result);

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getDownloadSpeed() {
          return _getDownloadSpeed.apply(this, arguments);
        }

        return getDownloadSpeed;
      }()
    }, {
      key: "getUploadSpeed",
      value: function () {
        var _getUploadSpeed = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var xhr, result, buff;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  xhr = new XMLHttpRequest();
                  result = this.meterXhr(xhr, true);
                  _context3.next = 4;
                  return createRandomBuffer(this.maxUploadSizeMb * 1024 * 1024);

                case 4:
                  buff = _context3.sent;
                  xhr.open('POST', this.uploadUrl, true);
                  xhr.send(buff);
                  return _context3.abrupt("return", result);

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getUploadSpeed() {
          return _getUploadSpeed.apply(this, arguments);
        }

        return getUploadSpeed;
      }()
    }, {
      key: "getPing",
      value: function () {
        var _getPing = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var _this2 = this;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  return _context4.abrupt("return", new Promise(function (resolve, reject) {
                    // Set up values to measure ping
                    var avgCollector = new AvgCollector({});
                    var currXhr;
                    var timeoutHandler; // Update value of promise once test is finished

                    var finish = function finish(xhr) {
                      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

                      if (timeoutHandler) {
                        clearTimeout(timeoutHandler);
                      } // Clean up


                      xhr.onprogress = null;
                      xhr.onload = null;
                      xhr.onerror = null;
                      xhr.abort(); // Return result

                      if (!error) {
                        resolve(avgCollector.getAvg());
                      } else {
                        reject(new Error(error));
                      }
                    };

                    var runPing = function runPing() {
                      var xhr = new XMLHttpRequest();
                      currXhr = xhr;
                      var startTime = Date.now();

                      xhr.onload = function () {
                        var ping = Date.now() - startTime;
                        var canStop = avgCollector.collect(ping);

                        if (canStop) {
                          finish(xhr);
                        } else {
                          setTimeout(runPing, 0);
                        }
                      };

                      xhr.onerror = function (e) {
                        finish(xhr, e);
                      };

                      xhr.open('GET', _this2.pingUrl + '?' + Math.random(), true);
                      xhr.send();
                    };

                    timeoutHandler = setTimeout(function () {
                      finish(currXhr);
                    }, _this2.maxTestTimeSec * 1000);
                    runPing();
                  }));

                case 1:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        function getPing() {
          return _getPing.apply(this, arguments);
        }

        return getPing;
      }()
    }]);

    return SpeedTest;
  }();
  /**
   * Helper to average series of values.
   *
   * @private
   * @param options {Object}
   * @param options.avgWindow {number} Window to average (last N measurements)
   * @param options.lowJitterThreshold {number} Change of avg considered stable
   * @param maxLowJitterConsecutiveMeasures {number} Number of measures
   *  when avg stays stable to stop collecting more samples
   */

  var AvgCollector = /*#__PURE__*/function () {
    function AvgCollector(_ref2) {
      var _ref2$avgWindow = _ref2.avgWindow,
          avgWindow = _ref2$avgWindow === void 0 ? 5 : _ref2$avgWindow,
          _ref2$lowJitterThresh = _ref2.lowJitterThreshold,
          lowJitterThreshold = _ref2$lowJitterThresh === void 0 ? 0.05 : _ref2$lowJitterThresh,
          _ref2$maxLowJitterCon = _ref2.maxLowJitterConsecutiveMeasures,
          maxLowJitterConsecutiveMeasures = _ref2$maxLowJitterCon === void 0 ? 5 : _ref2$maxLowJitterCon;

      classCallCheck(this, AvgCollector);

      this.measuresCount = 0;
      this.prevAvg = 0;
      this.avg = 0;
      this.lowJitterConsecutiveMeasures = 0;
      this.avgWindow = avgWindow;
      this.lowJitterThreshold = lowJitterThreshold;
      this.maxLowJitterConsecutiveMeasures = maxLowJitterConsecutiveMeasures;
      this.name = name;
    }
    /**
     * Collects one sample for averaging.
     * @param value {number} Reported speed
     * @returns {boolean} Can stop collecting due to average value stability
     */


    createClass(AvgCollector, [{
      key: "collect",
      value: function collect(value) {
        this.prevAvg = this.avg;
        var avgWindow = Math.min(this.measuresCount, this.avgWindow);
        this.avg = (this.avg * avgWindow + value) / (avgWindow + 1);
        this.measuresCount++; // Return true if measurements are stable.

        if (this.prevAvg > 0 && this.avg < this.prevAvg * (1 + this.lowJitterThreshold) && this.avg > this.prevAvg * (1 - this.lowJitterThreshold)) {
          this.lowJitterConsecutiveMeasures++;
        } else {
          this.lowJitterConsecutiveMeasures = 0;
        }

        return this.lowJitterConsecutiveMeasures >= this.maxLowJitterConsecutiveMeasures;
      }
    }, {
      key: "getAvg",
      value: function getAvg() {
        return this.avg;
      }
    }]);

    return AvgCollector;
  }();

  var setPrototypeOf = createCommonjsModule(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
  });

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }

  var inherits = _inherits;

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  });

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var assertThisInitialized = _assertThisInitialized;

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
      return call;
    }

    return assertThisInitialized(self);
  }

  var possibleConstructorReturn = _possibleConstructorReturn;

  var getPrototypeOf = createCommonjsModule(function (module) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf;
  });

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  var isNativeFunction = _isNativeFunction;

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  var isNativeReflectConstruct = _isNativeReflectConstruct;

  var construct = createCommonjsModule(function (module) {
  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      module.exports = _construct = Reflect.construct;
    } else {
      module.exports = _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  module.exports = _construct;
  });

  var wrapNativeSuper = createCommonjsModule(function (module) {
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  module.exports = _wrapNativeSuper;
  });

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NoDetailerError = /*#__PURE__*/function (_Error) {
    inherits(NoDetailerError, _Error);

    var _super = _createSuper(NoDetailerError);

    function NoDetailerError(d) {
      var _this;

      classCallCheck(this, NoDetailerError);

      _this = _super.call(this, "Serialized object contains type that may exist in PySyft, but is not currently supported in syft.js. Please file a feature request (https://github.com/OpenMined/syft.js/issues) for type ".concat(d, "."));
      _this.name = 'NoDetailerError';
      return _this;
    }

    return NoDetailerError;
  }( /*#__PURE__*/wrapNativeSuper(Error));
  var NotEnoughArgsError = /*#__PURE__*/function (_Error2) {
    inherits(NotEnoughArgsError, _Error2);

    var _super2 = _createSuper(NotEnoughArgsError);

    function NotEnoughArgsError(passed, expected) {
      var _this2;

      classCallCheck(this, NotEnoughArgsError);

      _this2 = _super2.call(this, "You have passed ".concat(passed, " argument(s) when the plan requires ").concat(expected, " argument(s)."));
      _this2.name = 'NotEnoughArgsError';
      return _this2;
    }

    return NotEnoughArgsError;
  }( /*#__PURE__*/wrapNativeSuper(Error));
  var MissingVariableError = /*#__PURE__*/function (_Error3) {
    inherits(MissingVariableError, _Error3);

    var _super3 = _createSuper(MissingVariableError);

    function MissingVariableError() {
      var _this3;

      classCallCheck(this, MissingVariableError);

      _this3 = _super3.call(this, "Command requires variable that is missing.");
      _this3.name = 'MissingVariableError';
      return _this3;
    }

    return MissingVariableError;
  }( /*#__PURE__*/wrapNativeSuper(Error));
  var CannotFindCommandError = /*#__PURE__*/function (_Error6) {
    inherits(CannotFindCommandError, _Error6);

    var _super6 = _createSuper(CannotFindCommandError);

    function CannotFindCommandError(command) {
      var _this6;

      classCallCheck(this, CannotFindCommandError);

      _this6 = _super6.call(this, "Command ".concat(command, " not found in in TensorFlow.js."));
      _this6.name = 'CannotFindCommandError';
      return _this6;
    }

    return CannotFindCommandError;
  }( /*#__PURE__*/wrapNativeSuper(Error));
  var GridUnknownCycleStatusError = /*#__PURE__*/function (_Error7) {
    inherits(GridUnknownCycleStatusError, _Error7);

    var _super7 = _createSuper(GridUnknownCycleStatusError);

    function GridUnknownCycleStatusError(status) {
      var _this7;

      classCallCheck(this, GridUnknownCycleStatusError);

      _this7 = _super7.call(this, "Unknown cycle status: ".concat(status));
      _this7.name = 'GridUnknownCycleStatusError';
      return _this7;
    }

    return GridUnknownCycleStatusError;
  }( /*#__PURE__*/wrapNativeSuper(Error));
  var GridError = /*#__PURE__*/function (_Error8) {
    inherits(GridError, _Error8);

    var _super8 = _createSuper(GridError);

    function GridError(status) {
      var _this8;

      classCallCheck(this, GridError);

      _this8 = _super8.call(this, "Grid error: ".concat(status));
      _this8.name = 'GridError';
      return _this8;
    }

    return GridError;
  }( /*#__PURE__*/wrapNativeSuper(Error));
  var ModelLoadFailedError = /*#__PURE__*/function (_Error9) {
    inherits(ModelLoadFailedError, _Error9);

    var _super9 = _createSuper(ModelLoadFailedError);

    function ModelLoadFailedError(status) {
      var _this9;

      classCallCheck(this, ModelLoadFailedError);

      _this9 = _super9.call(this, "Failed to load Model: ".concat(status));
      _this9.name = 'ModelLoadFailedError';
      return _this9;
    }

    return ModelLoadFailedError;
  }( /*#__PURE__*/wrapNativeSuper(Error));
  var PlanLoadFailedError = /*#__PURE__*/function (_Error10) {
    inherits(PlanLoadFailedError, _Error10);

    var _super10 = _createSuper(PlanLoadFailedError);

    function PlanLoadFailedError(planName, status) {
      var _this10;

      classCallCheck(this, PlanLoadFailedError);

      _this10 = _super10.call(this, "Failed to load '".concat(planName, "' Plan: ").concat(status));
      _this10.name = 'PlanLoadFailedError';
      return _this10;
    }

    return PlanLoadFailedError;
  }( /*#__PURE__*/wrapNativeSuper(Error));
  var ProtobufUnserializeFailedError = /*#__PURE__*/function (_Error11) {
    inherits(ProtobufUnserializeFailedError, _Error11);

    var _super11 = _createSuper(ProtobufUnserializeFailedError);

    function ProtobufUnserializeFailedError(pbType, status) {
      var _this11;

      classCallCheck(this, ProtobufUnserializeFailedError);

      _this11 = _super11.call(this, "Failed to unserialize binary protobuf data into ".concat(pbType, ": ").concat(status));
      _this11.name = 'ProtobufUnserializeFailedError';
      return _this11;
    }

    return ProtobufUnserializeFailedError;
  }( /*#__PURE__*/wrapNativeSuper(Error));

  var base64Arraybuffer = createCommonjsModule(function (module, exports) {
  /*
   * base64-arraybuffer
   * https://github.com/niklasvh/base64-arraybuffer
   *
   * Copyright (c) 2012 Niklas von Hertzen
   * Licensed under the MIT license.
   */
  (function(){

    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    // Use a lookup table to find the index.
    var lookup = new Uint8Array(256);
    for (var i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }

    exports.encode = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer),
      i, len = bytes.length, base64 = "";

      for (i = 0; i < len; i+=3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
      }

      if ((len % 3) === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }

      return base64;
    };

    exports.decode =  function(base64) {
      var bufferLength = base64.length * 0.75,
      len = base64.length, i, p = 0,
      encoded1, encoded2, encoded3, encoded4;

      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }

      var arraybuffer = new ArrayBuffer(bufferLength),
      bytes = new Uint8Array(arraybuffer);

      for (i = 0; i < len; i+=4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i+1)];
        encoded3 = lookup[base64.charCodeAt(i+2)];
        encoded4 = lookup[base64.charCodeAt(i+3)];

        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
      }

      return arraybuffer;
    };
  })();
  });

  /**
   * Decodes base64-encoded string to ArrayBuffer
   * @param {string} str
   * @returns {Uint8Array}
   */

  var base64Decode = function base64Decode(str) {
    return new Uint8Array(base64Arraybuffer.decode(str));
  };
  /**
   * Encodes ArrayBuffer to base64 string
   * @param {ArrayBuffer} array
   * @returns {string}
   */

  var base64Encode = function base64Encode(array) {
    return base64Arraybuffer.encode(array);
  };

  var HTTP_PATH_VERB = {
    'model-centric/get-plan': 'GET',
    'model-centric/get-model': 'GET',
    'model-centric/get-protocol': 'GET',
    'model-centric/cycle-request': 'POST',
    'model-centric/report': 'POST',
    'model-centric/authenticate': 'POST'
  };
  /**
   * GridAPIClient defines the possible API calls that can be made to PyGrid from a client perspective
   * Operations include get-plan, get-model, get-protocol, cycle-request, report and authenticate
   */

  var GridAPIClient = /*#__PURE__*/function () {
    function GridAPIClient(_ref) {
      var url = _ref.url,
          _ref$allowInsecureUrl = _ref.allowInsecureUrl,
          allowInsecureUrl = _ref$allowInsecureUrl === void 0 ? false : _ref$allowInsecureUrl;

      classCallCheck(this, GridAPIClient);

      // Choose between web socket or http protocol
      this.transport = url.match(/^ws/i) ? 'ws' : 'http';

      if (this.transport === 'ws') {
        this.wsUrl = url;
        this.httpUrl = url.replace(/^ws(s)?/i, 'http$1');
      } else {
        this.httpUrl = url;
        this.wsUrl = url.replace(/^http(s)?/i, 'ws$1');
      }

      if (!allowInsecureUrl) {
        this.wsUrl = this.wsUrl.replace('ws', 'wss');
        this.httpUrl = this.httpUrl.replace('http', 'https');
      } // Define all necessary components for both web socket and http


      this.ws = null;
      this.observer = new EventObserver();
      this.wsMessages = {};
      this.logger = new Logger('grid', true);
      this.responseTimeout = 10000;
      this._handleWsMessage = this._handleWsMessage.bind(this);
      this._handleWsError = this._handleWsError.bind(this);
      this._handleWsClose = this._handleWsClose.bind(this);
    }
    /**
     * Authenticates a connection to the grid
     * using a particular token associated with a model name and version
     * @param {string} modelName
     * @param {string} modelVersion
     * @param {string} authToken
     */


    createClass(GridAPIClient, [{
      key: "authenticate",
      value: function () {
        var _authenticate = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(modelName, modelVersion, authToken) {
          var response;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.logger.log("Authenticating against ".concat(modelName, " ").concat(modelVersion, " with ").concat(authToken, "..."));
                  _context.next = 3;
                  return this._send('model-centric/authenticate', {
                    model_name: modelName,
                    model_version: modelVersion,
                    auth_token: authToken
                  });

                case 3:
                  response = _context.sent;
                  return _context.abrupt("return", response);

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function authenticate(_x, _x2, _x3) {
          return _authenticate.apply(this, arguments);
        }

        return authenticate;
      }()
      /**
       * Requests to join an active federated learning cycle in PyGrid
       * @param {string} workerId
       * @param {string} modelName
       * @param {string} modelVersion
       * @param {number} ping
       * @param {number} download
       * @param {number} upload
       */

    }, {
      key: "requestCycle",
      value: function requestCycle(workerId, modelName, modelVersion, ping, download, upload) {
        this.logger.log("[WID: ".concat(workerId, "] Requesting cycle for model ").concat(modelName, " v.").concat(modelVersion, " [").concat(ping, ", ").concat(download, ", ").concat(upload, "]..."));

        var response = this._send('model-centric/cycle-request', {
          worker_id: workerId,
          model: modelName,
          version: modelVersion,
          ping: ping,
          download: download,
          upload: upload
        });

        return response;
      }
    }, {
      key: "getModel",
      value: function () {
        var _getModel = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(workerId, requestKey, modelId) {
          var response;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  this.logger.log("[WID: ".concat(workerId, ", KEY: ").concat(requestKey, "] Requesting model ").concat(modelId, "..."));
                  _context2.next = 3;
                  return this._sendHttp('model-centric/get-model', {
                    worker_id: workerId,
                    request_key: requestKey,
                    model_id: modelId
                  }, 'arrayBuffer');

                case 3:
                  response = _context2.sent;
                  return _context2.abrupt("return", response);

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getModel(_x4, _x5, _x6) {
          return _getModel.apply(this, arguments);
        }

        return getModel;
      }()
    }, {
      key: "getPlan",
      value: function () {
        var _getPlan = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(workerId, requestKey, planId) {
          var response;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  this.logger.log("[WID: ".concat(workerId, ", KEY: ").concat(requestKey, "] Requesting plan ").concat(planId, "..."));
                  _context3.next = 3;
                  return this._sendHttp('model-centric/get-plan', {
                    worker_id: workerId,
                    request_key: requestKey,
                    plan_id: planId,
                    receive_operations_as: 'tfjs'
                  }, 'arrayBuffer');

                case 3:
                  response = _context3.sent;
                  return _context3.abrupt("return", response);

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getPlan(_x7, _x8, _x9) {
          return _getPlan.apply(this, arguments);
        }

        return getPlan;
      }()
    }, {
      key: "getProtocol",
      value: function getProtocol(workerId, requestKey, protocolId) {
        this.logger.log("[WID: ".concat(workerId, ", KEY: ").concat(requestKey, "] Requesting protocol ").concat(protocolId, "..."));
        return Promise.resolve('CgYIjcivoCUqEwoGCIHIr6AlEgkSB3dvcmtlcjEqEwoGCIXIr6AlEgkSB3dvcmtlcjIqEwoGCInIr6AlEgkSB3dvcmtlcjM=');
      }
      /**
       * Submits a report indicating the difference between the model parameters from workerID and original PyGrid parameters
       * @param {string} workerId
       * @param {string} requestKey
       * @param {string} diff - a base64 encoded string difference between current and original model parameters in PyGrid
       */

    }, {
      key: "submitReport",
      value: function () {
        var _submitReport = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(workerId, requestKey, diff) {
          var response;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  this.logger.log("[WID: ".concat(workerId, ", KEY: ").concat(requestKey, "] Submitting report..."));
                  _context4.next = 3;
                  return this._send('model-centric/report', {
                    worker_id: workerId,
                    request_key: requestKey,
                    diff: diff
                  });

                case 3:
                  response = _context4.sent;
                  return _context4.abrupt("return", response);

                case 5:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function submitReport(_x10, _x11, _x12) {
          return _submitReport.apply(this, arguments);
        }

        return submitReport;
      }()
    }, {
      key: "getConnectionSpeed",
      value: function () {
        var _getConnectionSpeed = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(workerId) {
          var speedTest, ping, _yield$Promise$all, _yield$Promise$all2, download, upload;

          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  speedTest = new SpeedTest({
                    downloadUrl: this.httpUrl + '/model-centric/speed-test?worker_id=' + encodeURIComponent(workerId) + '&random=' + Math.random(),
                    uploadUrl: this.httpUrl + '/model-centric/speed-test?worker_id=' + encodeURIComponent(workerId) + '&random=' + Math.random(),
                    pingUrl: this.httpUrl + '/model-centric/speed-test?is_ping=1&worker_id=' + encodeURIComponent(workerId) + '&random=' + Math.random()
                  });
                  _context5.next = 3;
                  return speedTest.getPing();

                case 3:
                  ping = _context5.sent;
                  _context5.next = 6;
                  return Promise.all([speedTest.getDownloadSpeed(), speedTest.getUploadSpeed()]);

                case 6:
                  _yield$Promise$all = _context5.sent;
                  _yield$Promise$all2 = slicedToArray(_yield$Promise$all, 2);
                  download = _yield$Promise$all2[0];
                  upload = _yield$Promise$all2[1];
                  return _context5.abrupt("return", {
                    ping: ping,
                    download: download,
                    upload: upload
                  });

                case 11:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function getConnectionSpeed(_x13) {
          return _getConnectionSpeed.apply(this, arguments);
        }

        return getConnectionSpeed;
      }()
    }, {
      key: "_send",
      value: function () {
        var _send2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(path, data) {
          var response;
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  if (!(this.transport === 'ws')) {
                    _context6.next = 6;
                    break;
                  }

                  _context6.next = 3;
                  return this._sendWs(path, data);

                case 3:
                  _context6.t0 = _context6.sent;
                  _context6.next = 9;
                  break;

                case 6:
                  _context6.next = 8;
                  return this._sendHttp(path, data);

                case 8:
                  _context6.t0 = _context6.sent;

                case 9:
                  response = _context6.t0;

                  if (!response.error) {
                    _context6.next = 12;
                    break;
                  }

                  throw new Error(response.error);

                case 12:
                  return _context6.abrupt("return", response);

                case 13:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function _send(_x14, _x15) {
          return _send2.apply(this, arguments);
        }

        return _send;
      }()
    }, {
      key: "_sendHttp",
      value: function () {
        var _sendHttp2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(path, data) {
          var type,
              method,
              response,
              query,
              error,
              res,
              _args7 = arguments;
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  type = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : 'json';
                  method = HTTP_PATH_VERB[path] || 'GET';

                  if (!(method === 'GET')) {
                    _context7.next = 9;
                    break;
                  }

                  query = Object.keys(data).map(function (k) {
                    return encodeURIComponent(k) + '=' + encodeURIComponent(data[k]);
                  }).join('&');
                  _context7.next = 6;
                  return fetch(this.httpUrl + '/' + path + '?' + query, {
                    method: 'GET',
                    mode: 'cors'
                  });

                case 6:
                  response = _context7.sent;
                  _context7.next = 12;
                  break;

                case 9:
                  _context7.next = 11;
                  return fetch(this.httpUrl + '/' + path, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                  });

                case 11:
                  response = _context7.sent;

                case 12:
                  if (response.ok) {
                    _context7.next = 24;
                    break;
                  }

                  error = "".concat(response.status, " ").concat(response.statusText);
                  _context7.prev = 14;
                  _context7.next = 17;
                  return response.json();

                case 17:
                  res = _context7.sent;

                  if (res.error) {
                    error = res.error;
                  }

                  _context7.next = 23;
                  break;

                case 21:
                  _context7.prev = 21;
                  _context7.t0 = _context7["catch"](14);

                case 23:
                  throw new GridError(error);

                case 24:
                  return _context7.abrupt("return", response[type]());

                case 25:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this, [[14, 21]]);
        }));

        function _sendHttp(_x16, _x17) {
          return _sendHttp2.apply(this, arguments);
        }

        return _sendHttp;
      }()
    }, {
      key: "_sendWs",
      value: function () {
        var _sendWs2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(type, data) {
          var _this = this;

          var request_id, message;
          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  if (this.ws) {
                    _context8.next = 3;
                    break;
                  }

                  _context8.next = 3;
                  return this._initWs();

                case 3:
                  _context8.t0 = base64Encode;
                  _context8.next = 6;
                  return createRandomBuffer(32);

                case 6:
                  _context8.t1 = _context8.sent;
                  request_id = (0, _context8.t0)(_context8.t1);
                  message = {
                    request_id: request_id,
                    type: type,
                    data: data
                  };
                  this.logger.log('Sending WS message', request_id, type);
                  return _context8.abrupt("return", new Promise(function (resolve, reject) {
                    _this.ws.send(JSON.stringify(message));

                    var cleanUp = function cleanUp() {
                      // Remove all handlers related to message.
                      delete _this.wsMessages[request_id];

                      _this.observer.unsubscribe('ws-error', onError);

                      _this.observer.unsubscribe('ws-close', onClose);

                      clearTimeout(timeoutHandler);
                    };

                    var timeoutHandler = setTimeout(function () {
                      cleanUp();
                      reject(new Error('Response timeout'));
                    }, _this.responseTimeout);

                    var onMessage = function onMessage(data) {
                      cleanUp();
                      resolve(data.data);
                    };

                    var onError = function onError(event) {
                      cleanUp();
                      reject(new Error(event));
                    };

                    var onClose = function onClose() {
                      cleanUp();
                      reject(new Error('WS connection closed'));
                    }; // Save response handler under specific request_id.
                    // We expect same request_id in the response.


                    _this.wsMessages[request_id] = onMessage; // Other events while waiting for response.

                    _this.observer.subscribe('ws-error', onError);

                    _this.observer.subscribe('ws-close', onClose);
                  }));

                case 11:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function _sendWs(_x18, _x19) {
          return _sendWs2.apply(this, arguments);
        }

        return _sendWs;
      }()
    }, {
      key: "_initWs",
      value: function () {
        var _initWs2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
          var _this2 = this;

          return regenerator.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  return _context9.abrupt("return", new Promise(function (resolve, reject) {
                    var ws = new WebSocket(_this2.wsUrl);

                    ws.onopen = function () {
                      // setup handlers
                      ws.onerror = _this2._handleWsError;
                      ws.onclose = _this2._handleWsClose;
                      ws.onmessage = _this2._handleWsMessage;
                      _this2.ws = ws;
                      resolve();
                    };

                    ws.onerror = function (event) {
                      // Couldn't connect and error is returned
                      _this2._handleWsError(event);

                      reject(new Error(event));
                    };

                    ws.onclose = function (event) {
                      // Couldn't connect and connection closed
                      _this2._handleWsClose(event);

                      reject(new Error('WS connection closed during connect'));
                    };
                  }));

                case 1:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }));

        function _initWs() {
          return _initWs2.apply(this, arguments);
        }

        return _initWs;
      }()
    }, {
      key: "_handleWsMessage",
      value: function _handleWsMessage(event) {
        this.logger.log('Received message', event.data);
        var data;

        try {
          data = JSON.parse(event.data);
        } catch (e) {
          this.logger.log('Message is not valid JSON!');
        } // Call response handler, it should be stored under request_id.


        var request_id = data.request_id;

        if (request_id && Object.hasOwnProperty.call(this.wsMessages, request_id)) {
          var handler = this.wsMessages[request_id];
          handler(data);
        } else {
          this.logger.log('Message with unknown request_id');
        }
      }
    }, {
      key: "_handleWsError",
      value: function _handleWsError(event) {
        this.logger.log('WS connection error', event);
        this.observer.broadcast('ws-error', event);
        this.ws = null;
      }
    }, {
      key: "_handleWsClose",
      value: function _handleWsClose(event) {
        this.logger.log('WS connection closed', event);
        this.observer.broadcast('ws-close', event);
        this.ws = null;
      }
    }]);

    return GridAPIClient;
  }();

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty = _defineProperty;

  var _DOC = "This file defines PySyft protocol serialization constants";
  var VERSION = 0;
  var TYPES = {
  	dict: {
  		code: 0
  	},
  	list: {
  		code: 1
  	},
  	range: {
  		code: 2
  	},
  	set: {
  		code: 3
  	},
  	slice: {
  		code: 4
  	},
  	str: {
  		code: 5
  	},
  	tuple: {
  		code: 6
  	},
  	ellipsis: {
  		code: 7
  	},
  	"numpy.ndarray": {
  		code: 8
  	},
  	"numpy.float32": {
  		code: 9
  	},
  	"numpy.float64": {
  		code: 9
  	},
  	"numpy.int32": {
  		code: 9
  	},
  	"numpy.int64": {
  		code: 9
  	},
  	"torch.device": {
  		code: 10
  	},
  	"torch.Size": {
  		code: 11
  	},
  	"torch.jit.ScriptModule": {
  		code: 12
  	},
  	"torch._C.Function": {
  		code: 12
  	},
  	"torch.jit.ScriptFunction": {
  		code: 12
  	},
  	"torch.jit.TopLevelTracedModule": {
  		code: 12
  	},
  	"torch.nn.parameter.Parameter": {
  		code: 13
  	},
  	"torch.Tensor": {
  		code: 14
  	},
  	"syft.frameworks.torch.tensors.interpreters.additive_shared.AdditiveSharingTensor": {
  		code: 15
  	},
  	"syft.frameworks.torch.tensors.interpreters.precision.FixedPrecisionTensor": {
  		code: 16
  	},
  	"syft.frameworks.torch.tensors.interpreters.crt_precision.CRTPrecisionTensor": {
  		code: 17
  	},
  	"syft.frameworks.torch.tensors.decorators.logging.LoggingTensor": {
  		code: 18
  	},
  	"syft.generic.pointers.multi_pointer.MultiPointerTensor": {
  		code: 19
  	},
  	"syft.generic.pointers.object_pointer.ObjectPointer": {
  		code: 20
  	},
  	"syft.execution.plan.Plan": {
  		code: 21
  	},
  	"syft.execution.state.State": {
  		code: 22
  	},
  	"syft.execution.procedure.Procedure": {
  		code: 23
  	},
  	"syft.execution.protocol.Protocol": {
  		code: 24
  	},
  	"syft.generic.pointers.pointer_tensor.PointerTensor": {
  		code: 25
  	},
  	"syft.generic.pointers.pointer_plan.PointerPlan": {
  		code: 26
  	},
  	"syft.generic.pointers.pointer_protocol.PointerProtocol": {
  		code: 27
  	},
  	"syft.generic.pointers.object_wrapper.ObjectWrapper": {
  		code: 28
  	},
  	"syft.federated.train_config.TrainConfig": {
  		code: 29
  	},
  	"syft.workers.base.BaseWorker": {
  		code: 30,
  		forced_code: 43
  	},
  	"syft.frameworks.torch.tensors.interpreters.autograd.AutogradTensor": {
  		code: 31
  	},
  	"syft.messaging.message.Message": {
  		code: 32
  	},
  	"syft.messaging.message.TensorCommandMessage": {
  		code: 33
  	},
  	"syft.messaging.message.ObjectMessage": {
  		code: 34
  	},
  	"syft.messaging.message.ObjectRequestMessage": {
  		code: 35
  	},
  	"syft.messaging.message.IsNoneMessage": {
  		code: 36
  	},
  	"syft.messaging.message.GetShapeMessage": {
  		code: 37
  	},
  	"syft.messaging.message.ForceObjectDeleteMessage": {
  		code: 38
  	},
  	"syft.messaging.message.SearchMessage": {
  		code: 39
  	},
  	"syft.messaging.message.PlanCommandMessage": {
  		code: 40
  	},
  	"syft.exceptions.GetNotPermittedError": {
  		code: 41
  	},
  	"syft.exceptions.ResponseSignatureError": {
  		code: 42
  	},
  	"syft.generic.string.String": {
  		code: 44
  	},
  	"syft.frameworks.torch.tensors.interpreters.promise.PromiseTensor": {
  		code: 45
  	},
  	"syft.frameworks.torch.tensors.interpreters.private.PrivateTensor": {
  		code: 46
  	},
  	"syft.frameworks.torch.tensors.interpreters.gradients_core.GradFunc": {
  		code: 47
  	},
  	"syft.execution.placeholder.PlaceHolder": {
  		code: 48
  	},
  	"torch.memory_format": {
  		code: 49
  	},
  	"syft.messaging.message.CryptenInitPlan": {
  		code: 50
  	},
  	"syft.frameworks.torch.fl.dataset.BaseDataset": {
  		code: 51
  	},
  	"torch.dtype": {
  		code: 52
  	},
  	"syft.messaging.message.WorkerCommandMessage": {
  		code: 53
  	},
  	"syft.execution.computation.ComputationAction": {
  		code: 54
  	},
  	"syft.execution.communication.CommunicationAction": {
  		code: 55
  	},
  	"syft.execution.placeholder_id.PlaceholderId": {
  		code: 56
  	},
  	"syft.generic.pointers.pointer_dataset.PointerDataset": {
  		code: 57
  	},
  	"syft.execution.role.Role": {
  		code: 58
  	},
  	"syft.frameworks.torch.tensors.interpreters.paillier.PaillierTensor": {
  		code: 59
  	},
  	"syft.messaging.message.CryptenInitJail": {
  		code: 60
  	},
  	type: {
  		code: 61
  	},
  	"syft.execution.type_wrapper.NestedTypeWrapper": {
  		code: 62
  	},
  	"syft.workers.virtual.VirtualWorker": {
  		code: 63,
  		forced_code: 64
  	},
  	"syft.execution.role_assignments.RoleAssignments": {
  		code: 65
  	},
  	"syft.frameworks.torch.tensors.interpreters.fv.FVTensor": {
  		code: 66
  	},
  	"syft.execution.storage_actions.StorageAction": {
  		code: 67
  	}
  };
  var proto = {
  	_DOC: _DOC,
  	VERSION: VERSION,
  	TYPES: TYPES
  };

  var proto$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _DOC: _DOC,
    VERSION: VERSION,
    TYPES: TYPES,
    'default': proto
  });

  var aspromise = asPromise;

  /**
   * Callback as used by {@link util.asPromise}.
   * @typedef asPromiseCallback
   * @type {function}
   * @param {Error|null} error Error, if any
   * @param {...*} params Additional arguments
   * @returns {undefined}
   */

  /**
   * Returns a promise from a node-style callback function.
   * @memberof util
   * @param {asPromiseCallback} fn Function to call
   * @param {*} ctx Function context
   * @param {...*} params Function arguments
   * @returns {Promise<*>} Promisified function
   */
  function asPromise(fn, ctx/*, varargs */) {
      var params  = new Array(arguments.length - 1),
          offset  = 0,
          index   = 2,
          pending = true;
      while (index < arguments.length)
          params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err/*, varargs */) {
              if (pending) {
                  pending = false;
                  if (err)
                      reject(err);
                  else {
                      var params = new Array(arguments.length - 1),
                          offset = 0;
                      while (offset < params.length)
                          params[offset++] = arguments[offset];
                      resolve.apply(null, params);
                  }
              }
          };
          try {
              fn.apply(ctx || null, params);
          } catch (err) {
              if (pending) {
                  pending = false;
                  reject(err);
              }
          }
      });
  }

  var base64_1 = createCommonjsModule(function (module, exports) {

  /**
   * A minimal base64 implementation for number arrays.
   * @memberof util
   * @namespace
   */
  var base64 = exports;

  /**
   * Calculates the byte length of a base64 encoded string.
   * @param {string} string Base64 encoded string
   * @returns {number} Byte length
   */
  base64.length = function length(string) {
      var p = string.length;
      if (!p)
          return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
          ++n;
      return Math.ceil(string.length * 3) / 4 - n;
  };

  // Base64 encoding table
  var b64 = new Array(64);

  // Base64 decoding table
  var s64 = new Array(123);

  // 65..90, 97..122, 48..57, 43, 47
  for (var i = 0; i < 64;)
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

  /**
   * Encodes a buffer to a base64 encoded string.
   * @param {Uint8Array} buffer Source buffer
   * @param {number} start Source start
   * @param {number} end Source end
   * @returns {string} Base64 encoded string
   */
  base64.encode = function encode(buffer, start, end) {
      var parts = null,
          chunk = [];
      var i = 0, // output index
          j = 0, // goto index
          t;     // temporary
      while (start < end) {
          var b = buffer[start++];
          switch (j) {
              case 0:
                  chunk[i++] = b64[b >> 2];
                  t = (b & 3) << 4;
                  j = 1;
                  break;
              case 1:
                  chunk[i++] = b64[t | b >> 4];
                  t = (b & 15) << 2;
                  j = 2;
                  break;
              case 2:
                  chunk[i++] = b64[t | b >> 6];
                  chunk[i++] = b64[b & 63];
                  j = 0;
                  break;
          }
          if (i > 8191) {
              (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
              i = 0;
          }
      }
      if (j) {
          chunk[i++] = b64[t];
          chunk[i++] = 61;
          if (j === 1)
              chunk[i++] = 61;
      }
      if (parts) {
          if (i)
              parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
  };

  var invalidEncoding = "invalid encoding";

  /**
   * Decodes a base64 encoded string to a buffer.
   * @param {string} string Source string
   * @param {Uint8Array} buffer Destination buffer
   * @param {number} offset Destination offset
   * @returns {number} Number of bytes written
   * @throws {Error} If encoding is invalid
   */
  base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, // goto index
          t;     // temporary
      for (var i = 0; i < string.length;) {
          var c = string.charCodeAt(i++);
          if (c === 61 && j > 1)
              break;
          if ((c = s64[c]) === undefined)
              throw Error(invalidEncoding);
          switch (j) {
              case 0:
                  t = c;
                  j = 1;
                  break;
              case 1:
                  buffer[offset++] = t << 2 | (c & 48) >> 4;
                  t = c;
                  j = 2;
                  break;
              case 2:
                  buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                  t = c;
                  j = 3;
                  break;
              case 3:
                  buffer[offset++] = (t & 3) << 6 | c;
                  j = 0;
                  break;
          }
      }
      if (j === 1)
          throw Error(invalidEncoding);
      return offset - start;
  };

  /**
   * Tests if the specified string appears to be base64 encoded.
   * @param {string} string String to test
   * @returns {boolean} `true` if probably base64 encoded, otherwise false
   */
  base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
  });

  var eventemitter = EventEmitter;

  /**
   * Constructs a new event emitter instance.
   * @classdesc A minimal event emitter.
   * @memberof util
   * @constructor
   */
  function EventEmitter() {

      /**
       * Registered listeners.
       * @type {Object.<string,*>}
       * @private
       */
      this._listeners = {};
  }

  /**
   * Registers an event listener.
   * @param {string} evt Event name
   * @param {function} fn Listener
   * @param {*} [ctx] Listener context
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn  : fn,
          ctx : ctx || this
      });
      return this;
  };

  /**
   * Removes an event listener or any matching listeners if arguments are omitted.
   * @param {string} [evt] Event name. Removes all listeners if omitted.
   * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === undefined)
          this._listeners = {};
      else {
          if (fn === undefined)
              this._listeners[evt] = [];
          else {
              var listeners = this._listeners[evt];
              for (var i = 0; i < listeners.length;)
                  if (listeners[i].fn === fn)
                      listeners.splice(i, 1);
                  else
                      ++i;
          }
      }
      return this;
  };

  /**
   * Emits an event by calling its listeners with the specified arguments.
   * @param {string} evt Event name
   * @param {...*} args Arguments
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
          var args = [],
              i = 1;
          for (; i < arguments.length;)
              args.push(arguments[i++]);
          for (i = 0; i < listeners.length;)
              listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
  };

  var float_1 = factory(factory);

  /**
   * Reads / writes floats / doubles from / to buffers.
   * @name util.float
   * @namespace
   */

  /**
   * Writes a 32 bit float to a buffer using little endian byte order.
   * @name util.float.writeFloatLE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Writes a 32 bit float to a buffer using big endian byte order.
   * @name util.float.writeFloatBE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Reads a 32 bit float from a buffer using little endian byte order.
   * @name util.float.readFloatLE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Reads a 32 bit float from a buffer using big endian byte order.
   * @name util.float.readFloatBE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Writes a 64 bit double to a buffer using little endian byte order.
   * @name util.float.writeDoubleLE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Writes a 64 bit double to a buffer using big endian byte order.
   * @name util.float.writeDoubleBE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Reads a 64 bit double from a buffer using little endian byte order.
   * @name util.float.readDoubleLE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Reads a 64 bit double from a buffer using big endian byte order.
   * @name util.float.readDoubleBE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  // Factory function for the purpose of node-based testing in modified global environments
  function factory(exports) {

      // float: typed array
      if (typeof Float32Array !== "undefined") (function() {

          var f32 = new Float32Array([ -0 ]),
              f8b = new Uint8Array(f32.buffer),
              le  = f8b[3] === 128;

          function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos    ] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
          }

          function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos    ] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
          }

          /* istanbul ignore next */
          exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          /* istanbul ignore next */
          exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

          function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos    ];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
          }

          function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos    ];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
          }

          /* istanbul ignore next */
          exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          /* istanbul ignore next */
          exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

      // float: ieee754
      })(); else (function() {

          function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                  val = -val;
              if (val === 0)
                  writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
              else if (isNaN(val))
                  writeUint(2143289344, buf, pos);
              else if (val > 3.4028234663852886e+38) // +-Infinity
                  writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
              else if (val < 1.1754943508222875e-38) // denormal
                  writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
              else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2),
                      mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                  writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
              }
          }

          exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

          function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos),
                  sign = (uint >> 31) * 2 + 1,
                  exponent = uint >>> 23 & 255,
                  mantissa = uint & 8388607;
              return exponent === 255
                  ? mantissa
                  ? NaN
                  : sign * Infinity
                  : exponent === 0 // denormal
                  ? sign * 1.401298464324817e-45 * mantissa
                  : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }

          exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

      })();

      // double: typed array
      if (typeof Float64Array !== "undefined") (function() {

          var f64 = new Float64Array([-0]),
              f8b = new Uint8Array(f64.buffer),
              le  = f8b[7] === 128;

          function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos    ] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
          }

          function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos    ] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
          }

          /* istanbul ignore next */
          exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          /* istanbul ignore next */
          exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

          function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos    ];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
          }

          function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos    ];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
          }

          /* istanbul ignore next */
          exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          /* istanbul ignore next */
          exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

      // double: ieee754
      })(); else (function() {

          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                  val = -val;
              if (val === 0) {
                  writeUint(0, buf, pos + off0);
                  writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
              } else if (isNaN(val)) {
                  writeUint(0, buf, pos + off0);
                  writeUint(2146959360, buf, pos + off1);
              } else if (val > 1.7976931348623157e+308) { // +-Infinity
                  writeUint(0, buf, pos + off0);
                  writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
              } else {
                  var mantissa;
                  if (val < 2.2250738585072014e-308) { // denormal
                      mantissa = val / 5e-324;
                      writeUint(mantissa >>> 0, buf, pos + off0);
                      writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                  } else {
                      var exponent = Math.floor(Math.log(val) / Math.LN2);
                      if (exponent === 1024)
                          exponent = 1023;
                      mantissa = val * Math.pow(2, -exponent);
                      writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                      writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                  }
              }
          }

          exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0),
                  hi = readUint(buf, pos + off1);
              var sign = (hi >> 31) * 2 + 1,
                  exponent = hi >>> 20 & 2047,
                  mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047
                  ? mantissa
                  ? NaN
                  : sign * Infinity
                  : exponent === 0 // denormal
                  ? sign * 5e-324 * mantissa
                  : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }

          exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

      })();

      return exports;
  }

  // uint helpers

  function writeUintLE(val, buf, pos) {
      buf[pos    ] =  val        & 255;
      buf[pos + 1] =  val >>> 8  & 255;
      buf[pos + 2] =  val >>> 16 & 255;
      buf[pos + 3] =  val >>> 24;
  }

  function writeUintBE(val, buf, pos) {
      buf[pos    ] =  val >>> 24;
      buf[pos + 1] =  val >>> 16 & 255;
      buf[pos + 2] =  val >>> 8  & 255;
      buf[pos + 3] =  val        & 255;
  }

  function readUintLE(buf, pos) {
      return (buf[pos    ]
            | buf[pos + 1] << 8
            | buf[pos + 2] << 16
            | buf[pos + 3] << 24) >>> 0;
  }

  function readUintBE(buf, pos) {
      return (buf[pos    ] << 24
            | buf[pos + 1] << 16
            | buf[pos + 2] << 8
            | buf[pos + 3]) >>> 0;
  }

  var inquire_1 = inquire;

  /**
   * Requires a module only if available.
   * @memberof util
   * @param {string} moduleName Module to require
   * @returns {?Object} Required module if available and not empty, otherwise `null`
   */
  function inquire(moduleName) {
      try {
          var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
          if (mod && (mod.length || Object.keys(mod).length))
              return mod;
      } catch (e) {} // eslint-disable-line no-empty
      return null;
  }

  var utf8_1 = createCommonjsModule(function (module, exports) {

  /**
   * A minimal UTF8 implementation for number arrays.
   * @memberof util
   * @namespace
   */
  var utf8 = exports;

  /**
   * Calculates the UTF8 byte length of a string.
   * @param {string} string String
   * @returns {number} Byte length
   */
  utf8.length = function utf8_length(string) {
      var len = 0,
          c = 0;
      for (var i = 0; i < string.length; ++i) {
          c = string.charCodeAt(i);
          if (c < 128)
              len += 1;
          else if (c < 2048)
              len += 2;
          else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
              ++i;
              len += 4;
          } else
              len += 3;
      }
      return len;
  };

  /**
   * Reads UTF8 bytes as a string.
   * @param {Uint8Array} buffer Source buffer
   * @param {number} start Source start
   * @param {number} end Source end
   * @returns {string} String read
   */
  utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
          return "";
      var parts = null,
          chunk = [],
          i = 0, // char offset
          t;     // temporary
      while (start < end) {
          t = buffer[start++];
          if (t < 128)
              chunk[i++] = t;
          else if (t > 191 && t < 224)
              chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
          else if (t > 239 && t < 365) {
              t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
              chunk[i++] = 0xD800 + (t >> 10);
              chunk[i++] = 0xDC00 + (t & 1023);
          } else
              chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
          if (i > 8191) {
              (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
              i = 0;
          }
      }
      if (parts) {
          if (i)
              parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
  };

  /**
   * Writes a string as UTF8 bytes.
   * @param {string} string Source string
   * @param {Uint8Array} buffer Destination buffer
   * @param {number} offset Destination offset
   * @returns {number} Bytes written
   */
  utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset,
          c1, // character 1
          c2; // character 2
      for (var i = 0; i < string.length; ++i) {
          c1 = string.charCodeAt(i);
          if (c1 < 128) {
              buffer[offset++] = c1;
          } else if (c1 < 2048) {
              buffer[offset++] = c1 >> 6       | 192;
              buffer[offset++] = c1       & 63 | 128;
          } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
              c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
              ++i;
              buffer[offset++] = c1 >> 18      | 240;
              buffer[offset++] = c1 >> 12 & 63 | 128;
              buffer[offset++] = c1 >> 6  & 63 | 128;
              buffer[offset++] = c1       & 63 | 128;
          } else {
              buffer[offset++] = c1 >> 12      | 224;
              buffer[offset++] = c1 >> 6  & 63 | 128;
              buffer[offset++] = c1       & 63 | 128;
          }
      }
      return offset - start;
  };
  });

  var pool_1 = pool;

  /**
   * An allocator as used by {@link util.pool}.
   * @typedef PoolAllocator
   * @type {function}
   * @param {number} size Buffer size
   * @returns {Uint8Array} Buffer
   */

  /**
   * A slicer as used by {@link util.pool}.
   * @typedef PoolSlicer
   * @type {function}
   * @param {number} start Start offset
   * @param {number} end End offset
   * @returns {Uint8Array} Buffer slice
   * @this {Uint8Array}
   */

  /**
   * A general purpose buffer pool.
   * @memberof util
   * @function
   * @param {PoolAllocator} alloc Allocator
   * @param {PoolSlicer} slice Slicer
   * @param {number} [size=8192] Slab size
   * @returns {PoolAllocator} Pooled allocator
   */
  function pool(alloc, slice, size) {
      var SIZE   = size || 8192;
      var MAX    = SIZE >>> 1;
      var slab   = null;
      var offset = SIZE;
      return function pool_alloc(size) {
          if (size < 1 || size > MAX)
              return alloc(size);
          if (offset + size > SIZE) {
              slab = alloc(SIZE);
              offset = 0;
          }
          var buf = slice.call(slab, offset, offset += size);
          if (offset & 7) // align to 32 bit
              offset = (offset | 7) + 1;
          return buf;
      };
  }

  var longbits = LongBits;



  /**
   * Constructs new long bits.
   * @classdesc Helper class for working with the low and high bits of a 64 bit value.
   * @memberof util
   * @constructor
   * @param {number} lo Low 32 bits, unsigned
   * @param {number} hi High 32 bits, unsigned
   */
  function LongBits(lo, hi) {

      // note that the casts below are theoretically unnecessary as of today, but older statically
      // generated converter code might still call the ctor with signed 32bits. kept for compat.

      /**
       * Low bits.
       * @type {number}
       */
      this.lo = lo >>> 0;

      /**
       * High bits.
       * @type {number}
       */
      this.hi = hi >>> 0;
  }

  /**
   * Zero bits.
   * @memberof util.LongBits
   * @type {util.LongBits}
   */
  var zero = LongBits.zero = new LongBits(0, 0);

  zero.toNumber = function() { return 0; };
  zero.zzEncode = zero.zzDecode = function() { return this; };
  zero.length = function() { return 1; };

  /**
   * Zero hash.
   * @memberof util.LongBits
   * @type {string}
   */
  var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

  /**
   * Constructs new long bits from the specified number.
   * @param {number} value Value
   * @returns {util.LongBits} Instance
   */
  LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
          return zero;
      var sign = value < 0;
      if (sign)
          value = -value;
      var lo = value >>> 0,
          hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
              lo = 0;
              if (++hi > 4294967295)
                  hi = 0;
          }
      }
      return new LongBits(lo, hi);
  };

  /**
   * Constructs new long bits from a number, long or string.
   * @param {Long|number|string} value Value
   * @returns {util.LongBits} Instance
   */
  LongBits.from = function from(value) {
      if (typeof value === "number")
          return LongBits.fromNumber(value);
      if (minimal.isString(value)) {
          /* istanbul ignore else */
          if (minimal.Long)
              value = minimal.Long.fromString(value);
          else
              return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };

  /**
   * Converts this long bits to a possibly unsafe JavaScript number.
   * @param {boolean} [unsigned=false] Whether unsigned or not
   * @returns {number} Possibly unsafe number
   */
  LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0,
              hi = ~this.hi     >>> 0;
          if (!lo)
              hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
  };

  /**
   * Converts this long bits to a long.
   * @param {boolean} [unsigned=false] Whether unsigned or not
   * @returns {Long} Long
   */
  LongBits.prototype.toLong = function toLong(unsigned) {
      return minimal.Long
          ? new minimal.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
          /* istanbul ignore next */
          : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };

  var charCodeAt = String.prototype.charCodeAt;

  /**
   * Constructs new long bits from the specified 8 characters long hash.
   * @param {string} hash Hash
   * @returns {util.LongBits} Bits
   */
  LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
          return zero;
      return new LongBits(
          ( charCodeAt.call(hash, 0)
          | charCodeAt.call(hash, 1) << 8
          | charCodeAt.call(hash, 2) << 16
          | charCodeAt.call(hash, 3) << 24) >>> 0
      ,
          ( charCodeAt.call(hash, 4)
          | charCodeAt.call(hash, 5) << 8
          | charCodeAt.call(hash, 6) << 16
          | charCodeAt.call(hash, 7) << 24) >>> 0
      );
  };

  /**
   * Converts this long bits to a 8 characters long hash.
   * @returns {string} Hash
   */
  LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
          this.lo        & 255,
          this.lo >>> 8  & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24      ,
          this.hi        & 255,
          this.hi >>> 8  & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
      );
  };

  /**
   * Zig-zag encodes this long bits.
   * @returns {util.LongBits} `this`
   */
  LongBits.prototype.zzEncode = function zzEncode() {
      var mask =   this.hi >> 31;
      this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
      return this;
  };

  /**
   * Zig-zag decodes this long bits.
   * @returns {util.LongBits} `this`
   */
  LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
      return this;
  };

  /**
   * Calculates the length of this longbits when encoded as a varint.
   * @returns {number} Length
   */
  LongBits.prototype.length = function length() {
      var part0 =  this.lo,
          part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
          part2 =  this.hi >>> 24;
      return part2 === 0
           ? part1 === 0
             ? part0 < 16384
               ? part0 < 128 ? 1 : 2
               : part0 < 2097152 ? 3 : 4
             : part1 < 16384
               ? part1 < 128 ? 5 : 6
               : part1 < 2097152 ? 7 : 8
           : part2 < 128 ? 9 : 10;
  };

  var minimal = createCommonjsModule(function (module, exports) {
  var util = exports;

  // used to return a Promise where callback is omitted
  util.asPromise = aspromise;

  // converts to / from base64 encoded strings
  util.base64 = base64_1;

  // base class of rpc.Service
  util.EventEmitter = eventemitter;

  // float handling accross browsers
  util.float = float_1;

  // requires modules optionally and hides the call from bundlers
  util.inquire = inquire_1;

  // converts to / from utf8 encoded strings
  util.utf8 = utf8_1;

  // provides a node-like buffer pool in the browser
  util.pool = pool_1;

  // utility to work with the low and high bits of a 64 bit value
  util.LongBits = longbits;

  // global object reference
  util.global = typeof window !== "undefined" && window
             || typeof commonjsGlobal !== "undefined" && commonjsGlobal
             || typeof self   !== "undefined" && self
             || commonjsGlobal; // eslint-disable-line no-invalid-this

  /**
   * An immuable empty array.
   * @memberof util
   * @type {Array.<*>}
   * @const
   */
  util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

  /**
   * An immutable empty object.
   * @type {Object}
   * @const
   */
  util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

  /**
   * Whether running within node or not.
   * @memberof util
   * @type {boolean}
   * @const
   */
  util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);

  /**
   * Tests if the specified value is an integer.
   * @function
   * @param {*} value Value to test
   * @returns {boolean} `true` if the value is an integer
   */
  util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };

  /**
   * Tests if the specified value is a string.
   * @param {*} value Value to test
   * @returns {boolean} `true` if the value is a string
   */
  util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
  };

  /**
   * Tests if the specified value is a non-null object.
   * @param {*} value Value to test
   * @returns {boolean} `true` if the value is a non-null object
   */
  util.isObject = function isObject(value) {
      return value && typeof value === "object";
  };

  /**
   * Checks if a property on a message is considered to be present.
   * This is an alias of {@link util.isSet}.
   * @function
   * @param {Object} obj Plain object or message instance
   * @param {string} prop Property name
   * @returns {boolean} `true` if considered to be present, otherwise `false`
   */
  util.isset =

  /**
   * Checks if a property on a message is considered to be present.
   * @param {Object} obj Plain object or message instance
   * @param {string} prop Property name
   * @returns {boolean} `true` if considered to be present, otherwise `false`
   */
  util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
  };

  /**
   * Any compatible Buffer instance.
   * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
   * @interface Buffer
   * @extends Uint8Array
   */

  /**
   * Node's Buffer class if available.
   * @type {Constructor<Buffer>}
   */
  util.Buffer = (function() {
      try {
          var Buffer = util.inquire("buffer").Buffer;
          // refuse to use non-node buffers if not explicitly assigned (perf reasons):
          return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
      } catch (e) {
          /* istanbul ignore next */
          return null;
      }
  })();

  // Internal alias of or polyfull for Buffer.from.
  util._Buffer_from = null;

  // Internal alias of or polyfill for Buffer.allocUnsafe.
  util._Buffer_allocUnsafe = null;

  /**
   * Creates a new buffer of whatever type supported by the environment.
   * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
   * @returns {Uint8Array|Buffer} Buffer
   */
  util.newBuffer = function newBuffer(sizeOrArray) {
      /* istanbul ignore next */
      return typeof sizeOrArray === "number"
          ? util.Buffer
              ? util._Buffer_allocUnsafe(sizeOrArray)
              : new util.Array(sizeOrArray)
          : util.Buffer
              ? util._Buffer_from(sizeOrArray)
              : typeof Uint8Array === "undefined"
                  ? sizeOrArray
                  : new Uint8Array(sizeOrArray);
  };

  /**
   * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
   * @type {Constructor<Uint8Array>}
   */
  util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

  /**
   * Any compatible Long instance.
   * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
   * @interface Long
   * @property {number} low Low bits
   * @property {number} high High bits
   * @property {boolean} unsigned Whether unsigned or not
   */

  /**
   * Long.js's Long class if available.
   * @type {Constructor<Long>}
   */
  util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
           || /* istanbul ignore next */ util.global.Long
           || util.inquire("long");

  /**
   * Regular expression used to verify 2 bit (`bool`) map keys.
   * @type {RegExp}
   * @const
   */
  util.key2Re = /^true|false|0|1$/;

  /**
   * Regular expression used to verify 32 bit (`int32` etc.) map keys.
   * @type {RegExp}
   * @const
   */
  util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

  /**
   * Regular expression used to verify 64 bit (`int64` etc.) map keys.
   * @type {RegExp}
   * @const
   */
  util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

  /**
   * Converts a number or long to an 8 characters long hash string.
   * @param {Long|number} value Value to convert
   * @returns {string} Hash
   */
  util.longToHash = function longToHash(value) {
      return value
          ? util.LongBits.from(value).toHash()
          : util.LongBits.zeroHash;
  };

  /**
   * Converts an 8 characters long hash string to a long or number.
   * @param {string} hash Hash
   * @param {boolean} [unsigned=false] Whether unsigned or not
   * @returns {Long|number} Original value
   */
  util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
  };

  /**
   * Merges the properties of the source object into the destination object.
   * @memberof util
   * @param {Object.<string,*>} dst Destination object
   * @param {Object.<string,*>} src Source object
   * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
   * @returns {Object.<string,*>} Destination object
   */
  function merge(dst, src, ifNotSet) { // used by converters
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
          if (dst[keys[i]] === undefined || !ifNotSet)
              dst[keys[i]] = src[keys[i]];
      return dst;
  }

  util.merge = merge;

  /**
   * Converts the first character of a string to lower case.
   * @param {string} str String to convert
   * @returns {string} Converted string
   */
  util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
  };

  /**
   * Creates a custom error constructor.
   * @memberof util
   * @param {string} name Error name
   * @returns {Constructor<Error>} Custom error constructor
   */
  function newError(name) {

      function CustomError(message, properties) {

          if (!(this instanceof CustomError))
              return new CustomError(message, properties);

          // Error.call(this, message);
          // ^ just returns a new error instance because the ctor can be called as a function

          Object.defineProperty(this, "message", { get: function() { return message; } });

          /* istanbul ignore next */
          if (Error.captureStackTrace) // node
              Error.captureStackTrace(this, CustomError);
          else
              Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

          if (properties)
              merge(this, properties);
      }

      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

      Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

      CustomError.prototype.toString = function toString() {
          return this.name + ": " + this.message;
      };

      return CustomError;
  }

  util.newError = newError;

  /**
   * Constructs a new protocol error.
   * @classdesc Error subclass indicating a protocol specifc error.
   * @memberof util
   * @extends Error
   * @template T extends Message<T>
   * @constructor
   * @param {string} message Error message
   * @param {Object.<string,*>} [properties] Additional properties
   * @example
   * try {
   *     MyMessage.decode(someBuffer); // throws if required fields are missing
   * } catch (e) {
   *     if (e instanceof ProtocolError && e.instance)
   *         console.log("decoded so far: " + JSON.stringify(e.instance));
   * }
   */
  util.ProtocolError = newError("ProtocolError");

  /**
   * So far decoded message instance.
   * @name util.ProtocolError#instance
   * @type {Message<T>}
   */

  /**
   * A OneOf getter as returned by {@link util.oneOfGetter}.
   * @typedef OneOfGetter
   * @type {function}
   * @returns {string|undefined} Set field name, if any
   */

  /**
   * Builds a getter for a oneof's present field name.
   * @param {string[]} fieldNames Field names
   * @returns {OneOfGetter} Unbound getter
   */
  util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
          fieldMap[fieldNames[i]] = 1;

      /**
       * @returns {string|undefined} Set field name, if any
       * @this Object
       * @ignore
       */
      return function() { // eslint-disable-line consistent-return
          for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
              if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                  return keys[i];
      };
  };

  /**
   * A OneOf setter as returned by {@link util.oneOfSetter}.
   * @typedef OneOfSetter
   * @type {function}
   * @param {string|undefined} value Field name
   * @returns {undefined}
   */

  /**
   * Builds a setter for a oneof's present field name.
   * @param {string[]} fieldNames Field names
   * @returns {OneOfSetter} Unbound setter
   */
  util.oneOfSetter = function setOneOf(fieldNames) {

      /**
       * @param {string} name Field name
       * @returns {undefined}
       * @this Object
       * @ignore
       */
      return function(name) {
          for (var i = 0; i < fieldNames.length; ++i)
              if (fieldNames[i] !== name)
                  delete this[fieldNames[i]];
      };
  };

  /**
   * Default conversion options used for {@link Message#toJSON} implementations.
   *
   * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
   *
   * - Longs become strings
   * - Enums become string keys
   * - Bytes become base64 encoded strings
   * - (Sub-)Messages become plain objects
   * - Maps become plain objects with all string keys
   * - Repeated fields become arrays
   * - NaN and Infinity for float and double fields become strings
   *
   * @type {IConversionOptions}
   * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
   */
  util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
  };

  // Sets up buffer utility according to the environment (called in index-minimal)
  util._configure = function() {
      var Buffer = util.Buffer;
      /* istanbul ignore if */
      if (!Buffer) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
      }
      // because node 4.x buffers are incompatible & immutable
      // see: https://github.com/dcodeIO/protobuf.js/pull/665
      util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
          /* istanbul ignore next */
          function Buffer_from(value, encoding) {
              return new Buffer(value, encoding);
          };
      util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
          /* istanbul ignore next */
          function Buffer_allocUnsafe(size) {
              return new Buffer(size);
          };
  };
  });

  var writer = Writer;



  var BufferWriter; // cyclic

  var LongBits$1  = minimal.LongBits,
      base64    = minimal.base64,
      utf8      = minimal.utf8;

  /**
   * Constructs a new writer operation instance.
   * @classdesc Scheduled writer operation.
   * @constructor
   * @param {function(*, Uint8Array, number)} fn Function to call
   * @param {number} len Value byte length
   * @param {*} val Value to write
   * @ignore
   */
  function Op(fn, len, val) {

      /**
       * Function to call.
       * @type {function(Uint8Array, number, *)}
       */
      this.fn = fn;

      /**
       * Value byte length.
       * @type {number}
       */
      this.len = len;

      /**
       * Next operation.
       * @type {Writer.Op|undefined}
       */
      this.next = undefined;

      /**
       * Value to write.
       * @type {*}
       */
      this.val = val; // type varies
  }

  /* istanbul ignore next */
  function noop() {} // eslint-disable-line no-empty-function

  /**
   * Constructs a new writer state instance.
   * @classdesc Copied writer state.
   * @memberof Writer
   * @constructor
   * @param {Writer} writer Writer to copy state from
   * @ignore
   */
  function State(writer) {

      /**
       * Current head.
       * @type {Writer.Op}
       */
      this.head = writer.head;

      /**
       * Current tail.
       * @type {Writer.Op}
       */
      this.tail = writer.tail;

      /**
       * Current buffer length.
       * @type {number}
       */
      this.len = writer.len;

      /**
       * Next state.
       * @type {State|null}
       */
      this.next = writer.states;
  }

  /**
   * Constructs a new writer instance.
   * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
   * @constructor
   */
  function Writer() {

      /**
       * Current length.
       * @type {number}
       */
      this.len = 0;

      /**
       * Operations head.
       * @type {Object}
       */
      this.head = new Op(noop, 0, 0);

      /**
       * Operations tail
       * @type {Object}
       */
      this.tail = this.head;

      /**
       * Linked forked states.
       * @type {Object|null}
       */
      this.states = null;

      // When a value is written, the writer calculates its byte length and puts it into a linked
      // list of operations to perform when finish() is called. This both allows us to allocate
      // buffers of the exact required size and reduces the amount of work we have to do compared
      // to first calculating over objects and then encoding over objects. In our case, the encoding
      // part is just a linked list walk calling operations with already prepared values.
  }

  /**
   * Creates a new writer.
   * @function
   * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
   */
  Writer.create = minimal.Buffer
      ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
              return new BufferWriter();
          })();
      }
      /* istanbul ignore next */
      : function create_array() {
          return new Writer();
      };

  /**
   * Allocates a buffer of the specified size.
   * @param {number} size Buffer size
   * @returns {Uint8Array} Buffer
   */
  Writer.alloc = function alloc(size) {
      return new minimal.Array(size);
  };

  // Use Uint8Array buffer pool in the browser, just like node does with buffers
  /* istanbul ignore else */
  if (minimal.Array !== Array)
      Writer.alloc = minimal.pool(Writer.alloc, minimal.Array.prototype.subarray);

  /**
   * Pushes a new operation to the queue.
   * @param {function(Uint8Array, number, *)} fn Function to call
   * @param {number} len Value byte length
   * @param {number} val Value to write
   * @returns {Writer} `this`
   * @private
   */
  Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
  };

  function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
  }

  function writeVarint32(val, buf, pos) {
      while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
      }
      buf[pos] = val;
  }

  /**
   * Constructs a new varint writer operation instance.
   * @classdesc Scheduled varint writer operation.
   * @extends Op
   * @constructor
   * @param {number} len Value byte length
   * @param {number} val Value to write
   * @ignore
   */
  function VarintOp(len, val) {
      this.len = len;
      this.next = undefined;
      this.val = val;
  }

  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;

  /**
   * Writes an unsigned 32 bit value as a varint.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.uint32 = function write_uint32(value) {
      // here, the call to this.push has been inlined and a varint specific Op subclass is used.
      // uint32 is by far the most frequently used operation and benefits significantly from this.
      this.len += (this.tail = this.tail.next = new VarintOp(
          (value = value >>> 0)
                  < 128       ? 1
          : value < 16384     ? 2
          : value < 2097152   ? 3
          : value < 268435456 ? 4
          :                     5,
      value)).len;
      return this;
  };

  /**
   * Writes a signed 32 bit value as a varint.
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.int32 = function write_int32(value) {
      return value < 0
          ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) // 10 bytes per spec
          : this.uint32(value);
  };

  /**
   * Writes a 32 bit value as a varint, zig-zag encoded.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };

  function writeVarint64(val, buf, pos) {
      while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
      }
      while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
  }

  /**
   * Writes an unsigned 64 bit value as a varint.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits$1.from(value);
      return this._push(writeVarint64, bits.length(), bits);
  };

  /**
   * Writes a signed 64 bit value as a varint.
   * @function
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.int64 = Writer.prototype.uint64;

  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits$1.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
  };

  /**
   * Writes a boolish value as a varint.
   * @param {boolean} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
  };

  function writeFixed32(val, buf, pos) {
      buf[pos    ] =  val         & 255;
      buf[pos + 1] =  val >>> 8   & 255;
      buf[pos + 2] =  val >>> 16  & 255;
      buf[pos + 3] =  val >>> 24;
  }

  /**
   * Writes an unsigned 32 bit value as fixed 32 bits.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
  };

  /**
   * Writes a signed 32 bit value as fixed 32 bits.
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;

  /**
   * Writes an unsigned 64 bit value as fixed 64 bits.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits$1.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };

  /**
   * Writes a signed 64 bit value as fixed 64 bits.
   * @function
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;

  /**
   * Writes a float (32 bit).
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.float = function write_float(value) {
      return this._push(minimal.float.writeFloatLE, 4, value);
  };

  /**
   * Writes a double (64 bit float).
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.double = function write_double(value) {
      return this._push(minimal.float.writeDoubleLE, 8, value);
  };

  var writeBytes = minimal.Array.prototype.set
      ? function writeBytes_set(val, buf, pos) {
          buf.set(val, pos); // also works for plain array values
      }
      /* istanbul ignore next */
      : function writeBytes_for(val, buf, pos) {
          for (var i = 0; i < val.length; ++i)
              buf[pos + i] = val[i];
      };

  /**
   * Writes a sequence of bytes.
   * @param {Uint8Array|string} value Buffer or base64 encoded string to write
   * @returns {Writer} `this`
   */
  Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
          return this._push(writeByte, 1, 0);
      if (minimal.isString(value)) {
          var buf = Writer.alloc(len = base64.length(value));
          base64.decode(value, buf, 0);
          value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
  };

  /**
   * Writes a string.
   * @param {string} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len
          ? this.uint32(len)._push(utf8.write, len, value)
          : this._push(writeByte, 1, 0);
  };

  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   * @returns {Writer} `this`
   */
  Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
  };

  /**
   * Resets this instance to the last state.
   * @returns {Writer} `this`
   */
  Writer.prototype.reset = function reset() {
      if (this.states) {
          this.head   = this.states.head;
          this.tail   = this.states.tail;
          this.len    = this.states.len;
          this.states = this.states.next;
      } else {
          this.head = this.tail = new Op(noop, 0, 0);
          this.len  = 0;
      }
      return this;
  };

  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   * @returns {Writer} `this`
   */
  Writer.prototype.ldelim = function ldelim() {
      var head = this.head,
          tail = this.tail,
          len  = this.len;
      this.reset().uint32(len);
      if (len) {
          this.tail.next = head.next; // skip noop
          this.tail = tail;
          this.len += len;
      }
      return this;
  };

  /**
   * Finishes the write operation.
   * @returns {Uint8Array} Finished buffer
   */
  Writer.prototype.finish = function finish() {
      var head = this.head.next, // skip noop
          buf  = this.constructor.alloc(this.len),
          pos  = 0;
      while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
      }
      // this.head = this.tail = null;
      return buf;
  };

  Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
  };

  var writer_buffer = BufferWriter$1;

  // extends Writer

  (BufferWriter$1.prototype = Object.create(writer.prototype)).constructor = BufferWriter$1;



  var Buffer = minimal.Buffer;

  /**
   * Constructs a new buffer writer instance.
   * @classdesc Wire format writer using node buffers.
   * @extends Writer
   * @constructor
   */
  function BufferWriter$1() {
      writer.call(this);
  }

  /**
   * Allocates a buffer of the specified size.
   * @param {number} size Buffer size
   * @returns {Buffer} Buffer
   */
  BufferWriter$1.alloc = function alloc_buffer(size) {
      return (BufferWriter$1.alloc = minimal._Buffer_allocUnsafe)(size);
  };

  var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
      ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                             // also works for plain array values
      }
      /* istanbul ignore next */
      : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
              val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
              buf[pos++] = val[i++];
      };

  /**
   * @override
   */
  BufferWriter$1.prototype.bytes = function write_bytes_buffer(value) {
      if (minimal.isString(value))
          value = minimal._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
          this._push(writeBytesBuffer, len, value);
      return this;
  };

  function writeStringBuffer(val, buf, pos) {
      if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
          minimal.utf8.write(val, buf, pos);
      else
          buf.utf8Write(val, pos);
  }

  /**
   * @override
   */
  BufferWriter$1.prototype.string = function write_string_buffer(value) {
      var len = Buffer.byteLength(value);
      this.uint32(len);
      if (len)
          this._push(writeStringBuffer, len, value);
      return this;
  };

  var reader = Reader;



  var BufferReader; // cyclic

  var LongBits$2  = minimal.LongBits,
      utf8$1      = minimal.utf8;

  /* istanbul ignore next */
  function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }

  /**
   * Constructs a new reader instance using the specified buffer.
   * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
   * @constructor
   * @param {Uint8Array} buffer Buffer to read from
   */
  function Reader(buffer) {

      /**
       * Read buffer.
       * @type {Uint8Array}
       */
      this.buf = buffer;

      /**
       * Read buffer position.
       * @type {number}
       */
      this.pos = 0;

      /**
       * Read buffer length.
       * @type {number}
       */
      this.len = buffer.length;
  }

  var create_array = typeof Uint8Array !== "undefined"
      ? function create_typed_array(buffer) {
          if (buffer instanceof Uint8Array || Array.isArray(buffer))
              return new Reader(buffer);
          throw Error("illegal buffer");
      }
      /* istanbul ignore next */
      : function create_array(buffer) {
          if (Array.isArray(buffer))
              return new Reader(buffer);
          throw Error("illegal buffer");
      };

  /**
   * Creates a new reader using the specified buffer.
   * @function
   * @param {Uint8Array|Buffer} buffer Buffer to read from
   * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
   * @throws {Error} If `buffer` is not a valid buffer
   */
  Reader.create = minimal.Buffer
      ? function create_buffer_setup(buffer) {
          return (Reader.create = function create_buffer(buffer) {
              return minimal.Buffer.isBuffer(buffer)
                  ? new BufferReader(buffer)
                  /* istanbul ignore next */
                  : create_array(buffer);
          })(buffer);
      }
      /* istanbul ignore next */
      : create_array;

  Reader.prototype._slice = minimal.Array.prototype.subarray || /* istanbul ignore next */ minimal.Array.prototype.slice;

  /**
   * Reads a varint as an unsigned 32 bit value.
   * @function
   * @returns {number} Value read
   */
  Reader.prototype.uint32 = (function read_uint32_setup() {
      var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
      return function read_uint32() {
          value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

          /* istanbul ignore if */
          if ((this.pos += 5) > this.len) {
              this.pos = this.len;
              throw indexOutOfRange(this, 10);
          }
          return value;
      };
  })();

  /**
   * Reads a varint as a signed 32 bit value.
   * @returns {number} Value read
   */
  Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
  };

  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value.
   * @returns {number} Value read
   */
  Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
  };

  /* eslint-disable no-invalid-this */

  function readLongVarint() {
      // tends to deopt with local vars for octet etc.
      var bits = new LongBits$2(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) { // fast route (lo)
          for (; i < 4; ++i) {
              // 1st..4th
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
          // 5th
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
          if (this.buf[this.pos++] < 128)
              return bits;
          i = 0;
      } else {
          for (; i < 3; ++i) {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
              // 1st..3th
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
          // 4th
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
          return bits;
      }
      if (this.len - this.pos > 4) { // fast route (hi)
          for (; i < 5; ++i) {
              // 6th..10th
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
      } else {
          for (; i < 5; ++i) {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
              // 6th..10th
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
      }
      /* istanbul ignore next */
      throw Error("invalid varint encoding");
  }

  /* eslint-enable no-invalid-this */

  /**
   * Reads a varint as a signed 64 bit value.
   * @name Reader#int64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a varint as an unsigned 64 bit value.
   * @name Reader#uint64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value.
   * @name Reader#sint64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a varint as a boolean.
   * @returns {boolean} Value read
   */
  Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
  };

  function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
      return (buf[end - 4]
            | buf[end - 3] << 8
            | buf[end - 2] << 16
            | buf[end - 1] << 24) >>> 0;
  }

  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer.
   * @returns {number} Value read
   */
  Reader.prototype.fixed32 = function read_fixed32() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      return readFixed32_end(this.buf, this.pos += 4);
  };

  /**
   * Reads fixed 32 bits as a signed 32 bit integer.
   * @returns {number} Value read
   */
  Reader.prototype.sfixed32 = function read_sfixed32() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      return readFixed32_end(this.buf, this.pos += 4) | 0;
  };

  /* eslint-disable no-invalid-this */

  function readFixed64(/* this: Reader */) {

      /* istanbul ignore if */
      if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);

      return new LongBits$2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }

  /* eslint-enable no-invalid-this */

  /**
   * Reads fixed 64 bits.
   * @name Reader#fixed64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads zig-zag encoded fixed 64 bits.
   * @name Reader#sfixed64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a float (32 bit) as a number.
   * @function
   * @returns {number} Value read
   */
  Reader.prototype.float = function read_float() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      var value = minimal.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
  };

  /**
   * Reads a double (64 bit float) as a number.
   * @function
   * @returns {number} Value read
   */
  Reader.prototype.double = function read_double() {

      /* istanbul ignore if */
      if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);

      var value = minimal.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
  };

  /**
   * Reads a sequence of bytes preceeded by its length as a varint.
   * @returns {Uint8Array} Value read
   */
  Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(),
          start  = this.pos,
          end    = this.pos + length;

      /* istanbul ignore if */
      if (end > this.len)
          throw indexOutOfRange(this, length);

      this.pos += length;
      if (Array.isArray(this.buf)) // plain array
          return this.buf.slice(start, end);
      return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
          ? new this.buf.constructor(0)
          : this._slice.call(this.buf, start, end);
  };

  /**
   * Reads a string preceeded by its byte length as a varint.
   * @returns {string} Value read
   */
  Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8$1.read(bytes, 0, bytes.length);
  };

  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint.
   * @param {number} [length] Length if known, otherwise a varint is assumed
   * @returns {Reader} `this`
   */
  Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
          /* istanbul ignore if */
          if (this.pos + length > this.len)
              throw indexOutOfRange(this, length);
          this.pos += length;
      } else {
          do {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
      }
      return this;
  };

  /**
   * Skips the next element of the specified wire type.
   * @param {number} wireType Wire type received
   * @returns {Reader} `this`
   */
  Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
          case 0:
              this.skip();
              break;
          case 1:
              this.skip(8);
              break;
          case 2:
              this.skip(this.uint32());
              break;
          case 3:
              while ((wireType = this.uint32() & 7) !== 4) {
                  this.skipType(wireType);
              }
              break;
          case 5:
              this.skip(4);
              break;

          /* istanbul ignore next */
          default:
              throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
  };

  Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;

      var fn = minimal.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
      minimal.merge(Reader.prototype, {

          int64: function read_int64() {
              return readLongVarint.call(this)[fn](false);
          },

          uint64: function read_uint64() {
              return readLongVarint.call(this)[fn](true);
          },

          sint64: function read_sint64() {
              return readLongVarint.call(this).zzDecode()[fn](false);
          },

          fixed64: function read_fixed64() {
              return readFixed64.call(this)[fn](true);
          },

          sfixed64: function read_sfixed64() {
              return readFixed64.call(this)[fn](false);
          }

      });
  };

  var reader_buffer = BufferReader$1;

  // extends Reader

  (BufferReader$1.prototype = Object.create(reader.prototype)).constructor = BufferReader$1;



  /**
   * Constructs a new buffer reader instance.
   * @classdesc Wire format reader using node buffers.
   * @extends Reader
   * @constructor
   * @param {Buffer} buffer Buffer to read from
   */
  function BufferReader$1(buffer) {
      reader.call(this, buffer);

      /**
       * Read buffer.
       * @name BufferReader#buf
       * @type {Buffer}
       */
  }

  /* istanbul ignore else */
  if (minimal.Buffer)
      BufferReader$1.prototype._slice = minimal.Buffer.prototype.slice;

  /**
   * @override
   */
  BufferReader$1.prototype.string = function read_string_buffer() {
      var len = this.uint32(); // modifies pos
      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
  };

  var service = Service;



  // Extends EventEmitter
  (Service.prototype = Object.create(minimal.EventEmitter.prototype)).constructor = Service;

  /**
   * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
   *
   * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
   * @typedef rpc.ServiceMethodCallback
   * @template TRes extends Message<TRes>
   * @type {function}
   * @param {Error|null} error Error, if any
   * @param {TRes} [response] Response message
   * @returns {undefined}
   */

  /**
   * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
   * @typedef rpc.ServiceMethod
   * @template TReq extends Message<TReq>
   * @template TRes extends Message<TRes>
   * @type {function}
   * @param {TReq|Properties<TReq>} request Request message or plain object
   * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
   * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
   */

  /**
   * Constructs a new RPC service instance.
   * @classdesc An RPC service as returned by {@link Service#create}.
   * @exports rpc.Service
   * @extends util.EventEmitter
   * @constructor
   * @param {RPCImpl} rpcImpl RPC implementation
   * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
   * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
   */
  function Service(rpcImpl, requestDelimited, responseDelimited) {

      if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");

      minimal.EventEmitter.call(this);

      /**
       * RPC implementation. Becomes `null` once the service is ended.
       * @type {RPCImpl|null}
       */
      this.rpcImpl = rpcImpl;

      /**
       * Whether requests are length-delimited.
       * @type {boolean}
       */
      this.requestDelimited = Boolean(requestDelimited);

      /**
       * Whether responses are length-delimited.
       * @type {boolean}
       */
      this.responseDelimited = Boolean(responseDelimited);
  }

  /**
   * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
   * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
   * @param {Constructor<TReq>} requestCtor Request constructor
   * @param {Constructor<TRes>} responseCtor Response constructor
   * @param {TReq|Properties<TReq>} request Request message or plain object
   * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
   * @returns {undefined}
   * @template TReq extends Message<TReq>
   * @template TRes extends Message<TRes>
   */
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

      if (!request)
          throw TypeError("request must be specified");

      var self = this;
      if (!callback)
          return minimal.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

      if (!self.rpcImpl) {
          setTimeout(function() { callback(Error("already ended")); }, 0);
          return undefined;
      }

      try {
          return self.rpcImpl(
              method,
              requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
              function rpcCallback(err, response) {

                  if (err) {
                      self.emit("error", err, method);
                      return callback(err);
                  }

                  if (response === null) {
                      self.end(/* endedByRPC */ true);
                      return undefined;
                  }

                  if (!(response instanceof responseCtor)) {
                      try {
                          response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                      } catch (err) {
                          self.emit("error", err, method);
                          return callback(err);
                      }
                  }

                  self.emit("data", response, method);
                  return callback(null, response);
              }
          );
      } catch (err) {
          self.emit("error", err, method);
          setTimeout(function() { callback(err); }, 0);
          return undefined;
      }
  };

  /**
   * Ends this service and emits the `end` event.
   * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
   * @returns {rpc.Service} `this`
   */
  Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
          if (!endedByRPC) // signal end to rpcImpl
              this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
      }
      return this;
  };

  var rpc_1 = createCommonjsModule(function (module, exports) {

  /**
   * Streaming RPC helpers.
   * @namespace
   */
  var rpc = exports;

  /**
   * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
   * @typedef RPCImpl
   * @type {function}
   * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
   * @param {Uint8Array} requestData Request data
   * @param {RPCImplCallback} callback Callback function
   * @returns {undefined}
   * @example
   * function rpcImpl(method, requestData, callback) {
   *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
   *         throw Error("no such method");
   *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
   *         callback(err, responseData);
   *     });
   * }
   */

  /**
   * Node-style callback as used by {@link RPCImpl}.
   * @typedef RPCImplCallback
   * @type {function}
   * @param {Error|null} error Error, if any, otherwise `null`
   * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
   * @returns {undefined}
   */

  rpc.Service = service;
  });

  var roots = {};

  var indexMinimal = createCommonjsModule(function (module, exports) {
  var protobuf = exports;

  /**
   * Build type, one of `"full"`, `"light"` or `"minimal"`.
   * @name build
   * @type {string}
   * @const
   */
  protobuf.build = "minimal";

  // Serialization
  protobuf.Writer       = writer;
  protobuf.BufferWriter = writer_buffer;
  protobuf.Reader       = reader;
  protobuf.BufferReader = reader_buffer;

  // Utility
  protobuf.util         = minimal;
  protobuf.rpc          = rpc_1;
  protobuf.roots        = roots;
  protobuf.configure    = configure;

  /* istanbul ignore next */
  /**
   * Reconfigures the library according to the environment.
   * @returns {undefined}
   */
  function configure() {
      protobuf.Reader._configure(protobuf.BufferReader);
      protobuf.util._configure();
  }

  // Set up buffer utility according to the environment
  protobuf.Writer._configure(protobuf.BufferWriter);
  configure();
  });

  var minimal$1 = indexMinimal;

  // Common aliases
  var $Reader = minimal$1.Reader, $Writer = minimal$1.Writer, $util = minimal$1.util;

  // Exported root namespace
  var $root = minimal$1.roots["default"] || (minimal$1.roots["default"] = {});

  $root.syft_proto = (function() {

      /**
       * Namespace syft_proto.
       * @exports syft_proto
       * @namespace
       */
      var syft_proto = {};

      syft_proto.execution = (function() {

          /**
           * Namespace execution.
           * @memberof syft_proto
           * @namespace
           */
          var execution = {};

          execution.v1 = (function() {

              /**
               * Namespace v1.
               * @memberof syft_proto.execution
               * @namespace
               */
              var v1 = {};

              v1.CommunicationAction = (function() {

                  /**
                   * Properties of a CommunicationAction.
                   * @memberof syft_proto.execution.v1
                   * @interface ICommunicationAction
                   * @property {string|null} [command] CommunicationAction command
                   * @property {syft_proto.types.syft.v1.IId|null} [target_id] CommunicationAction target_id
                   * @property {syft_proto.generic.pointers.v1.IPointerTensor|null} [target_pointer] CommunicationAction target_pointer
                   * @property {syft_proto.execution.v1.IPlaceholderId|null} [target_placeholder_id] CommunicationAction target_placeholder_id
                   * @property {syft_proto.types.torch.v1.ITorchTensor|null} [target_tensor] CommunicationAction target_tensor
                   * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] CommunicationAction args
                   * @property {Object.<string,syft_proto.types.syft.v1.IArg>|null} [kwargs] CommunicationAction kwargs
                   * @property {Array.<syft_proto.types.syft.v1.IId>|null} [return_ids] CommunicationAction return_ids
                   * @property {Array.<syft_proto.execution.v1.IPlaceholderId>|null} [return_placeholder_ids] CommunicationAction return_placeholder_ids
                   */

                  /**
                   * Constructs a new CommunicationAction.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a CommunicationAction.
                   * @implements ICommunicationAction
                   * @constructor
                   * @param {syft_proto.execution.v1.ICommunicationAction=} [properties] Properties to set
                   */
                  function CommunicationAction(properties) {
                      this.args = [];
                      this.kwargs = {};
                      this.return_ids = [];
                      this.return_placeholder_ids = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * CommunicationAction command.
                   * @member {string} command
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.command = "";

                  /**
                   * CommunicationAction target_id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} target_id
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.target_id = null;

                  /**
                   * CommunicationAction target_pointer.
                   * @member {syft_proto.generic.pointers.v1.IPointerTensor|null|undefined} target_pointer
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.target_pointer = null;

                  /**
                   * CommunicationAction target_placeholder_id.
                   * @member {syft_proto.execution.v1.IPlaceholderId|null|undefined} target_placeholder_id
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.target_placeholder_id = null;

                  /**
                   * CommunicationAction target_tensor.
                   * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} target_tensor
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.target_tensor = null;

                  /**
                   * CommunicationAction args.
                   * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.args = $util.emptyArray;

                  /**
                   * CommunicationAction kwargs.
                   * @member {Object.<string,syft_proto.types.syft.v1.IArg>} kwargs
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.kwargs = $util.emptyObject;

                  /**
                   * CommunicationAction return_ids.
                   * @member {Array.<syft_proto.types.syft.v1.IId>} return_ids
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.return_ids = $util.emptyArray;

                  /**
                   * CommunicationAction return_placeholder_ids.
                   * @member {Array.<syft_proto.execution.v1.IPlaceholderId>} return_placeholder_ids
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  CommunicationAction.prototype.return_placeholder_ids = $util.emptyArray;

                  // OneOf field names bound to virtual getters and setters
                  var $oneOfFields;

                  /**
                   * CommunicationAction target.
                   * @member {"target_id"|"target_pointer"|"target_placeholder_id"|"target_tensor"|undefined} target
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   */
                  Object.defineProperty(CommunicationAction.prototype, "target", {
                      get: $util.oneOfGetter($oneOfFields = ["target_id", "target_pointer", "target_placeholder_id", "target_tensor"]),
                      set: $util.oneOfSetter($oneOfFields)
                  });

                  /**
                   * Creates a new CommunicationAction instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @static
                   * @param {syft_proto.execution.v1.ICommunicationAction=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.CommunicationAction} CommunicationAction instance
                   */
                  CommunicationAction.create = function create(properties) {
                      return new CommunicationAction(properties);
                  };

                  /**
                   * Encodes the specified CommunicationAction message. Does not implicitly {@link syft_proto.execution.v1.CommunicationAction.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @static
                   * @param {syft_proto.execution.v1.ICommunicationAction} message CommunicationAction message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  CommunicationAction.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.command != null && message.hasOwnProperty("command"))
                          writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer"))
                          $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.target_pointer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id"))
                          $root.syft_proto.execution.v1.PlaceholderId.encode(message.target_placeholder_id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor"))
                          $root.syft_proto.types.torch.v1.TorchTensor.encode(message.target_tensor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                      if (message.args != null && message.args.length)
                          for (var i = 0; i < message.args.length; ++i)
                              $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                      if (message.kwargs != null && message.hasOwnProperty("kwargs"))
                          for (var keys = Object.keys(message.kwargs), i = 0; i < keys.length; ++i) {
                              writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                              $root.syft_proto.types.syft.v1.Arg.encode(message.kwargs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                          }
                      if (message.return_ids != null && message.return_ids.length)
                          for (var i = 0; i < message.return_ids.length; ++i)
                              $root.syft_proto.types.syft.v1.Id.encode(message.return_ids[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                      if (message.return_placeholder_ids != null && message.return_placeholder_ids.length)
                          for (var i = 0; i < message.return_placeholder_ids.length; ++i)
                              $root.syft_proto.execution.v1.PlaceholderId.encode(message.return_placeholder_ids[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                      if (message.target_id != null && message.hasOwnProperty("target_id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.target_id, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified CommunicationAction message, length delimited. Does not implicitly {@link syft_proto.execution.v1.CommunicationAction.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @static
                   * @param {syft_proto.execution.v1.ICommunicationAction} message CommunicationAction message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  CommunicationAction.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a CommunicationAction message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.CommunicationAction} CommunicationAction
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  CommunicationAction.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.CommunicationAction(), key;
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.command = reader.string();
                              break;
                          case 9:
                              message.target_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32());
                              break;
                          case 3:
                              message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32());
                              break;
                          case 4:
                              message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                              break;
                          case 5:
                              if (!(message.args && message.args.length))
                                  message.args = [];
                              message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                              break;
                          case 6:
                              reader.skip().pos++;
                              if (message.kwargs === $util.emptyObject)
                                  message.kwargs = {};
                              key = reader.string();
                              reader.pos++;
                              message.kwargs[key] = $root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32());
                              break;
                          case 7:
                              if (!(message.return_ids && message.return_ids.length))
                                  message.return_ids = [];
                              message.return_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                              break;
                          case 8:
                              if (!(message.return_placeholder_ids && message.return_placeholder_ids.length))
                                  message.return_placeholder_ids = [];
                              message.return_placeholder_ids.push($root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32()));
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a CommunicationAction message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.CommunicationAction} CommunicationAction
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  CommunicationAction.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a CommunicationAction message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  CommunicationAction.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      var properties = {};
                      if (message.command != null && message.hasOwnProperty("command"))
                          if (!$util.isString(message.command))
                              return "command: string expected";
                      if (message.target_id != null && message.hasOwnProperty("target_id")) {
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.target_id);
                              if (error)
                                  return "target_id." + error;
                          }
                      }
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.target_pointer);
                              if (error)
                                  return "target_pointer." + error;
                          }
                      }
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.target_placeholder_id);
                              if (error)
                                  return "target_placeholder_id." + error;
                          }
                      }
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.target_tensor);
                              if (error)
                                  return "target_tensor." + error;
                          }
                      }
                      if (message.args != null && message.hasOwnProperty("args")) {
                          if (!Array.isArray(message.args))
                              return "args: array expected";
                          for (var i = 0; i < message.args.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                              if (error)
                                  return "args." + error;
                          }
                      }
                      if (message.kwargs != null && message.hasOwnProperty("kwargs")) {
                          if (!$util.isObject(message.kwargs))
                              return "kwargs: object expected";
                          var key = Object.keys(message.kwargs);
                          for (var i = 0; i < key.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Arg.verify(message.kwargs[key[i]]);
                              if (error)
                                  return "kwargs." + error;
                          }
                      }
                      if (message.return_ids != null && message.hasOwnProperty("return_ids")) {
                          if (!Array.isArray(message.return_ids))
                              return "return_ids: array expected";
                          for (var i = 0; i < message.return_ids.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.return_ids[i]);
                              if (error)
                                  return "return_ids." + error;
                          }
                      }
                      if (message.return_placeholder_ids != null && message.hasOwnProperty("return_placeholder_ids")) {
                          if (!Array.isArray(message.return_placeholder_ids))
                              return "return_placeholder_ids: array expected";
                          for (var i = 0; i < message.return_placeholder_ids.length; ++i) {
                              var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.return_placeholder_ids[i]);
                              if (error)
                                  return "return_placeholder_ids." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a CommunicationAction message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.CommunicationAction} CommunicationAction
                   */
                  CommunicationAction.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.CommunicationAction)
                          return object;
                      var message = new $root.syft_proto.execution.v1.CommunicationAction();
                      if (object.command != null)
                          message.command = String(object.command);
                      if (object.target_id != null) {
                          if (typeof object.target_id !== "object")
                              throw TypeError(".syft_proto.execution.v1.CommunicationAction.target_id: object expected");
                          message.target_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.target_id);
                      }
                      if (object.target_pointer != null) {
                          if (typeof object.target_pointer !== "object")
                              throw TypeError(".syft_proto.execution.v1.CommunicationAction.target_pointer: object expected");
                          message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.target_pointer);
                      }
                      if (object.target_placeholder_id != null) {
                          if (typeof object.target_placeholder_id !== "object")
                              throw TypeError(".syft_proto.execution.v1.CommunicationAction.target_placeholder_id: object expected");
                          message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.target_placeholder_id);
                      }
                      if (object.target_tensor != null) {
                          if (typeof object.target_tensor !== "object")
                              throw TypeError(".syft_proto.execution.v1.CommunicationAction.target_tensor: object expected");
                          message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.target_tensor);
                      }
                      if (object.args) {
                          if (!Array.isArray(object.args))
                              throw TypeError(".syft_proto.execution.v1.CommunicationAction.args: array expected");
                          message.args = [];
                          for (var i = 0; i < object.args.length; ++i) {
                              if (typeof object.args[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.CommunicationAction.args: object expected");
                              message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                          }
                      }
                      if (object.kwargs) {
                          if (typeof object.kwargs !== "object")
                              throw TypeError(".syft_proto.execution.v1.CommunicationAction.kwargs: object expected");
                          message.kwargs = {};
                          for (var keys = Object.keys(object.kwargs), i = 0; i < keys.length; ++i) {
                              if (typeof object.kwargs[keys[i]] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.CommunicationAction.kwargs: object expected");
                              message.kwargs[keys[i]] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.kwargs[keys[i]]);
                          }
                      }
                      if (object.return_ids) {
                          if (!Array.isArray(object.return_ids))
                              throw TypeError(".syft_proto.execution.v1.CommunicationAction.return_ids: array expected");
                          message.return_ids = [];
                          for (var i = 0; i < object.return_ids.length; ++i) {
                              if (typeof object.return_ids[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.CommunicationAction.return_ids: object expected");
                              message.return_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.return_ids[i]);
                          }
                      }
                      if (object.return_placeholder_ids) {
                          if (!Array.isArray(object.return_placeholder_ids))
                              throw TypeError(".syft_proto.execution.v1.CommunicationAction.return_placeholder_ids: array expected");
                          message.return_placeholder_ids = [];
                          for (var i = 0; i < object.return_placeholder_ids.length; ++i) {
                              if (typeof object.return_placeholder_ids[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.CommunicationAction.return_placeholder_ids: object expected");
                              message.return_placeholder_ids[i] = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.return_placeholder_ids[i]);
                          }
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a CommunicationAction message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @static
                   * @param {syft_proto.execution.v1.CommunicationAction} message CommunicationAction
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  CommunicationAction.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults) {
                          object.args = [];
                          object.return_ids = [];
                          object.return_placeholder_ids = [];
                      }
                      if (options.objects || options.defaults)
                          object.kwargs = {};
                      if (options.defaults)
                          object.command = "";
                      if (message.command != null && message.hasOwnProperty("command"))
                          object.command = message.command;
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                          object.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.target_pointer, options);
                          if (options.oneofs)
                              object.target = "target_pointer";
                      }
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                          object.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.target_placeholder_id, options);
                          if (options.oneofs)
                              object.target = "target_placeholder_id";
                      }
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                          object.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.target_tensor, options);
                          if (options.oneofs)
                              object.target = "target_tensor";
                      }
                      if (message.args && message.args.length) {
                          object.args = [];
                          for (var j = 0; j < message.args.length; ++j)
                              object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                      }
                      var keys2;
                      if (message.kwargs && (keys2 = Object.keys(message.kwargs)).length) {
                          object.kwargs = {};
                          for (var j = 0; j < keys2.length; ++j)
                              object.kwargs[keys2[j]] = $root.syft_proto.types.syft.v1.Arg.toObject(message.kwargs[keys2[j]], options);
                      }
                      if (message.return_ids && message.return_ids.length) {
                          object.return_ids = [];
                          for (var j = 0; j < message.return_ids.length; ++j)
                              object.return_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.return_ids[j], options);
                      }
                      if (message.return_placeholder_ids && message.return_placeholder_ids.length) {
                          object.return_placeholder_ids = [];
                          for (var j = 0; j < message.return_placeholder_ids.length; ++j)
                              object.return_placeholder_ids[j] = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.return_placeholder_ids[j], options);
                      }
                      if (message.target_id != null && message.hasOwnProperty("target_id")) {
                          object.target_id = $root.syft_proto.types.syft.v1.Id.toObject(message.target_id, options);
                          if (options.oneofs)
                              object.target = "target_id";
                      }
                      return object;
                  };

                  /**
                   * Converts this CommunicationAction to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.CommunicationAction
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  CommunicationAction.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return CommunicationAction;
              })();

              v1.PlaceholderId = (function() {

                  /**
                   * Properties of a PlaceholderId.
                   * @memberof syft_proto.execution.v1
                   * @interface IPlaceholderId
                   * @property {syft_proto.types.syft.v1.IId|null} [id] PlaceholderId id
                   */

                  /**
                   * Constructs a new PlaceholderId.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a PlaceholderId.
                   * @implements IPlaceholderId
                   * @constructor
                   * @param {syft_proto.execution.v1.IPlaceholderId=} [properties] Properties to set
                   */
                  function PlaceholderId(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * PlaceholderId id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @instance
                   */
                  PlaceholderId.prototype.id = null;

                  /**
                   * Creates a new PlaceholderId instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @static
                   * @param {syft_proto.execution.v1.IPlaceholderId=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.PlaceholderId} PlaceholderId instance
                   */
                  PlaceholderId.create = function create(properties) {
                      return new PlaceholderId(properties);
                  };

                  /**
                   * Encodes the specified PlaceholderId message. Does not implicitly {@link syft_proto.execution.v1.PlaceholderId.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @static
                   * @param {syft_proto.execution.v1.IPlaceholderId} message PlaceholderId message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  PlaceholderId.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.id != null && message.hasOwnProperty("id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified PlaceholderId message, length delimited. Does not implicitly {@link syft_proto.execution.v1.PlaceholderId.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @static
                   * @param {syft_proto.execution.v1.IPlaceholderId} message PlaceholderId message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  PlaceholderId.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a PlaceholderId message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.PlaceholderId} PlaceholderId
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  PlaceholderId.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.PlaceholderId();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a PlaceholderId message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.PlaceholderId} PlaceholderId
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  PlaceholderId.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a PlaceholderId message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  PlaceholderId.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.id != null && message.hasOwnProperty("id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                          if (error)
                              return "id." + error;
                      }
                      return null;
                  };

                  /**
                   * Creates a PlaceholderId message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.PlaceholderId} PlaceholderId
                   */
                  PlaceholderId.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.PlaceholderId)
                          return object;
                      var message = new $root.syft_proto.execution.v1.PlaceholderId();
                      if (object.id != null) {
                          if (typeof object.id !== "object")
                              throw TypeError(".syft_proto.execution.v1.PlaceholderId.id: object expected");
                          message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a PlaceholderId message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @static
                   * @param {syft_proto.execution.v1.PlaceholderId} message PlaceholderId
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  PlaceholderId.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults)
                          object.id = null;
                      if (message.id != null && message.hasOwnProperty("id"))
                          object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                      return object;
                  };

                  /**
                   * Converts this PlaceholderId to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.PlaceholderId
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  PlaceholderId.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return PlaceholderId;
              })();

              v1.Placeholder = (function() {

                  /**
                   * Properties of a Placeholder.
                   * @memberof syft_proto.execution.v1
                   * @interface IPlaceholder
                   * @property {syft_proto.types.torch.v1.ITorchTensor|null} [child_tensor] Placeholder child_tensor
                   * @property {syft_proto.types.torch.v1.IParameter|null} [child_parameter] Placeholder child_parameter
                   * @property {syft_proto.types.syft.v1.IId|null} [id] Placeholder id
                   * @property {Array.<string>|null} [tags] Placeholder tags
                   * @property {string|null} [description] Placeholder description
                   * @property {syft_proto.types.syft.v1.IShape|null} [expected_shape] Placeholder expected_shape
                   */

                  /**
                   * Constructs a new Placeholder.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a Placeholder.
                   * @implements IPlaceholder
                   * @constructor
                   * @param {syft_proto.execution.v1.IPlaceholder=} [properties] Properties to set
                   */
                  function Placeholder(properties) {
                      this.tags = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * Placeholder child_tensor.
                   * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} child_tensor
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @instance
                   */
                  Placeholder.prototype.child_tensor = null;

                  /**
                   * Placeholder child_parameter.
                   * @member {syft_proto.types.torch.v1.IParameter|null|undefined} child_parameter
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @instance
                   */
                  Placeholder.prototype.child_parameter = null;

                  /**
                   * Placeholder id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @instance
                   */
                  Placeholder.prototype.id = null;

                  /**
                   * Placeholder tags.
                   * @member {Array.<string>} tags
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @instance
                   */
                  Placeholder.prototype.tags = $util.emptyArray;

                  /**
                   * Placeholder description.
                   * @member {string} description
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @instance
                   */
                  Placeholder.prototype.description = "";

                  /**
                   * Placeholder expected_shape.
                   * @member {syft_proto.types.syft.v1.IShape|null|undefined} expected_shape
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @instance
                   */
                  Placeholder.prototype.expected_shape = null;

                  // OneOf field names bound to virtual getters and setters
                  var $oneOfFields;

                  /**
                   * Placeholder child.
                   * @member {"child_tensor"|"child_parameter"|undefined} child
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @instance
                   */
                  Object.defineProperty(Placeholder.prototype, "child", {
                      get: $util.oneOfGetter($oneOfFields = ["child_tensor", "child_parameter"]),
                      set: $util.oneOfSetter($oneOfFields)
                  });

                  /**
                   * Creates a new Placeholder instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @static
                   * @param {syft_proto.execution.v1.IPlaceholder=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.Placeholder} Placeholder instance
                   */
                  Placeholder.create = function create(properties) {
                      return new Placeholder(properties);
                  };

                  /**
                   * Encodes the specified Placeholder message. Does not implicitly {@link syft_proto.execution.v1.Placeholder.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @static
                   * @param {syft_proto.execution.v1.IPlaceholder} message Placeholder message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Placeholder.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.child_tensor != null && message.hasOwnProperty("child_tensor"))
                          $root.syft_proto.types.torch.v1.TorchTensor.encode(message.child_tensor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.child_parameter != null && message.hasOwnProperty("child_parameter"))
                          $root.syft_proto.types.torch.v1.Parameter.encode(message.child_parameter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      if (message.id != null && message.hasOwnProperty("id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                      if (message.tags != null && message.tags.length)
                          for (var i = 0; i < message.tags.length; ++i)
                              writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                      if (message.description != null && message.hasOwnProperty("description"))
                          writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                      if (message.expected_shape != null && message.hasOwnProperty("expected_shape"))
                          $root.syft_proto.types.syft.v1.Shape.encode(message.expected_shape, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified Placeholder message, length delimited. Does not implicitly {@link syft_proto.execution.v1.Placeholder.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @static
                   * @param {syft_proto.execution.v1.IPlaceholder} message Placeholder message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Placeholder.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a Placeholder message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.Placeholder} Placeholder
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Placeholder.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.Placeholder();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.child_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.child_parameter = $root.syft_proto.types.torch.v1.Parameter.decode(reader, reader.uint32());
                              break;
                          case 3:
                              message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          case 4:
                              if (!(message.tags && message.tags.length))
                                  message.tags = [];
                              message.tags.push(reader.string());
                              break;
                          case 5:
                              message.description = reader.string();
                              break;
                          case 6:
                              message.expected_shape = $root.syft_proto.types.syft.v1.Shape.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a Placeholder message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.Placeholder} Placeholder
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Placeholder.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a Placeholder message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  Placeholder.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      var properties = {};
                      if (message.child_tensor != null && message.hasOwnProperty("child_tensor")) {
                          properties.child = 1;
                          {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.child_tensor);
                              if (error)
                                  return "child_tensor." + error;
                          }
                      }
                      if (message.child_parameter != null && message.hasOwnProperty("child_parameter")) {
                          if (properties.child === 1)
                              return "child: multiple values";
                          properties.child = 1;
                          {
                              var error = $root.syft_proto.types.torch.v1.Parameter.verify(message.child_parameter);
                              if (error)
                                  return "child_parameter." + error;
                          }
                      }
                      if (message.id != null && message.hasOwnProperty("id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                          if (error)
                              return "id." + error;
                      }
                      if (message.tags != null && message.hasOwnProperty("tags")) {
                          if (!Array.isArray(message.tags))
                              return "tags: array expected";
                          for (var i = 0; i < message.tags.length; ++i)
                              if (!$util.isString(message.tags[i]))
                                  return "tags: string[] expected";
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          if (!$util.isString(message.description))
                              return "description: string expected";
                      if (message.expected_shape != null && message.hasOwnProperty("expected_shape")) {
                          var error = $root.syft_proto.types.syft.v1.Shape.verify(message.expected_shape);
                          if (error)
                              return "expected_shape." + error;
                      }
                      return null;
                  };

                  /**
                   * Creates a Placeholder message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.Placeholder} Placeholder
                   */
                  Placeholder.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.Placeholder)
                          return object;
                      var message = new $root.syft_proto.execution.v1.Placeholder();
                      if (object.child_tensor != null) {
                          if (typeof object.child_tensor !== "object")
                              throw TypeError(".syft_proto.execution.v1.Placeholder.child_tensor: object expected");
                          message.child_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.child_tensor);
                      }
                      if (object.child_parameter != null) {
                          if (typeof object.child_parameter !== "object")
                              throw TypeError(".syft_proto.execution.v1.Placeholder.child_parameter: object expected");
                          message.child_parameter = $root.syft_proto.types.torch.v1.Parameter.fromObject(object.child_parameter);
                      }
                      if (object.id != null) {
                          if (typeof object.id !== "object")
                              throw TypeError(".syft_proto.execution.v1.Placeholder.id: object expected");
                          message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                      }
                      if (object.tags) {
                          if (!Array.isArray(object.tags))
                              throw TypeError(".syft_proto.execution.v1.Placeholder.tags: array expected");
                          message.tags = [];
                          for (var i = 0; i < object.tags.length; ++i)
                              message.tags[i] = String(object.tags[i]);
                      }
                      if (object.description != null)
                          message.description = String(object.description);
                      if (object.expected_shape != null) {
                          if (typeof object.expected_shape !== "object")
                              throw TypeError(".syft_proto.execution.v1.Placeholder.expected_shape: object expected");
                          message.expected_shape = $root.syft_proto.types.syft.v1.Shape.fromObject(object.expected_shape);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a Placeholder message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @static
                   * @param {syft_proto.execution.v1.Placeholder} message Placeholder
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  Placeholder.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults)
                          object.tags = [];
                      if (options.defaults) {
                          object.id = null;
                          object.description = "";
                          object.expected_shape = null;
                      }
                      if (message.child_tensor != null && message.hasOwnProperty("child_tensor")) {
                          object.child_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.child_tensor, options);
                          if (options.oneofs)
                              object.child = "child_tensor";
                      }
                      if (message.child_parameter != null && message.hasOwnProperty("child_parameter")) {
                          object.child_parameter = $root.syft_proto.types.torch.v1.Parameter.toObject(message.child_parameter, options);
                          if (options.oneofs)
                              object.child = "child_parameter";
                      }
                      if (message.id != null && message.hasOwnProperty("id"))
                          object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                      if (message.tags && message.tags.length) {
                          object.tags = [];
                          for (var j = 0; j < message.tags.length; ++j)
                              object.tags[j] = message.tags[j];
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          object.description = message.description;
                      if (message.expected_shape != null && message.hasOwnProperty("expected_shape"))
                          object.expected_shape = $root.syft_proto.types.syft.v1.Shape.toObject(message.expected_shape, options);
                      return object;
                  };

                  /**
                   * Converts this Placeholder to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.Placeholder
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  Placeholder.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return Placeholder;
              })();

              v1.ComputationAction = (function() {

                  /**
                   * Properties of a ComputationAction.
                   * @memberof syft_proto.execution.v1
                   * @interface IComputationAction
                   * @property {string|null} [command] ComputationAction command
                   * @property {syft_proto.types.syft.v1.IId|null} [target_id] ComputationAction target_id
                   * @property {syft_proto.generic.pointers.v1.IPointerTensor|null} [target_pointer] ComputationAction target_pointer
                   * @property {syft_proto.execution.v1.IPlaceholderId|null} [target_placeholder_id] ComputationAction target_placeholder_id
                   * @property {syft_proto.types.torch.v1.ITorchTensor|null} [target_tensor] ComputationAction target_tensor
                   * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] ComputationAction args
                   * @property {Object.<string,syft_proto.types.syft.v1.IArg>|null} [kwargs] ComputationAction kwargs
                   * @property {Array.<syft_proto.types.syft.v1.IId>|null} [return_ids] ComputationAction return_ids
                   * @property {Array.<syft_proto.execution.v1.IPlaceholderId>|null} [return_placeholder_ids] ComputationAction return_placeholder_ids
                   */

                  /**
                   * Constructs a new ComputationAction.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a ComputationAction.
                   * @implements IComputationAction
                   * @constructor
                   * @param {syft_proto.execution.v1.IComputationAction=} [properties] Properties to set
                   */
                  function ComputationAction(properties) {
                      this.args = [];
                      this.kwargs = {};
                      this.return_ids = [];
                      this.return_placeholder_ids = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * ComputationAction command.
                   * @member {string} command
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.command = "";

                  /**
                   * ComputationAction target_id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} target_id
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.target_id = null;

                  /**
                   * ComputationAction target_pointer.
                   * @member {syft_proto.generic.pointers.v1.IPointerTensor|null|undefined} target_pointer
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.target_pointer = null;

                  /**
                   * ComputationAction target_placeholder_id.
                   * @member {syft_proto.execution.v1.IPlaceholderId|null|undefined} target_placeholder_id
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.target_placeholder_id = null;

                  /**
                   * ComputationAction target_tensor.
                   * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} target_tensor
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.target_tensor = null;

                  /**
                   * ComputationAction args.
                   * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.args = $util.emptyArray;

                  /**
                   * ComputationAction kwargs.
                   * @member {Object.<string,syft_proto.types.syft.v1.IArg>} kwargs
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.kwargs = $util.emptyObject;

                  /**
                   * ComputationAction return_ids.
                   * @member {Array.<syft_proto.types.syft.v1.IId>} return_ids
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.return_ids = $util.emptyArray;

                  /**
                   * ComputationAction return_placeholder_ids.
                   * @member {Array.<syft_proto.execution.v1.IPlaceholderId>} return_placeholder_ids
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  ComputationAction.prototype.return_placeholder_ids = $util.emptyArray;

                  // OneOf field names bound to virtual getters and setters
                  var $oneOfFields;

                  /**
                   * ComputationAction target.
                   * @member {"target_id"|"target_pointer"|"target_placeholder_id"|"target_tensor"|undefined} target
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   */
                  Object.defineProperty(ComputationAction.prototype, "target", {
                      get: $util.oneOfGetter($oneOfFields = ["target_id", "target_pointer", "target_placeholder_id", "target_tensor"]),
                      set: $util.oneOfSetter($oneOfFields)
                  });

                  /**
                   * Creates a new ComputationAction instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @static
                   * @param {syft_proto.execution.v1.IComputationAction=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.ComputationAction} ComputationAction instance
                   */
                  ComputationAction.create = function create(properties) {
                      return new ComputationAction(properties);
                  };

                  /**
                   * Encodes the specified ComputationAction message. Does not implicitly {@link syft_proto.execution.v1.ComputationAction.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @static
                   * @param {syft_proto.execution.v1.IComputationAction} message ComputationAction message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ComputationAction.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.command != null && message.hasOwnProperty("command"))
                          writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer"))
                          $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.target_pointer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id"))
                          $root.syft_proto.execution.v1.PlaceholderId.encode(message.target_placeholder_id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor"))
                          $root.syft_proto.types.torch.v1.TorchTensor.encode(message.target_tensor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                      if (message.args != null && message.args.length)
                          for (var i = 0; i < message.args.length; ++i)
                              $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                      if (message.kwargs != null && message.hasOwnProperty("kwargs"))
                          for (var keys = Object.keys(message.kwargs), i = 0; i < keys.length; ++i) {
                              writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                              $root.syft_proto.types.syft.v1.Arg.encode(message.kwargs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                          }
                      if (message.return_ids != null && message.return_ids.length)
                          for (var i = 0; i < message.return_ids.length; ++i)
                              $root.syft_proto.types.syft.v1.Id.encode(message.return_ids[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                      if (message.return_placeholder_ids != null && message.return_placeholder_ids.length)
                          for (var i = 0; i < message.return_placeholder_ids.length; ++i)
                              $root.syft_proto.execution.v1.PlaceholderId.encode(message.return_placeholder_ids[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                      if (message.target_id != null && message.hasOwnProperty("target_id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.target_id, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified ComputationAction message, length delimited. Does not implicitly {@link syft_proto.execution.v1.ComputationAction.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @static
                   * @param {syft_proto.execution.v1.IComputationAction} message ComputationAction message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ComputationAction.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a ComputationAction message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.ComputationAction} ComputationAction
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ComputationAction.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.ComputationAction(), key;
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.command = reader.string();
                              break;
                          case 9:
                              message.target_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32());
                              break;
                          case 3:
                              message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32());
                              break;
                          case 4:
                              message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                              break;
                          case 5:
                              if (!(message.args && message.args.length))
                                  message.args = [];
                              message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                              break;
                          case 6:
                              reader.skip().pos++;
                              if (message.kwargs === $util.emptyObject)
                                  message.kwargs = {};
                              key = reader.string();
                              reader.pos++;
                              message.kwargs[key] = $root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32());
                              break;
                          case 7:
                              if (!(message.return_ids && message.return_ids.length))
                                  message.return_ids = [];
                              message.return_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                              break;
                          case 8:
                              if (!(message.return_placeholder_ids && message.return_placeholder_ids.length))
                                  message.return_placeholder_ids = [];
                              message.return_placeholder_ids.push($root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32()));
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a ComputationAction message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.ComputationAction} ComputationAction
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ComputationAction.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a ComputationAction message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  ComputationAction.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      var properties = {};
                      if (message.command != null && message.hasOwnProperty("command"))
                          if (!$util.isString(message.command))
                              return "command: string expected";
                      if (message.target_id != null && message.hasOwnProperty("target_id")) {
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.target_id);
                              if (error)
                                  return "target_id." + error;
                          }
                      }
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.target_pointer);
                              if (error)
                                  return "target_pointer." + error;
                          }
                      }
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.target_placeholder_id);
                              if (error)
                                  return "target_placeholder_id." + error;
                          }
                      }
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.target_tensor);
                              if (error)
                                  return "target_tensor." + error;
                          }
                      }
                      if (message.args != null && message.hasOwnProperty("args")) {
                          if (!Array.isArray(message.args))
                              return "args: array expected";
                          for (var i = 0; i < message.args.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                              if (error)
                                  return "args." + error;
                          }
                      }
                      if (message.kwargs != null && message.hasOwnProperty("kwargs")) {
                          if (!$util.isObject(message.kwargs))
                              return "kwargs: object expected";
                          var key = Object.keys(message.kwargs);
                          for (var i = 0; i < key.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Arg.verify(message.kwargs[key[i]]);
                              if (error)
                                  return "kwargs." + error;
                          }
                      }
                      if (message.return_ids != null && message.hasOwnProperty("return_ids")) {
                          if (!Array.isArray(message.return_ids))
                              return "return_ids: array expected";
                          for (var i = 0; i < message.return_ids.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.return_ids[i]);
                              if (error)
                                  return "return_ids." + error;
                          }
                      }
                      if (message.return_placeholder_ids != null && message.hasOwnProperty("return_placeholder_ids")) {
                          if (!Array.isArray(message.return_placeholder_ids))
                              return "return_placeholder_ids: array expected";
                          for (var i = 0; i < message.return_placeholder_ids.length; ++i) {
                              var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.return_placeholder_ids[i]);
                              if (error)
                                  return "return_placeholder_ids." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a ComputationAction message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.ComputationAction} ComputationAction
                   */
                  ComputationAction.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.ComputationAction)
                          return object;
                      var message = new $root.syft_proto.execution.v1.ComputationAction();
                      if (object.command != null)
                          message.command = String(object.command);
                      if (object.target_id != null) {
                          if (typeof object.target_id !== "object")
                              throw TypeError(".syft_proto.execution.v1.ComputationAction.target_id: object expected");
                          message.target_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.target_id);
                      }
                      if (object.target_pointer != null) {
                          if (typeof object.target_pointer !== "object")
                              throw TypeError(".syft_proto.execution.v1.ComputationAction.target_pointer: object expected");
                          message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.target_pointer);
                      }
                      if (object.target_placeholder_id != null) {
                          if (typeof object.target_placeholder_id !== "object")
                              throw TypeError(".syft_proto.execution.v1.ComputationAction.target_placeholder_id: object expected");
                          message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.target_placeholder_id);
                      }
                      if (object.target_tensor != null) {
                          if (typeof object.target_tensor !== "object")
                              throw TypeError(".syft_proto.execution.v1.ComputationAction.target_tensor: object expected");
                          message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.target_tensor);
                      }
                      if (object.args) {
                          if (!Array.isArray(object.args))
                              throw TypeError(".syft_proto.execution.v1.ComputationAction.args: array expected");
                          message.args = [];
                          for (var i = 0; i < object.args.length; ++i) {
                              if (typeof object.args[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.ComputationAction.args: object expected");
                              message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                          }
                      }
                      if (object.kwargs) {
                          if (typeof object.kwargs !== "object")
                              throw TypeError(".syft_proto.execution.v1.ComputationAction.kwargs: object expected");
                          message.kwargs = {};
                          for (var keys = Object.keys(object.kwargs), i = 0; i < keys.length; ++i) {
                              if (typeof object.kwargs[keys[i]] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.ComputationAction.kwargs: object expected");
                              message.kwargs[keys[i]] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.kwargs[keys[i]]);
                          }
                      }
                      if (object.return_ids) {
                          if (!Array.isArray(object.return_ids))
                              throw TypeError(".syft_proto.execution.v1.ComputationAction.return_ids: array expected");
                          message.return_ids = [];
                          for (var i = 0; i < object.return_ids.length; ++i) {
                              if (typeof object.return_ids[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.ComputationAction.return_ids: object expected");
                              message.return_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.return_ids[i]);
                          }
                      }
                      if (object.return_placeholder_ids) {
                          if (!Array.isArray(object.return_placeholder_ids))
                              throw TypeError(".syft_proto.execution.v1.ComputationAction.return_placeholder_ids: array expected");
                          message.return_placeholder_ids = [];
                          for (var i = 0; i < object.return_placeholder_ids.length; ++i) {
                              if (typeof object.return_placeholder_ids[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.ComputationAction.return_placeholder_ids: object expected");
                              message.return_placeholder_ids[i] = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.return_placeholder_ids[i]);
                          }
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a ComputationAction message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @static
                   * @param {syft_proto.execution.v1.ComputationAction} message ComputationAction
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  ComputationAction.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults) {
                          object.args = [];
                          object.return_ids = [];
                          object.return_placeholder_ids = [];
                      }
                      if (options.objects || options.defaults)
                          object.kwargs = {};
                      if (options.defaults)
                          object.command = "";
                      if (message.command != null && message.hasOwnProperty("command"))
                          object.command = message.command;
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                          object.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.target_pointer, options);
                          if (options.oneofs)
                              object.target = "target_pointer";
                      }
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                          object.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.target_placeholder_id, options);
                          if (options.oneofs)
                              object.target = "target_placeholder_id";
                      }
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                          object.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.target_tensor, options);
                          if (options.oneofs)
                              object.target = "target_tensor";
                      }
                      if (message.args && message.args.length) {
                          object.args = [];
                          for (var j = 0; j < message.args.length; ++j)
                              object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                      }
                      var keys2;
                      if (message.kwargs && (keys2 = Object.keys(message.kwargs)).length) {
                          object.kwargs = {};
                          for (var j = 0; j < keys2.length; ++j)
                              object.kwargs[keys2[j]] = $root.syft_proto.types.syft.v1.Arg.toObject(message.kwargs[keys2[j]], options);
                      }
                      if (message.return_ids && message.return_ids.length) {
                          object.return_ids = [];
                          for (var j = 0; j < message.return_ids.length; ++j)
                              object.return_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.return_ids[j], options);
                      }
                      if (message.return_placeholder_ids && message.return_placeholder_ids.length) {
                          object.return_placeholder_ids = [];
                          for (var j = 0; j < message.return_placeholder_ids.length; ++j)
                              object.return_placeholder_ids[j] = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.return_placeholder_ids[j], options);
                      }
                      if (message.target_id != null && message.hasOwnProperty("target_id")) {
                          object.target_id = $root.syft_proto.types.syft.v1.Id.toObject(message.target_id, options);
                          if (options.oneofs)
                              object.target = "target_id";
                      }
                      return object;
                  };

                  /**
                   * Converts this ComputationAction to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.ComputationAction
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  ComputationAction.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return ComputationAction;
              })();

              v1.Plan = (function() {

                  /**
                   * Properties of a Plan.
                   * @memberof syft_proto.execution.v1
                   * @interface IPlan
                   * @property {syft_proto.types.syft.v1.IId|null} [id] Plan id
                   * @property {syft_proto.execution.v1.IRole|null} [role] Plan role
                   * @property {boolean|null} [include_state] Plan include_state
                   * @property {string|null} [name] Plan name
                   * @property {Array.<string>|null} [tags] Plan tags
                   * @property {string|null} [description] Plan description
                   * @property {Uint8Array|null} [torchscript] Plan torchscript
                   * @property {syft_proto.execution.v1.INestedTypeWrapper|null} [input_types] Plan input_types
                   * @property {string|null} [base_framework] Plan base_framework
                   * @property {Object.<string,syft_proto.execution.v1.IRole>|null} [roles] Plan roles
                   */

                  /**
                   * Constructs a new Plan.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a Plan.
                   * @implements IPlan
                   * @constructor
                   * @param {syft_proto.execution.v1.IPlan=} [properties] Properties to set
                   */
                  function Plan(properties) {
                      this.tags = [];
                      this.roles = {};
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * Plan id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.id = null;

                  /**
                   * Plan role.
                   * @member {syft_proto.execution.v1.IRole|null|undefined} role
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.role = null;

                  /**
                   * Plan include_state.
                   * @member {boolean} include_state
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.include_state = false;

                  /**
                   * Plan name.
                   * @member {string} name
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.name = "";

                  /**
                   * Plan tags.
                   * @member {Array.<string>} tags
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.tags = $util.emptyArray;

                  /**
                   * Plan description.
                   * @member {string} description
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.description = "";

                  /**
                   * Plan torchscript.
                   * @member {Uint8Array} torchscript
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.torchscript = $util.newBuffer([]);

                  /**
                   * Plan input_types.
                   * @member {syft_proto.execution.v1.INestedTypeWrapper|null|undefined} input_types
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.input_types = null;

                  /**
                   * Plan base_framework.
                   * @member {string} base_framework
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.base_framework = "";

                  /**
                   * Plan roles.
                   * @member {Object.<string,syft_proto.execution.v1.IRole>} roles
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   */
                  Plan.prototype.roles = $util.emptyObject;

                  /**
                   * Creates a new Plan instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.Plan
                   * @static
                   * @param {syft_proto.execution.v1.IPlan=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.Plan} Plan instance
                   */
                  Plan.create = function create(properties) {
                      return new Plan(properties);
                  };

                  /**
                   * Encodes the specified Plan message. Does not implicitly {@link syft_proto.execution.v1.Plan.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.Plan
                   * @static
                   * @param {syft_proto.execution.v1.IPlan} message Plan message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Plan.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.id != null && message.hasOwnProperty("id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.role != null && message.hasOwnProperty("role"))
                          $root.syft_proto.execution.v1.Role.encode(message.role, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      if (message.include_state != null && message.hasOwnProperty("include_state"))
                          writer.uint32(/* id 3, wireType 0 =*/24).bool(message.include_state);
                      if (message.name != null && message.hasOwnProperty("name"))
                          writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                      if (message.tags != null && message.tags.length)
                          for (var i = 0; i < message.tags.length; ++i)
                              writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
                      if (message.description != null && message.hasOwnProperty("description"))
                          writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
                      if (message.torchscript != null && message.hasOwnProperty("torchscript"))
                          writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.torchscript);
                      if (message.input_types != null && message.hasOwnProperty("input_types"))
                          $root.syft_proto.execution.v1.NestedTypeWrapper.encode(message.input_types, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                      if (message.base_framework != null && message.hasOwnProperty("base_framework"))
                          writer.uint32(/* id 9, wireType 2 =*/74).string(message.base_framework);
                      if (message.roles != null && message.hasOwnProperty("roles"))
                          for (var keys = Object.keys(message.roles), i = 0; i < keys.length; ++i) {
                              writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                              $root.syft_proto.execution.v1.Role.encode(message.roles[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                          }
                      return writer;
                  };

                  /**
                   * Encodes the specified Plan message, length delimited. Does not implicitly {@link syft_proto.execution.v1.Plan.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.Plan
                   * @static
                   * @param {syft_proto.execution.v1.IPlan} message Plan message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Plan.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a Plan message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.Plan
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.Plan} Plan
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Plan.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.Plan(), key;
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.role = $root.syft_proto.execution.v1.Role.decode(reader, reader.uint32());
                              break;
                          case 3:
                              message.include_state = reader.bool();
                              break;
                          case 4:
                              message.name = reader.string();
                              break;
                          case 5:
                              if (!(message.tags && message.tags.length))
                                  message.tags = [];
                              message.tags.push(reader.string());
                              break;
                          case 6:
                              message.description = reader.string();
                              break;
                          case 7:
                              message.torchscript = reader.bytes();
                              break;
                          case 8:
                              message.input_types = $root.syft_proto.execution.v1.NestedTypeWrapper.decode(reader, reader.uint32());
                              break;
                          case 9:
                              message.base_framework = reader.string();
                              break;
                          case 10:
                              reader.skip().pos++;
                              if (message.roles === $util.emptyObject)
                                  message.roles = {};
                              key = reader.string();
                              reader.pos++;
                              message.roles[key] = $root.syft_proto.execution.v1.Role.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a Plan message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.Plan
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.Plan} Plan
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Plan.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a Plan message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.Plan
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  Plan.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.id != null && message.hasOwnProperty("id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                          if (error)
                              return "id." + error;
                      }
                      if (message.role != null && message.hasOwnProperty("role")) {
                          var error = $root.syft_proto.execution.v1.Role.verify(message.role);
                          if (error)
                              return "role." + error;
                      }
                      if (message.include_state != null && message.hasOwnProperty("include_state"))
                          if (typeof message.include_state !== "boolean")
                              return "include_state: boolean expected";
                      if (message.name != null && message.hasOwnProperty("name"))
                          if (!$util.isString(message.name))
                              return "name: string expected";
                      if (message.tags != null && message.hasOwnProperty("tags")) {
                          if (!Array.isArray(message.tags))
                              return "tags: array expected";
                          for (var i = 0; i < message.tags.length; ++i)
                              if (!$util.isString(message.tags[i]))
                                  return "tags: string[] expected";
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          if (!$util.isString(message.description))
                              return "description: string expected";
                      if (message.torchscript != null && message.hasOwnProperty("torchscript"))
                          if (!(message.torchscript && typeof message.torchscript.length === "number" || $util.isString(message.torchscript)))
                              return "torchscript: buffer expected";
                      if (message.input_types != null && message.hasOwnProperty("input_types")) {
                          var error = $root.syft_proto.execution.v1.NestedTypeWrapper.verify(message.input_types);
                          if (error)
                              return "input_types." + error;
                      }
                      if (message.base_framework != null && message.hasOwnProperty("base_framework"))
                          if (!$util.isString(message.base_framework))
                              return "base_framework: string expected";
                      if (message.roles != null && message.hasOwnProperty("roles")) {
                          if (!$util.isObject(message.roles))
                              return "roles: object expected";
                          var key = Object.keys(message.roles);
                          for (var i = 0; i < key.length; ++i) {
                              var error = $root.syft_proto.execution.v1.Role.verify(message.roles[key[i]]);
                              if (error)
                                  return "roles." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a Plan message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.Plan
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.Plan} Plan
                   */
                  Plan.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.Plan)
                          return object;
                      var message = new $root.syft_proto.execution.v1.Plan();
                      if (object.id != null) {
                          if (typeof object.id !== "object")
                              throw TypeError(".syft_proto.execution.v1.Plan.id: object expected");
                          message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                      }
                      if (object.role != null) {
                          if (typeof object.role !== "object")
                              throw TypeError(".syft_proto.execution.v1.Plan.role: object expected");
                          message.role = $root.syft_proto.execution.v1.Role.fromObject(object.role);
                      }
                      if (object.include_state != null)
                          message.include_state = Boolean(object.include_state);
                      if (object.name != null)
                          message.name = String(object.name);
                      if (object.tags) {
                          if (!Array.isArray(object.tags))
                              throw TypeError(".syft_proto.execution.v1.Plan.tags: array expected");
                          message.tags = [];
                          for (var i = 0; i < object.tags.length; ++i)
                              message.tags[i] = String(object.tags[i]);
                      }
                      if (object.description != null)
                          message.description = String(object.description);
                      if (object.torchscript != null)
                          if (typeof object.torchscript === "string")
                              $util.base64.decode(object.torchscript, message.torchscript = $util.newBuffer($util.base64.length(object.torchscript)), 0);
                          else if (object.torchscript.length)
                              message.torchscript = object.torchscript;
                      if (object.input_types != null) {
                          if (typeof object.input_types !== "object")
                              throw TypeError(".syft_proto.execution.v1.Plan.input_types: object expected");
                          message.input_types = $root.syft_proto.execution.v1.NestedTypeWrapper.fromObject(object.input_types);
                      }
                      if (object.base_framework != null)
                          message.base_framework = String(object.base_framework);
                      if (object.roles) {
                          if (typeof object.roles !== "object")
                              throw TypeError(".syft_proto.execution.v1.Plan.roles: object expected");
                          message.roles = {};
                          for (var keys = Object.keys(object.roles), i = 0; i < keys.length; ++i) {
                              if (typeof object.roles[keys[i]] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.Plan.roles: object expected");
                              message.roles[keys[i]] = $root.syft_proto.execution.v1.Role.fromObject(object.roles[keys[i]]);
                          }
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a Plan message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.Plan
                   * @static
                   * @param {syft_proto.execution.v1.Plan} message Plan
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  Plan.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults)
                          object.tags = [];
                      if (options.objects || options.defaults)
                          object.roles = {};
                      if (options.defaults) {
                          object.id = null;
                          object.role = null;
                          object.include_state = false;
                          object.name = "";
                          object.description = "";
                          if (options.bytes === String)
                              object.torchscript = "";
                          else {
                              object.torchscript = [];
                              if (options.bytes !== Array)
                                  object.torchscript = $util.newBuffer(object.torchscript);
                          }
                          object.input_types = null;
                          object.base_framework = "";
                      }
                      if (message.id != null && message.hasOwnProperty("id"))
                          object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                      if (message.role != null && message.hasOwnProperty("role"))
                          object.role = $root.syft_proto.execution.v1.Role.toObject(message.role, options);
                      if (message.include_state != null && message.hasOwnProperty("include_state"))
                          object.include_state = message.include_state;
                      if (message.name != null && message.hasOwnProperty("name"))
                          object.name = message.name;
                      if (message.tags && message.tags.length) {
                          object.tags = [];
                          for (var j = 0; j < message.tags.length; ++j)
                              object.tags[j] = message.tags[j];
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          object.description = message.description;
                      if (message.torchscript != null && message.hasOwnProperty("torchscript"))
                          object.torchscript = options.bytes === String ? $util.base64.encode(message.torchscript, 0, message.torchscript.length) : options.bytes === Array ? Array.prototype.slice.call(message.torchscript) : message.torchscript;
                      if (message.input_types != null && message.hasOwnProperty("input_types"))
                          object.input_types = $root.syft_proto.execution.v1.NestedTypeWrapper.toObject(message.input_types, options);
                      if (message.base_framework != null && message.hasOwnProperty("base_framework"))
                          object.base_framework = message.base_framework;
                      var keys2;
                      if (message.roles && (keys2 = Object.keys(message.roles)).length) {
                          object.roles = {};
                          for (var j = 0; j < keys2.length; ++j)
                              object.roles[keys2[j]] = $root.syft_proto.execution.v1.Role.toObject(message.roles[keys2[j]], options);
                      }
                      return object;
                  };

                  /**
                   * Converts this Plan to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.Plan
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  Plan.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return Plan;
              })();

              v1.Role = (function() {

                  /**
                   * Properties of a Role.
                   * @memberof syft_proto.execution.v1
                   * @interface IRole
                   * @property {syft_proto.types.syft.v1.IId|null} [id] Role id
                   * @property {Array.<syft_proto.execution.v1.IComputationAction>|null} [actions] Role actions
                   * @property {syft_proto.execution.v1.IState|null} [state] Role state
                   * @property {Array.<syft_proto.execution.v1.IPlaceholder>|null} [placeholders] Role placeholders
                   * @property {Array.<syft_proto.types.syft.v1.IId>|null} [input_placeholder_ids] Role input_placeholder_ids
                   * @property {Array.<syft_proto.types.syft.v1.IId>|null} [output_placeholder_ids] Role output_placeholder_ids
                   * @property {Array.<string>|null} [tags] Role tags
                   * @property {string|null} [description] Role description
                   */

                  /**
                   * Constructs a new Role.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a Role.
                   * @implements IRole
                   * @constructor
                   * @param {syft_proto.execution.v1.IRole=} [properties] Properties to set
                   */
                  function Role(properties) {
                      this.actions = [];
                      this.placeholders = [];
                      this.input_placeholder_ids = [];
                      this.output_placeholder_ids = [];
                      this.tags = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * Role id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   */
                  Role.prototype.id = null;

                  /**
                   * Role actions.
                   * @member {Array.<syft_proto.execution.v1.IComputationAction>} actions
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   */
                  Role.prototype.actions = $util.emptyArray;

                  /**
                   * Role state.
                   * @member {syft_proto.execution.v1.IState|null|undefined} state
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   */
                  Role.prototype.state = null;

                  /**
                   * Role placeholders.
                   * @member {Array.<syft_proto.execution.v1.IPlaceholder>} placeholders
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   */
                  Role.prototype.placeholders = $util.emptyArray;

                  /**
                   * Role input_placeholder_ids.
                   * @member {Array.<syft_proto.types.syft.v1.IId>} input_placeholder_ids
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   */
                  Role.prototype.input_placeholder_ids = $util.emptyArray;

                  /**
                   * Role output_placeholder_ids.
                   * @member {Array.<syft_proto.types.syft.v1.IId>} output_placeholder_ids
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   */
                  Role.prototype.output_placeholder_ids = $util.emptyArray;

                  /**
                   * Role tags.
                   * @member {Array.<string>} tags
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   */
                  Role.prototype.tags = $util.emptyArray;

                  /**
                   * Role description.
                   * @member {string} description
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   */
                  Role.prototype.description = "";

                  /**
                   * Creates a new Role instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.Role
                   * @static
                   * @param {syft_proto.execution.v1.IRole=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.Role} Role instance
                   */
                  Role.create = function create(properties) {
                      return new Role(properties);
                  };

                  /**
                   * Encodes the specified Role message. Does not implicitly {@link syft_proto.execution.v1.Role.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.Role
                   * @static
                   * @param {syft_proto.execution.v1.IRole} message Role message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Role.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.id != null && message.hasOwnProperty("id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.actions != null && message.actions.length)
                          for (var i = 0; i < message.actions.length; ++i)
                              $root.syft_proto.execution.v1.ComputationAction.encode(message.actions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      if (message.state != null && message.hasOwnProperty("state"))
                          $root.syft_proto.execution.v1.State.encode(message.state, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                      if (message.placeholders != null && message.placeholders.length)
                          for (var i = 0; i < message.placeholders.length; ++i)
                              $root.syft_proto.execution.v1.Placeholder.encode(message.placeholders[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                      if (message.input_placeholder_ids != null && message.input_placeholder_ids.length)
                          for (var i = 0; i < message.input_placeholder_ids.length; ++i)
                              $root.syft_proto.types.syft.v1.Id.encode(message.input_placeholder_ids[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                      if (message.output_placeholder_ids != null && message.output_placeholder_ids.length)
                          for (var i = 0; i < message.output_placeholder_ids.length; ++i)
                              $root.syft_proto.types.syft.v1.Id.encode(message.output_placeholder_ids[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                      if (message.tags != null && message.tags.length)
                          for (var i = 0; i < message.tags.length; ++i)
                              writer.uint32(/* id 7, wireType 2 =*/58).string(message.tags[i]);
                      if (message.description != null && message.hasOwnProperty("description"))
                          writer.uint32(/* id 8, wireType 2 =*/66).string(message.description);
                      return writer;
                  };

                  /**
                   * Encodes the specified Role message, length delimited. Does not implicitly {@link syft_proto.execution.v1.Role.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.Role
                   * @static
                   * @param {syft_proto.execution.v1.IRole} message Role message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Role.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a Role message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.Role
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.Role} Role
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Role.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.Role();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          case 2:
                              if (!(message.actions && message.actions.length))
                                  message.actions = [];
                              message.actions.push($root.syft_proto.execution.v1.ComputationAction.decode(reader, reader.uint32()));
                              break;
                          case 3:
                              message.state = $root.syft_proto.execution.v1.State.decode(reader, reader.uint32());
                              break;
                          case 4:
                              if (!(message.placeholders && message.placeholders.length))
                                  message.placeholders = [];
                              message.placeholders.push($root.syft_proto.execution.v1.Placeholder.decode(reader, reader.uint32()));
                              break;
                          case 5:
                              if (!(message.input_placeholder_ids && message.input_placeholder_ids.length))
                                  message.input_placeholder_ids = [];
                              message.input_placeholder_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                              break;
                          case 6:
                              if (!(message.output_placeholder_ids && message.output_placeholder_ids.length))
                                  message.output_placeholder_ids = [];
                              message.output_placeholder_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                              break;
                          case 7:
                              if (!(message.tags && message.tags.length))
                                  message.tags = [];
                              message.tags.push(reader.string());
                              break;
                          case 8:
                              message.description = reader.string();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a Role message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.Role
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.Role} Role
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Role.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a Role message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.Role
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  Role.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.id != null && message.hasOwnProperty("id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                          if (error)
                              return "id." + error;
                      }
                      if (message.actions != null && message.hasOwnProperty("actions")) {
                          if (!Array.isArray(message.actions))
                              return "actions: array expected";
                          for (var i = 0; i < message.actions.length; ++i) {
                              var error = $root.syft_proto.execution.v1.ComputationAction.verify(message.actions[i]);
                              if (error)
                                  return "actions." + error;
                          }
                      }
                      if (message.state != null && message.hasOwnProperty("state")) {
                          var error = $root.syft_proto.execution.v1.State.verify(message.state);
                          if (error)
                              return "state." + error;
                      }
                      if (message.placeholders != null && message.hasOwnProperty("placeholders")) {
                          if (!Array.isArray(message.placeholders))
                              return "placeholders: array expected";
                          for (var i = 0; i < message.placeholders.length; ++i) {
                              var error = $root.syft_proto.execution.v1.Placeholder.verify(message.placeholders[i]);
                              if (error)
                                  return "placeholders." + error;
                          }
                      }
                      if (message.input_placeholder_ids != null && message.hasOwnProperty("input_placeholder_ids")) {
                          if (!Array.isArray(message.input_placeholder_ids))
                              return "input_placeholder_ids: array expected";
                          for (var i = 0; i < message.input_placeholder_ids.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.input_placeholder_ids[i]);
                              if (error)
                                  return "input_placeholder_ids." + error;
                          }
                      }
                      if (message.output_placeholder_ids != null && message.hasOwnProperty("output_placeholder_ids")) {
                          if (!Array.isArray(message.output_placeholder_ids))
                              return "output_placeholder_ids: array expected";
                          for (var i = 0; i < message.output_placeholder_ids.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.output_placeholder_ids[i]);
                              if (error)
                                  return "output_placeholder_ids." + error;
                          }
                      }
                      if (message.tags != null && message.hasOwnProperty("tags")) {
                          if (!Array.isArray(message.tags))
                              return "tags: array expected";
                          for (var i = 0; i < message.tags.length; ++i)
                              if (!$util.isString(message.tags[i]))
                                  return "tags: string[] expected";
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          if (!$util.isString(message.description))
                              return "description: string expected";
                      return null;
                  };

                  /**
                   * Creates a Role message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.Role
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.Role} Role
                   */
                  Role.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.Role)
                          return object;
                      var message = new $root.syft_proto.execution.v1.Role();
                      if (object.id != null) {
                          if (typeof object.id !== "object")
                              throw TypeError(".syft_proto.execution.v1.Role.id: object expected");
                          message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                      }
                      if (object.actions) {
                          if (!Array.isArray(object.actions))
                              throw TypeError(".syft_proto.execution.v1.Role.actions: array expected");
                          message.actions = [];
                          for (var i = 0; i < object.actions.length; ++i) {
                              if (typeof object.actions[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.Role.actions: object expected");
                              message.actions[i] = $root.syft_proto.execution.v1.ComputationAction.fromObject(object.actions[i]);
                          }
                      }
                      if (object.state != null) {
                          if (typeof object.state !== "object")
                              throw TypeError(".syft_proto.execution.v1.Role.state: object expected");
                          message.state = $root.syft_proto.execution.v1.State.fromObject(object.state);
                      }
                      if (object.placeholders) {
                          if (!Array.isArray(object.placeholders))
                              throw TypeError(".syft_proto.execution.v1.Role.placeholders: array expected");
                          message.placeholders = [];
                          for (var i = 0; i < object.placeholders.length; ++i) {
                              if (typeof object.placeholders[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.Role.placeholders: object expected");
                              message.placeholders[i] = $root.syft_proto.execution.v1.Placeholder.fromObject(object.placeholders[i]);
                          }
                      }
                      if (object.input_placeholder_ids) {
                          if (!Array.isArray(object.input_placeholder_ids))
                              throw TypeError(".syft_proto.execution.v1.Role.input_placeholder_ids: array expected");
                          message.input_placeholder_ids = [];
                          for (var i = 0; i < object.input_placeholder_ids.length; ++i) {
                              if (typeof object.input_placeholder_ids[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.Role.input_placeholder_ids: object expected");
                              message.input_placeholder_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.input_placeholder_ids[i]);
                          }
                      }
                      if (object.output_placeholder_ids) {
                          if (!Array.isArray(object.output_placeholder_ids))
                              throw TypeError(".syft_proto.execution.v1.Role.output_placeholder_ids: array expected");
                          message.output_placeholder_ids = [];
                          for (var i = 0; i < object.output_placeholder_ids.length; ++i) {
                              if (typeof object.output_placeholder_ids[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.Role.output_placeholder_ids: object expected");
                              message.output_placeholder_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.output_placeholder_ids[i]);
                          }
                      }
                      if (object.tags) {
                          if (!Array.isArray(object.tags))
                              throw TypeError(".syft_proto.execution.v1.Role.tags: array expected");
                          message.tags = [];
                          for (var i = 0; i < object.tags.length; ++i)
                              message.tags[i] = String(object.tags[i]);
                      }
                      if (object.description != null)
                          message.description = String(object.description);
                      return message;
                  };

                  /**
                   * Creates a plain object from a Role message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.Role
                   * @static
                   * @param {syft_proto.execution.v1.Role} message Role
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  Role.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults) {
                          object.actions = [];
                          object.placeholders = [];
                          object.input_placeholder_ids = [];
                          object.output_placeholder_ids = [];
                          object.tags = [];
                      }
                      if (options.defaults) {
                          object.id = null;
                          object.state = null;
                          object.description = "";
                      }
                      if (message.id != null && message.hasOwnProperty("id"))
                          object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                      if (message.actions && message.actions.length) {
                          object.actions = [];
                          for (var j = 0; j < message.actions.length; ++j)
                              object.actions[j] = $root.syft_proto.execution.v1.ComputationAction.toObject(message.actions[j], options);
                      }
                      if (message.state != null && message.hasOwnProperty("state"))
                          object.state = $root.syft_proto.execution.v1.State.toObject(message.state, options);
                      if (message.placeholders && message.placeholders.length) {
                          object.placeholders = [];
                          for (var j = 0; j < message.placeholders.length; ++j)
                              object.placeholders[j] = $root.syft_proto.execution.v1.Placeholder.toObject(message.placeholders[j], options);
                      }
                      if (message.input_placeholder_ids && message.input_placeholder_ids.length) {
                          object.input_placeholder_ids = [];
                          for (var j = 0; j < message.input_placeholder_ids.length; ++j)
                              object.input_placeholder_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.input_placeholder_ids[j], options);
                      }
                      if (message.output_placeholder_ids && message.output_placeholder_ids.length) {
                          object.output_placeholder_ids = [];
                          for (var j = 0; j < message.output_placeholder_ids.length; ++j)
                              object.output_placeholder_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.output_placeholder_ids[j], options);
                      }
                      if (message.tags && message.tags.length) {
                          object.tags = [];
                          for (var j = 0; j < message.tags.length; ++j)
                              object.tags[j] = message.tags[j];
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          object.description = message.description;
                      return object;
                  };

                  /**
                   * Converts this Role to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.Role
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  Role.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return Role;
              })();

              v1.State = (function() {

                  /**
                   * Properties of a State.
                   * @memberof syft_proto.execution.v1
                   * @interface IState
                   * @property {Array.<syft_proto.execution.v1.IPlaceholder>|null} [placeholders] State placeholders
                   * @property {Array.<syft_proto.execution.v1.IStateTensor>|null} [tensors] State tensors
                   */

                  /**
                   * Constructs a new State.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a State.
                   * @implements IState
                   * @constructor
                   * @param {syft_proto.execution.v1.IState=} [properties] Properties to set
                   */
                  function State(properties) {
                      this.placeholders = [];
                      this.tensors = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * State placeholders.
                   * @member {Array.<syft_proto.execution.v1.IPlaceholder>} placeholders
                   * @memberof syft_proto.execution.v1.State
                   * @instance
                   */
                  State.prototype.placeholders = $util.emptyArray;

                  /**
                   * State tensors.
                   * @member {Array.<syft_proto.execution.v1.IStateTensor>} tensors
                   * @memberof syft_proto.execution.v1.State
                   * @instance
                   */
                  State.prototype.tensors = $util.emptyArray;

                  /**
                   * Creates a new State instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.State
                   * @static
                   * @param {syft_proto.execution.v1.IState=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.State} State instance
                   */
                  State.create = function create(properties) {
                      return new State(properties);
                  };

                  /**
                   * Encodes the specified State message. Does not implicitly {@link syft_proto.execution.v1.State.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.State
                   * @static
                   * @param {syft_proto.execution.v1.IState} message State message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  State.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.placeholders != null && message.placeholders.length)
                          for (var i = 0; i < message.placeholders.length; ++i)
                              $root.syft_proto.execution.v1.Placeholder.encode(message.placeholders[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.tensors != null && message.tensors.length)
                          for (var i = 0; i < message.tensors.length; ++i)
                              $root.syft_proto.execution.v1.StateTensor.encode(message.tensors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified State message, length delimited. Does not implicitly {@link syft_proto.execution.v1.State.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.State
                   * @static
                   * @param {syft_proto.execution.v1.IState} message State message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  State.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a State message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.State
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.State} State
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  State.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.State();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              if (!(message.placeholders && message.placeholders.length))
                                  message.placeholders = [];
                              message.placeholders.push($root.syft_proto.execution.v1.Placeholder.decode(reader, reader.uint32()));
                              break;
                          case 2:
                              if (!(message.tensors && message.tensors.length))
                                  message.tensors = [];
                              message.tensors.push($root.syft_proto.execution.v1.StateTensor.decode(reader, reader.uint32()));
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a State message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.State
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.State} State
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  State.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a State message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.State
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  State.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.placeholders != null && message.hasOwnProperty("placeholders")) {
                          if (!Array.isArray(message.placeholders))
                              return "placeholders: array expected";
                          for (var i = 0; i < message.placeholders.length; ++i) {
                              var error = $root.syft_proto.execution.v1.Placeholder.verify(message.placeholders[i]);
                              if (error)
                                  return "placeholders." + error;
                          }
                      }
                      if (message.tensors != null && message.hasOwnProperty("tensors")) {
                          if (!Array.isArray(message.tensors))
                              return "tensors: array expected";
                          for (var i = 0; i < message.tensors.length; ++i) {
                              var error = $root.syft_proto.execution.v1.StateTensor.verify(message.tensors[i]);
                              if (error)
                                  return "tensors." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a State message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.State
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.State} State
                   */
                  State.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.State)
                          return object;
                      var message = new $root.syft_proto.execution.v1.State();
                      if (object.placeholders) {
                          if (!Array.isArray(object.placeholders))
                              throw TypeError(".syft_proto.execution.v1.State.placeholders: array expected");
                          message.placeholders = [];
                          for (var i = 0; i < object.placeholders.length; ++i) {
                              if (typeof object.placeholders[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.State.placeholders: object expected");
                              message.placeholders[i] = $root.syft_proto.execution.v1.Placeholder.fromObject(object.placeholders[i]);
                          }
                      }
                      if (object.tensors) {
                          if (!Array.isArray(object.tensors))
                              throw TypeError(".syft_proto.execution.v1.State.tensors: array expected");
                          message.tensors = [];
                          for (var i = 0; i < object.tensors.length; ++i) {
                              if (typeof object.tensors[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.State.tensors: object expected");
                              message.tensors[i] = $root.syft_proto.execution.v1.StateTensor.fromObject(object.tensors[i]);
                          }
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a State message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.State
                   * @static
                   * @param {syft_proto.execution.v1.State} message State
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  State.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults) {
                          object.placeholders = [];
                          object.tensors = [];
                      }
                      if (message.placeholders && message.placeholders.length) {
                          object.placeholders = [];
                          for (var j = 0; j < message.placeholders.length; ++j)
                              object.placeholders[j] = $root.syft_proto.execution.v1.Placeholder.toObject(message.placeholders[j], options);
                      }
                      if (message.tensors && message.tensors.length) {
                          object.tensors = [];
                          for (var j = 0; j < message.tensors.length; ++j)
                              object.tensors[j] = $root.syft_proto.execution.v1.StateTensor.toObject(message.tensors[j], options);
                      }
                      return object;
                  };

                  /**
                   * Converts this State to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.State
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  State.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return State;
              })();

              v1.StateTensor = (function() {

                  /**
                   * Properties of a StateTensor.
                   * @memberof syft_proto.execution.v1
                   * @interface IStateTensor
                   * @property {syft_proto.types.torch.v1.ITorchTensor|null} [torch_tensor] StateTensor torch_tensor
                   * @property {syft_proto.types.torch.v1.IParameter|null} [torch_param] StateTensor torch_param
                   */

                  /**
                   * Constructs a new StateTensor.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a StateTensor.
                   * @implements IStateTensor
                   * @constructor
                   * @param {syft_proto.execution.v1.IStateTensor=} [properties] Properties to set
                   */
                  function StateTensor(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * StateTensor torch_tensor.
                   * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} torch_tensor
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @instance
                   */
                  StateTensor.prototype.torch_tensor = null;

                  /**
                   * StateTensor torch_param.
                   * @member {syft_proto.types.torch.v1.IParameter|null|undefined} torch_param
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @instance
                   */
                  StateTensor.prototype.torch_param = null;

                  // OneOf field names bound to virtual getters and setters
                  var $oneOfFields;

                  /**
                   * StateTensor tensor.
                   * @member {"torch_tensor"|"torch_param"|undefined} tensor
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @instance
                   */
                  Object.defineProperty(StateTensor.prototype, "tensor", {
                      get: $util.oneOfGetter($oneOfFields = ["torch_tensor", "torch_param"]),
                      set: $util.oneOfSetter($oneOfFields)
                  });

                  /**
                   * Creates a new StateTensor instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @static
                   * @param {syft_proto.execution.v1.IStateTensor=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.StateTensor} StateTensor instance
                   */
                  StateTensor.create = function create(properties) {
                      return new StateTensor(properties);
                  };

                  /**
                   * Encodes the specified StateTensor message. Does not implicitly {@link syft_proto.execution.v1.StateTensor.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @static
                   * @param {syft_proto.execution.v1.IStateTensor} message StateTensor message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  StateTensor.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.torch_tensor != null && message.hasOwnProperty("torch_tensor"))
                          $root.syft_proto.types.torch.v1.TorchTensor.encode(message.torch_tensor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.torch_param != null && message.hasOwnProperty("torch_param"))
                          $root.syft_proto.types.torch.v1.Parameter.encode(message.torch_param, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified StateTensor message, length delimited. Does not implicitly {@link syft_proto.execution.v1.StateTensor.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @static
                   * @param {syft_proto.execution.v1.IStateTensor} message StateTensor message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  StateTensor.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a StateTensor message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.StateTensor} StateTensor
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  StateTensor.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.StateTensor();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.torch_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.torch_param = $root.syft_proto.types.torch.v1.Parameter.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a StateTensor message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.StateTensor} StateTensor
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  StateTensor.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a StateTensor message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  StateTensor.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      var properties = {};
                      if (message.torch_tensor != null && message.hasOwnProperty("torch_tensor")) {
                          properties.tensor = 1;
                          {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.torch_tensor);
                              if (error)
                                  return "torch_tensor." + error;
                          }
                      }
                      if (message.torch_param != null && message.hasOwnProperty("torch_param")) {
                          if (properties.tensor === 1)
                              return "tensor: multiple values";
                          properties.tensor = 1;
                          {
                              var error = $root.syft_proto.types.torch.v1.Parameter.verify(message.torch_param);
                              if (error)
                                  return "torch_param." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a StateTensor message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.StateTensor} StateTensor
                   */
                  StateTensor.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.StateTensor)
                          return object;
                      var message = new $root.syft_proto.execution.v1.StateTensor();
                      if (object.torch_tensor != null) {
                          if (typeof object.torch_tensor !== "object")
                              throw TypeError(".syft_proto.execution.v1.StateTensor.torch_tensor: object expected");
                          message.torch_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.torch_tensor);
                      }
                      if (object.torch_param != null) {
                          if (typeof object.torch_param !== "object")
                              throw TypeError(".syft_proto.execution.v1.StateTensor.torch_param: object expected");
                          message.torch_param = $root.syft_proto.types.torch.v1.Parameter.fromObject(object.torch_param);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a StateTensor message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @static
                   * @param {syft_proto.execution.v1.StateTensor} message StateTensor
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  StateTensor.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (message.torch_tensor != null && message.hasOwnProperty("torch_tensor")) {
                          object.torch_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.torch_tensor, options);
                          if (options.oneofs)
                              object.tensor = "torch_tensor";
                      }
                      if (message.torch_param != null && message.hasOwnProperty("torch_param")) {
                          object.torch_param = $root.syft_proto.types.torch.v1.Parameter.toObject(message.torch_param, options);
                          if (options.oneofs)
                              object.tensor = "torch_param";
                      }
                      return object;
                  };

                  /**
                   * Converts this StateTensor to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.StateTensor
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  StateTensor.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return StateTensor;
              })();

              v1.InputTypeDescriptor = (function() {

                  /**
                   * Properties of an InputTypeDescriptor.
                   * @memberof syft_proto.execution.v1
                   * @interface IInputTypeDescriptor
                   * @property {string|null} [type_name] InputTypeDescriptor type_name
                   */

                  /**
                   * Constructs a new InputTypeDescriptor.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents an InputTypeDescriptor.
                   * @implements IInputTypeDescriptor
                   * @constructor
                   * @param {syft_proto.execution.v1.IInputTypeDescriptor=} [properties] Properties to set
                   */
                  function InputTypeDescriptor(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * InputTypeDescriptor type_name.
                   * @member {string} type_name
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @instance
                   */
                  InputTypeDescriptor.prototype.type_name = "";

                  /**
                   * Creates a new InputTypeDescriptor instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @static
                   * @param {syft_proto.execution.v1.IInputTypeDescriptor=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.InputTypeDescriptor} InputTypeDescriptor instance
                   */
                  InputTypeDescriptor.create = function create(properties) {
                      return new InputTypeDescriptor(properties);
                  };

                  /**
                   * Encodes the specified InputTypeDescriptor message. Does not implicitly {@link syft_proto.execution.v1.InputTypeDescriptor.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @static
                   * @param {syft_proto.execution.v1.IInputTypeDescriptor} message InputTypeDescriptor message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  InputTypeDescriptor.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.type_name != null && message.hasOwnProperty("type_name"))
                          writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_name);
                      return writer;
                  };

                  /**
                   * Encodes the specified InputTypeDescriptor message, length delimited. Does not implicitly {@link syft_proto.execution.v1.InputTypeDescriptor.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @static
                   * @param {syft_proto.execution.v1.IInputTypeDescriptor} message InputTypeDescriptor message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  InputTypeDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes an InputTypeDescriptor message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.InputTypeDescriptor} InputTypeDescriptor
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  InputTypeDescriptor.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.InputTypeDescriptor();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.type_name = reader.string();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes an InputTypeDescriptor message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.InputTypeDescriptor} InputTypeDescriptor
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  InputTypeDescriptor.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies an InputTypeDescriptor message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  InputTypeDescriptor.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.type_name != null && message.hasOwnProperty("type_name"))
                          if (!$util.isString(message.type_name))
                              return "type_name: string expected";
                      return null;
                  };

                  /**
                   * Creates an InputTypeDescriptor message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.InputTypeDescriptor} InputTypeDescriptor
                   */
                  InputTypeDescriptor.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.InputTypeDescriptor)
                          return object;
                      var message = new $root.syft_proto.execution.v1.InputTypeDescriptor();
                      if (object.type_name != null)
                          message.type_name = String(object.type_name);
                      return message;
                  };

                  /**
                   * Creates a plain object from an InputTypeDescriptor message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @static
                   * @param {syft_proto.execution.v1.InputTypeDescriptor} message InputTypeDescriptor
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  InputTypeDescriptor.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults)
                          object.type_name = "";
                      if (message.type_name != null && message.hasOwnProperty("type_name"))
                          object.type_name = message.type_name;
                      return object;
                  };

                  /**
                   * Converts this InputTypeDescriptor to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.InputTypeDescriptor
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  InputTypeDescriptor.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return InputTypeDescriptor;
              })();

              v1.NestedTypeWrapper = (function() {

                  /**
                   * Properties of a NestedTypeWrapper.
                   * @memberof syft_proto.execution.v1
                   * @interface INestedTypeWrapper
                   * @property {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer|null} [nested_types] NestedTypeWrapper nested_types
                   */

                  /**
                   * Constructs a new NestedTypeWrapper.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a NestedTypeWrapper.
                   * @implements INestedTypeWrapper
                   * @constructor
                   * @param {syft_proto.execution.v1.INestedTypeWrapper=} [properties] Properties to set
                   */
                  function NestedTypeWrapper(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * NestedTypeWrapper nested_types.
                   * @member {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer|null|undefined} nested_types
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @instance
                   */
                  NestedTypeWrapper.prototype.nested_types = null;

                  /**
                   * Creates a new NestedTypeWrapper instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @static
                   * @param {syft_proto.execution.v1.INestedTypeWrapper=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.NestedTypeWrapper} NestedTypeWrapper instance
                   */
                  NestedTypeWrapper.create = function create(properties) {
                      return new NestedTypeWrapper(properties);
                  };

                  /**
                   * Encodes the specified NestedTypeWrapper message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @static
                   * @param {syft_proto.execution.v1.INestedTypeWrapper} message NestedTypeWrapper message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  NestedTypeWrapper.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.nested_types != null && message.hasOwnProperty("nested_types"))
                          $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.encode(message.nested_types, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified NestedTypeWrapper message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @static
                   * @param {syft_proto.execution.v1.INestedTypeWrapper} message NestedTypeWrapper message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  NestedTypeWrapper.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a NestedTypeWrapper message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.NestedTypeWrapper} NestedTypeWrapper
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  NestedTypeWrapper.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.nested_types = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a NestedTypeWrapper message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.NestedTypeWrapper} NestedTypeWrapper
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  NestedTypeWrapper.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a NestedTypeWrapper message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  NestedTypeWrapper.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.nested_types != null && message.hasOwnProperty("nested_types")) {
                          var error = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.verify(message.nested_types);
                          if (error)
                              return "nested_types." + error;
                      }
                      return null;
                  };

                  /**
                   * Creates a NestedTypeWrapper message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.NestedTypeWrapper} NestedTypeWrapper
                   */
                  NestedTypeWrapper.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper)
                          return object;
                      var message = new $root.syft_proto.execution.v1.NestedTypeWrapper();
                      if (object.nested_types != null) {
                          if (typeof object.nested_types !== "object")
                              throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.nested_types: object expected");
                          message.nested_types = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.fromObject(object.nested_types);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a NestedTypeWrapper message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @static
                   * @param {syft_proto.execution.v1.NestedTypeWrapper} message NestedTypeWrapper
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  NestedTypeWrapper.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults)
                          object.nested_types = null;
                      if (message.nested_types != null && message.hasOwnProperty("nested_types"))
                          object.nested_types = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.toObject(message.nested_types, options);
                      return object;
                  };

                  /**
                   * Converts this NestedTypeWrapper to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.NestedTypeWrapper
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  NestedTypeWrapper.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  NestedTypeWrapper.TypeList = (function() {

                      /**
                       * Properties of a TypeList.
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper
                       * @interface ITypeList
                       * @property {Array.<syft_proto.execution.v1.INestedTypeWrapper>|null} [nested_types] TypeList nested_types
                       */

                      /**
                       * Constructs a new TypeList.
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper
                       * @classdesc Represents a TypeList.
                       * @implements ITypeList
                       * @constructor
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeList=} [properties] Properties to set
                       */
                      function TypeList(properties) {
                          this.nested_types = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * TypeList nested_types.
                       * @member {Array.<syft_proto.execution.v1.INestedTypeWrapper>} nested_types
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @instance
                       */
                      TypeList.prototype.nested_types = $util.emptyArray;

                      /**
                       * Creates a new TypeList instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeList=} [properties] Properties to set
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeList} TypeList instance
                       */
                      TypeList.create = function create(properties) {
                          return new TypeList(properties);
                      };

                      /**
                       * Encodes the specified TypeList message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeList.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeList} message TypeList message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TypeList.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.nested_types != null && message.nested_types.length)
                              for (var i = 0; i < message.nested_types.length; ++i)
                                  $root.syft_proto.execution.v1.NestedTypeWrapper.encode(message.nested_types[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          return writer;
                      };

                      /**
                       * Encodes the specified TypeList message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeList.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeList} message TypeList message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TypeList.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a TypeList message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeList} TypeList
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TypeList.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  if (!(message.nested_types && message.nested_types.length))
                                      message.nested_types = [];
                                  message.nested_types.push($root.syft_proto.execution.v1.NestedTypeWrapper.decode(reader, reader.uint32()));
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a TypeList message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeList} TypeList
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TypeList.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a TypeList message.
                       * @function verify
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      TypeList.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.nested_types != null && message.hasOwnProperty("nested_types")) {
                              if (!Array.isArray(message.nested_types))
                                  return "nested_types: array expected";
                              for (var i = 0; i < message.nested_types.length; ++i) {
                                  var error = $root.syft_proto.execution.v1.NestedTypeWrapper.verify(message.nested_types[i]);
                                  if (error)
                                      return "nested_types." + error;
                              }
                          }
                          return null;
                      };

                      /**
                       * Creates a TypeList message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeList} TypeList
                       */
                      TypeList.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList)
                              return object;
                          var message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList();
                          if (object.nested_types) {
                              if (!Array.isArray(object.nested_types))
                                  throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeList.nested_types: array expected");
                              message.nested_types = [];
                              for (var i = 0; i < object.nested_types.length; ++i) {
                                  if (typeof object.nested_types[i] !== "object")
                                      throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeList.nested_types: object expected");
                                  message.nested_types[i] = $root.syft_proto.execution.v1.NestedTypeWrapper.fromObject(object.nested_types[i]);
                              }
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a TypeList message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.TypeList} message TypeList
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      TypeList.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults)
                              object.nested_types = [];
                          if (message.nested_types && message.nested_types.length) {
                              object.nested_types = [];
                              for (var j = 0; j < message.nested_types.length; ++j)
                                  object.nested_types[j] = $root.syft_proto.execution.v1.NestedTypeWrapper.toObject(message.nested_types[j], options);
                          }
                          return object;
                      };

                      /**
                       * Converts this TypeList to JSON.
                       * @function toJSON
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeList
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      TypeList.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return TypeList;
                  })();

                  NestedTypeWrapper.TypeTuple = (function() {

                      /**
                       * Properties of a TypeTuple.
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper
                       * @interface ITypeTuple
                       * @property {Array.<syft_proto.execution.v1.INestedTypeWrapper>|null} [nested_types] TypeTuple nested_types
                       */

                      /**
                       * Constructs a new TypeTuple.
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper
                       * @classdesc Represents a TypeTuple.
                       * @implements ITypeTuple
                       * @constructor
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple=} [properties] Properties to set
                       */
                      function TypeTuple(properties) {
                          this.nested_types = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * TypeTuple nested_types.
                       * @member {Array.<syft_proto.execution.v1.INestedTypeWrapper>} nested_types
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @instance
                       */
                      TypeTuple.prototype.nested_types = $util.emptyArray;

                      /**
                       * Creates a new TypeTuple instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple=} [properties] Properties to set
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} TypeTuple instance
                       */
                      TypeTuple.create = function create(properties) {
                          return new TypeTuple(properties);
                      };

                      /**
                       * Encodes the specified TypeTuple message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple} message TypeTuple message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TypeTuple.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.nested_types != null && message.nested_types.length)
                              for (var i = 0; i < message.nested_types.length; ++i)
                                  $root.syft_proto.execution.v1.NestedTypeWrapper.encode(message.nested_types[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          return writer;
                      };

                      /**
                       * Encodes the specified TypeTuple message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple} message TypeTuple message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TypeTuple.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a TypeTuple message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} TypeTuple
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TypeTuple.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  if (!(message.nested_types && message.nested_types.length))
                                      message.nested_types = [];
                                  message.nested_types.push($root.syft_proto.execution.v1.NestedTypeWrapper.decode(reader, reader.uint32()));
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a TypeTuple message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} TypeTuple
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TypeTuple.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a TypeTuple message.
                       * @function verify
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      TypeTuple.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.nested_types != null && message.hasOwnProperty("nested_types")) {
                              if (!Array.isArray(message.nested_types))
                                  return "nested_types: array expected";
                              for (var i = 0; i < message.nested_types.length; ++i) {
                                  var error = $root.syft_proto.execution.v1.NestedTypeWrapper.verify(message.nested_types[i]);
                                  if (error)
                                      return "nested_types." + error;
                              }
                          }
                          return null;
                      };

                      /**
                       * Creates a TypeTuple message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} TypeTuple
                       */
                      TypeTuple.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple)
                              return object;
                          var message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple();
                          if (object.nested_types) {
                              if (!Array.isArray(object.nested_types))
                                  throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.nested_types: array expected");
                              message.nested_types = [];
                              for (var i = 0; i < object.nested_types.length; ++i) {
                                  if (typeof object.nested_types[i] !== "object")
                                      throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.nested_types: object expected");
                                  message.nested_types[i] = $root.syft_proto.execution.v1.NestedTypeWrapper.fromObject(object.nested_types[i]);
                              }
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a TypeTuple message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.TypeTuple} message TypeTuple
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      TypeTuple.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults)
                              object.nested_types = [];
                          if (message.nested_types && message.nested_types.length) {
                              object.nested_types = [];
                              for (var j = 0; j < message.nested_types.length; ++j)
                                  object.nested_types[j] = $root.syft_proto.execution.v1.NestedTypeWrapper.toObject(message.nested_types[j], options);
                          }
                          return object;
                      };

                      /**
                       * Converts this TypeTuple to JSON.
                       * @function toJSON
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeTuple
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      TypeTuple.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return TypeTuple;
                  })();

                  NestedTypeWrapper.TypeMap = (function() {

                      /**
                       * Properties of a TypeMap.
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper
                       * @interface ITypeMap
                       * @property {Object.<string,syft_proto.execution.v1.INestedTypeWrapper>|null} [nested_types] TypeMap nested_types
                       */

                      /**
                       * Constructs a new TypeMap.
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper
                       * @classdesc Represents a TypeMap.
                       * @implements ITypeMap
                       * @constructor
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap=} [properties] Properties to set
                       */
                      function TypeMap(properties) {
                          this.nested_types = {};
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * TypeMap nested_types.
                       * @member {Object.<string,syft_proto.execution.v1.INestedTypeWrapper>} nested_types
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @instance
                       */
                      TypeMap.prototype.nested_types = $util.emptyObject;

                      /**
                       * Creates a new TypeMap instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap=} [properties] Properties to set
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} TypeMap instance
                       */
                      TypeMap.create = function create(properties) {
                          return new TypeMap(properties);
                      };

                      /**
                       * Encodes the specified TypeMap message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeMap.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap} message TypeMap message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TypeMap.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.nested_types != null && message.hasOwnProperty("nested_types"))
                              for (var keys = Object.keys(message.nested_types), i = 0; i < keys.length; ++i) {
                                  writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                                  $root.syft_proto.execution.v1.NestedTypeWrapper.encode(message.nested_types[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                              }
                          return writer;
                      };

                      /**
                       * Encodes the specified TypeMap message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeMap.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap} message TypeMap message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TypeMap.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a TypeMap message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} TypeMap
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TypeMap.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap(), key;
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  reader.skip().pos++;
                                  if (message.nested_types === $util.emptyObject)
                                      message.nested_types = {};
                                  key = reader.string();
                                  reader.pos++;
                                  message.nested_types[key] = $root.syft_proto.execution.v1.NestedTypeWrapper.decode(reader, reader.uint32());
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a TypeMap message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} TypeMap
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TypeMap.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a TypeMap message.
                       * @function verify
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      TypeMap.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.nested_types != null && message.hasOwnProperty("nested_types")) {
                              if (!$util.isObject(message.nested_types))
                                  return "nested_types: object expected";
                              var key = Object.keys(message.nested_types);
                              for (var i = 0; i < key.length; ++i) {
                                  var error = $root.syft_proto.execution.v1.NestedTypeWrapper.verify(message.nested_types[key[i]]);
                                  if (error)
                                      return "nested_types." + error;
                              }
                          }
                          return null;
                      };

                      /**
                       * Creates a TypeMap message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} TypeMap
                       */
                      TypeMap.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap)
                              return object;
                          var message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap();
                          if (object.nested_types) {
                              if (typeof object.nested_types !== "object")
                                  throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeMap.nested_types: object expected");
                              message.nested_types = {};
                              for (var keys = Object.keys(object.nested_types), i = 0; i < keys.length; ++i) {
                                  if (typeof object.nested_types[keys[i]] !== "object")
                                      throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeMap.nested_types: object expected");
                                  message.nested_types[keys[i]] = $root.syft_proto.execution.v1.NestedTypeWrapper.fromObject(object.nested_types[keys[i]]);
                              }
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a TypeMap message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.TypeMap} message TypeMap
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      TypeMap.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.objects || options.defaults)
                              object.nested_types = {};
                          var keys2;
                          if (message.nested_types && (keys2 = Object.keys(message.nested_types)).length) {
                              object.nested_types = {};
                              for (var j = 0; j < keys2.length; ++j)
                                  object.nested_types[keys2[j]] = $root.syft_proto.execution.v1.NestedTypeWrapper.toObject(message.nested_types[keys2[j]], options);
                          }
                          return object;
                      };

                      /**
                       * Converts this TypeMap to JSON.
                       * @function toJSON
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeMap
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      TypeMap.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return TypeMap;
                  })();

                  NestedTypeWrapper.TypeContainer = (function() {

                      /**
                       * Properties of a TypeContainer.
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper
                       * @interface ITypeContainer
                       * @property {syft_proto.execution.v1.IInputTypeDescriptor|null} [nested_type] TypeContainer nested_type
                       * @property {syft_proto.execution.v1.NestedTypeWrapper.ITypeList|null} [nested_type_list] TypeContainer nested_type_list
                       * @property {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple|null} [nested_type_tuple] TypeContainer nested_type_tuple
                       * @property {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap|null} [nested_type_dict] TypeContainer nested_type_dict
                       */

                      /**
                       * Constructs a new TypeContainer.
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper
                       * @classdesc Represents a TypeContainer.
                       * @implements ITypeContainer
                       * @constructor
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer=} [properties] Properties to set
                       */
                      function TypeContainer(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * TypeContainer nested_type.
                       * @member {syft_proto.execution.v1.IInputTypeDescriptor|null|undefined} nested_type
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @instance
                       */
                      TypeContainer.prototype.nested_type = null;

                      /**
                       * TypeContainer nested_type_list.
                       * @member {syft_proto.execution.v1.NestedTypeWrapper.ITypeList|null|undefined} nested_type_list
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @instance
                       */
                      TypeContainer.prototype.nested_type_list = null;

                      /**
                       * TypeContainer nested_type_tuple.
                       * @member {syft_proto.execution.v1.NestedTypeWrapper.ITypeTuple|null|undefined} nested_type_tuple
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @instance
                       */
                      TypeContainer.prototype.nested_type_tuple = null;

                      /**
                       * TypeContainer nested_type_dict.
                       * @member {syft_proto.execution.v1.NestedTypeWrapper.ITypeMap|null|undefined} nested_type_dict
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @instance
                       */
                      TypeContainer.prototype.nested_type_dict = null;

                      // OneOf field names bound to virtual getters and setters
                      var $oneOfFields;

                      /**
                       * TypeContainer nested_container.
                       * @member {"nested_type"|"nested_type_list"|"nested_type_tuple"|"nested_type_dict"|undefined} nested_container
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @instance
                       */
                      Object.defineProperty(TypeContainer.prototype, "nested_container", {
                          get: $util.oneOfGetter($oneOfFields = ["nested_type", "nested_type_list", "nested_type_tuple", "nested_type_dict"]),
                          set: $util.oneOfSetter($oneOfFields)
                      });

                      /**
                       * Creates a new TypeContainer instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer=} [properties] Properties to set
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} TypeContainer instance
                       */
                      TypeContainer.create = function create(properties) {
                          return new TypeContainer(properties);
                      };

                      /**
                       * Encodes the specified TypeContainer message. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer} message TypeContainer message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TypeContainer.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.nested_type != null && message.hasOwnProperty("nested_type"))
                              $root.syft_proto.execution.v1.InputTypeDescriptor.encode(message.nested_type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          if (message.nested_type_list != null && message.hasOwnProperty("nested_type_list"))
                              $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.encode(message.nested_type_list, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                          if (message.nested_type_tuple != null && message.hasOwnProperty("nested_type_tuple"))
                              $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.encode(message.nested_type_tuple, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                          if (message.nested_type_dict != null && message.hasOwnProperty("nested_type_dict"))
                              $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.encode(message.nested_type_dict, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                          return writer;
                      };

                      /**
                       * Encodes the specified TypeContainer message, length delimited. Does not implicitly {@link syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.ITypeContainer} message TypeContainer message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TypeContainer.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a TypeContainer message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} TypeContainer
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TypeContainer.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.nested_type = $root.syft_proto.execution.v1.InputTypeDescriptor.decode(reader, reader.uint32());
                                  break;
                              case 2:
                                  message.nested_type_list = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.decode(reader, reader.uint32());
                                  break;
                              case 3:
                                  message.nested_type_tuple = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.decode(reader, reader.uint32());
                                  break;
                              case 4:
                                  message.nested_type_dict = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.decode(reader, reader.uint32());
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a TypeContainer message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} TypeContainer
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TypeContainer.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a TypeContainer message.
                       * @function verify
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      TypeContainer.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          var properties = {};
                          if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                              properties.nested_container = 1;
                              {
                                  var error = $root.syft_proto.execution.v1.InputTypeDescriptor.verify(message.nested_type);
                                  if (error)
                                      return "nested_type." + error;
                              }
                          }
                          if (message.nested_type_list != null && message.hasOwnProperty("nested_type_list")) {
                              if (properties.nested_container === 1)
                                  return "nested_container: multiple values";
                              properties.nested_container = 1;
                              {
                                  var error = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.verify(message.nested_type_list);
                                  if (error)
                                      return "nested_type_list." + error;
                              }
                          }
                          if (message.nested_type_tuple != null && message.hasOwnProperty("nested_type_tuple")) {
                              if (properties.nested_container === 1)
                                  return "nested_container: multiple values";
                              properties.nested_container = 1;
                              {
                                  var error = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.verify(message.nested_type_tuple);
                                  if (error)
                                      return "nested_type_tuple." + error;
                              }
                          }
                          if (message.nested_type_dict != null && message.hasOwnProperty("nested_type_dict")) {
                              if (properties.nested_container === 1)
                                  return "nested_container: multiple values";
                              properties.nested_container = 1;
                              {
                                  var error = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.verify(message.nested_type_dict);
                                  if (error)
                                      return "nested_type_dict." + error;
                              }
                          }
                          return null;
                      };

                      /**
                       * Creates a TypeContainer message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} TypeContainer
                       */
                      TypeContainer.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer)
                              return object;
                          var message = new $root.syft_proto.execution.v1.NestedTypeWrapper.TypeContainer();
                          if (object.nested_type != null) {
                              if (typeof object.nested_type !== "object")
                                  throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.nested_type: object expected");
                              message.nested_type = $root.syft_proto.execution.v1.InputTypeDescriptor.fromObject(object.nested_type);
                          }
                          if (object.nested_type_list != null) {
                              if (typeof object.nested_type_list !== "object")
                                  throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.nested_type_list: object expected");
                              message.nested_type_list = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.fromObject(object.nested_type_list);
                          }
                          if (object.nested_type_tuple != null) {
                              if (typeof object.nested_type_tuple !== "object")
                                  throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.nested_type_tuple: object expected");
                              message.nested_type_tuple = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.fromObject(object.nested_type_tuple);
                          }
                          if (object.nested_type_dict != null) {
                              if (typeof object.nested_type_dict !== "object")
                                  throw TypeError(".syft_proto.execution.v1.NestedTypeWrapper.TypeContainer.nested_type_dict: object expected");
                              message.nested_type_dict = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.fromObject(object.nested_type_dict);
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a TypeContainer message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @static
                       * @param {syft_proto.execution.v1.NestedTypeWrapper.TypeContainer} message TypeContainer
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      TypeContainer.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                              object.nested_type = $root.syft_proto.execution.v1.InputTypeDescriptor.toObject(message.nested_type, options);
                              if (options.oneofs)
                                  object.nested_container = "nested_type";
                          }
                          if (message.nested_type_list != null && message.hasOwnProperty("nested_type_list")) {
                              object.nested_type_list = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeList.toObject(message.nested_type_list, options);
                              if (options.oneofs)
                                  object.nested_container = "nested_type_list";
                          }
                          if (message.nested_type_tuple != null && message.hasOwnProperty("nested_type_tuple")) {
                              object.nested_type_tuple = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeTuple.toObject(message.nested_type_tuple, options);
                              if (options.oneofs)
                                  object.nested_container = "nested_type_tuple";
                          }
                          if (message.nested_type_dict != null && message.hasOwnProperty("nested_type_dict")) {
                              object.nested_type_dict = $root.syft_proto.execution.v1.NestedTypeWrapper.TypeMap.toObject(message.nested_type_dict, options);
                              if (options.oneofs)
                                  object.nested_container = "nested_type_dict";
                          }
                          return object;
                      };

                      /**
                       * Converts this TypeContainer to JSON.
                       * @function toJSON
                       * @memberof syft_proto.execution.v1.NestedTypeWrapper.TypeContainer
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      TypeContainer.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return TypeContainer;
                  })();

                  return NestedTypeWrapper;
              })();

              v1.Protocol = (function() {

                  /**
                   * Properties of a Protocol.
                   * @memberof syft_proto.execution.v1
                   * @interface IProtocol
                   * @property {syft_proto.types.syft.v1.IId|null} [id] Protocol id
                   * @property {string|null} [name] Protocol name
                   * @property {Object.<string,syft_proto.execution.v1.IRole>|null} [roles] Protocol roles
                   * @property {Array.<string>|null} [tags] Protocol tags
                   * @property {string|null} [description] Protocol description
                   */

                  /**
                   * Constructs a new Protocol.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a Protocol.
                   * @implements IProtocol
                   * @constructor
                   * @param {syft_proto.execution.v1.IProtocol=} [properties] Properties to set
                   */
                  function Protocol(properties) {
                      this.roles = {};
                      this.tags = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * Protocol id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                   * @memberof syft_proto.execution.v1.Protocol
                   * @instance
                   */
                  Protocol.prototype.id = null;

                  /**
                   * Protocol name.
                   * @member {string} name
                   * @memberof syft_proto.execution.v1.Protocol
                   * @instance
                   */
                  Protocol.prototype.name = "";

                  /**
                   * Protocol roles.
                   * @member {Object.<string,syft_proto.execution.v1.IRole>} roles
                   * @memberof syft_proto.execution.v1.Protocol
                   * @instance
                   */
                  Protocol.prototype.roles = $util.emptyObject;

                  /**
                   * Protocol tags.
                   * @member {Array.<string>} tags
                   * @memberof syft_proto.execution.v1.Protocol
                   * @instance
                   */
                  Protocol.prototype.tags = $util.emptyArray;

                  /**
                   * Protocol description.
                   * @member {string} description
                   * @memberof syft_proto.execution.v1.Protocol
                   * @instance
                   */
                  Protocol.prototype.description = "";

                  /**
                   * Creates a new Protocol instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.Protocol
                   * @static
                   * @param {syft_proto.execution.v1.IProtocol=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.Protocol} Protocol instance
                   */
                  Protocol.create = function create(properties) {
                      return new Protocol(properties);
                  };

                  /**
                   * Encodes the specified Protocol message. Does not implicitly {@link syft_proto.execution.v1.Protocol.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.Protocol
                   * @static
                   * @param {syft_proto.execution.v1.IProtocol} message Protocol message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Protocol.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.id != null && message.hasOwnProperty("id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.name != null && message.hasOwnProperty("name"))
                          writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                      if (message.roles != null && message.hasOwnProperty("roles"))
                          for (var keys = Object.keys(message.roles), i = 0; i < keys.length; ++i) {
                              writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                              $root.syft_proto.execution.v1.Role.encode(message.roles[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                          }
                      if (message.tags != null && message.tags.length)
                          for (var i = 0; i < message.tags.length; ++i)
                              writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                      if (message.description != null && message.hasOwnProperty("description"))
                          writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                      return writer;
                  };

                  /**
                   * Encodes the specified Protocol message, length delimited. Does not implicitly {@link syft_proto.execution.v1.Protocol.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.Protocol
                   * @static
                   * @param {syft_proto.execution.v1.IProtocol} message Protocol message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Protocol.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a Protocol message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.Protocol
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.Protocol} Protocol
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Protocol.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.Protocol(), key;
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.name = reader.string();
                              break;
                          case 3:
                              reader.skip().pos++;
                              if (message.roles === $util.emptyObject)
                                  message.roles = {};
                              key = reader.string();
                              reader.pos++;
                              message.roles[key] = $root.syft_proto.execution.v1.Role.decode(reader, reader.uint32());
                              break;
                          case 4:
                              if (!(message.tags && message.tags.length))
                                  message.tags = [];
                              message.tags.push(reader.string());
                              break;
                          case 5:
                              message.description = reader.string();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a Protocol message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.Protocol
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.Protocol} Protocol
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Protocol.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a Protocol message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.Protocol
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  Protocol.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.id != null && message.hasOwnProperty("id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                          if (error)
                              return "id." + error;
                      }
                      if (message.name != null && message.hasOwnProperty("name"))
                          if (!$util.isString(message.name))
                              return "name: string expected";
                      if (message.roles != null && message.hasOwnProperty("roles")) {
                          if (!$util.isObject(message.roles))
                              return "roles: object expected";
                          var key = Object.keys(message.roles);
                          for (var i = 0; i < key.length; ++i) {
                              var error = $root.syft_proto.execution.v1.Role.verify(message.roles[key[i]]);
                              if (error)
                                  return "roles." + error;
                          }
                      }
                      if (message.tags != null && message.hasOwnProperty("tags")) {
                          if (!Array.isArray(message.tags))
                              return "tags: array expected";
                          for (var i = 0; i < message.tags.length; ++i)
                              if (!$util.isString(message.tags[i]))
                                  return "tags: string[] expected";
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          if (!$util.isString(message.description))
                              return "description: string expected";
                      return null;
                  };

                  /**
                   * Creates a Protocol message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.Protocol
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.Protocol} Protocol
                   */
                  Protocol.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.Protocol)
                          return object;
                      var message = new $root.syft_proto.execution.v1.Protocol();
                      if (object.id != null) {
                          if (typeof object.id !== "object")
                              throw TypeError(".syft_proto.execution.v1.Protocol.id: object expected");
                          message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                      }
                      if (object.name != null)
                          message.name = String(object.name);
                      if (object.roles) {
                          if (typeof object.roles !== "object")
                              throw TypeError(".syft_proto.execution.v1.Protocol.roles: object expected");
                          message.roles = {};
                          for (var keys = Object.keys(object.roles), i = 0; i < keys.length; ++i) {
                              if (typeof object.roles[keys[i]] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.Protocol.roles: object expected");
                              message.roles[keys[i]] = $root.syft_proto.execution.v1.Role.fromObject(object.roles[keys[i]]);
                          }
                      }
                      if (object.tags) {
                          if (!Array.isArray(object.tags))
                              throw TypeError(".syft_proto.execution.v1.Protocol.tags: array expected");
                          message.tags = [];
                          for (var i = 0; i < object.tags.length; ++i)
                              message.tags[i] = String(object.tags[i]);
                      }
                      if (object.description != null)
                          message.description = String(object.description);
                      return message;
                  };

                  /**
                   * Creates a plain object from a Protocol message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.Protocol
                   * @static
                   * @param {syft_proto.execution.v1.Protocol} message Protocol
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  Protocol.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults)
                          object.tags = [];
                      if (options.objects || options.defaults)
                          object.roles = {};
                      if (options.defaults) {
                          object.id = null;
                          object.name = "";
                          object.description = "";
                      }
                      if (message.id != null && message.hasOwnProperty("id"))
                          object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                      if (message.name != null && message.hasOwnProperty("name"))
                          object.name = message.name;
                      var keys2;
                      if (message.roles && (keys2 = Object.keys(message.roles)).length) {
                          object.roles = {};
                          for (var j = 0; j < keys2.length; ++j)
                              object.roles[keys2[j]] = $root.syft_proto.execution.v1.Role.toObject(message.roles[keys2[j]], options);
                      }
                      if (message.tags && message.tags.length) {
                          object.tags = [];
                          for (var j = 0; j < message.tags.length; ++j)
                              object.tags[j] = message.tags[j];
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          object.description = message.description;
                      return object;
                  };

                  /**
                   * Converts this Protocol to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.Protocol
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  Protocol.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return Protocol;
              })();

              v1.StorageAction = (function() {

                  /**
                   * Properties of a StorageAction.
                   * @memberof syft_proto.execution.v1
                   * @interface IStorageAction
                   * @property {string|null} [command] StorageAction command
                   * @property {syft_proto.types.syft.v1.IId|null} [target_id] StorageAction target_id
                   * @property {syft_proto.generic.pointers.v1.IPointerTensor|null} [target_pointer] StorageAction target_pointer
                   * @property {syft_proto.execution.v1.IPlaceholderId|null} [target_placeholder_id] StorageAction target_placeholder_id
                   * @property {syft_proto.types.torch.v1.ITorchTensor|null} [target_tensor] StorageAction target_tensor
                   * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] StorageAction args
                   * @property {Object.<string,syft_proto.types.syft.v1.IArg>|null} [kwargs] StorageAction kwargs
                   * @property {Array.<syft_proto.types.syft.v1.IId>|null} [return_ids] StorageAction return_ids
                   * @property {Array.<syft_proto.execution.v1.IPlaceholderId>|null} [return_placeholder_ids] StorageAction return_placeholder_ids
                   */

                  /**
                   * Constructs a new StorageAction.
                   * @memberof syft_proto.execution.v1
                   * @classdesc Represents a StorageAction.
                   * @implements IStorageAction
                   * @constructor
                   * @param {syft_proto.execution.v1.IStorageAction=} [properties] Properties to set
                   */
                  function StorageAction(properties) {
                      this.args = [];
                      this.kwargs = {};
                      this.return_ids = [];
                      this.return_placeholder_ids = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * StorageAction command.
                   * @member {string} command
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.command = "";

                  /**
                   * StorageAction target_id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} target_id
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.target_id = null;

                  /**
                   * StorageAction target_pointer.
                   * @member {syft_proto.generic.pointers.v1.IPointerTensor|null|undefined} target_pointer
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.target_pointer = null;

                  /**
                   * StorageAction target_placeholder_id.
                   * @member {syft_proto.execution.v1.IPlaceholderId|null|undefined} target_placeholder_id
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.target_placeholder_id = null;

                  /**
                   * StorageAction target_tensor.
                   * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} target_tensor
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.target_tensor = null;

                  /**
                   * StorageAction args.
                   * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.args = $util.emptyArray;

                  /**
                   * StorageAction kwargs.
                   * @member {Object.<string,syft_proto.types.syft.v1.IArg>} kwargs
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.kwargs = $util.emptyObject;

                  /**
                   * StorageAction return_ids.
                   * @member {Array.<syft_proto.types.syft.v1.IId>} return_ids
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.return_ids = $util.emptyArray;

                  /**
                   * StorageAction return_placeholder_ids.
                   * @member {Array.<syft_proto.execution.v1.IPlaceholderId>} return_placeholder_ids
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  StorageAction.prototype.return_placeholder_ids = $util.emptyArray;

                  // OneOf field names bound to virtual getters and setters
                  var $oneOfFields;

                  /**
                   * StorageAction target.
                   * @member {"target_id"|"target_pointer"|"target_placeholder_id"|"target_tensor"|undefined} target
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   */
                  Object.defineProperty(StorageAction.prototype, "target", {
                      get: $util.oneOfGetter($oneOfFields = ["target_id", "target_pointer", "target_placeholder_id", "target_tensor"]),
                      set: $util.oneOfSetter($oneOfFields)
                  });

                  /**
                   * Creates a new StorageAction instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @static
                   * @param {syft_proto.execution.v1.IStorageAction=} [properties] Properties to set
                   * @returns {syft_proto.execution.v1.StorageAction} StorageAction instance
                   */
                  StorageAction.create = function create(properties) {
                      return new StorageAction(properties);
                  };

                  /**
                   * Encodes the specified StorageAction message. Does not implicitly {@link syft_proto.execution.v1.StorageAction.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @static
                   * @param {syft_proto.execution.v1.IStorageAction} message StorageAction message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  StorageAction.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.command != null && message.hasOwnProperty("command"))
                          writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer"))
                          $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.target_pointer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id"))
                          $root.syft_proto.execution.v1.PlaceholderId.encode(message.target_placeholder_id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor"))
                          $root.syft_proto.types.torch.v1.TorchTensor.encode(message.target_tensor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                      if (message.args != null && message.args.length)
                          for (var i = 0; i < message.args.length; ++i)
                              $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                      if (message.kwargs != null && message.hasOwnProperty("kwargs"))
                          for (var keys = Object.keys(message.kwargs), i = 0; i < keys.length; ++i) {
                              writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                              $root.syft_proto.types.syft.v1.Arg.encode(message.kwargs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                          }
                      if (message.return_ids != null && message.return_ids.length)
                          for (var i = 0; i < message.return_ids.length; ++i)
                              $root.syft_proto.types.syft.v1.Id.encode(message.return_ids[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                      if (message.return_placeholder_ids != null && message.return_placeholder_ids.length)
                          for (var i = 0; i < message.return_placeholder_ids.length; ++i)
                              $root.syft_proto.execution.v1.PlaceholderId.encode(message.return_placeholder_ids[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                      if (message.target_id != null && message.hasOwnProperty("target_id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.target_id, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified StorageAction message, length delimited. Does not implicitly {@link syft_proto.execution.v1.StorageAction.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @static
                   * @param {syft_proto.execution.v1.IStorageAction} message StorageAction message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  StorageAction.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a StorageAction message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.execution.v1.StorageAction} StorageAction
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  StorageAction.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.execution.v1.StorageAction(), key;
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.command = reader.string();
                              break;
                          case 9:
                              message.target_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32());
                              break;
                          case 3:
                              message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32());
                              break;
                          case 4:
                              message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                              break;
                          case 5:
                              if (!(message.args && message.args.length))
                                  message.args = [];
                              message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                              break;
                          case 6:
                              reader.skip().pos++;
                              if (message.kwargs === $util.emptyObject)
                                  message.kwargs = {};
                              key = reader.string();
                              reader.pos++;
                              message.kwargs[key] = $root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32());
                              break;
                          case 7:
                              if (!(message.return_ids && message.return_ids.length))
                                  message.return_ids = [];
                              message.return_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                              break;
                          case 8:
                              if (!(message.return_placeholder_ids && message.return_placeholder_ids.length))
                                  message.return_placeholder_ids = [];
                              message.return_placeholder_ids.push($root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32()));
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a StorageAction message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.execution.v1.StorageAction} StorageAction
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  StorageAction.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a StorageAction message.
                   * @function verify
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  StorageAction.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      var properties = {};
                      if (message.command != null && message.hasOwnProperty("command"))
                          if (!$util.isString(message.command))
                              return "command: string expected";
                      if (message.target_id != null && message.hasOwnProperty("target_id")) {
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.target_id);
                              if (error)
                                  return "target_id." + error;
                          }
                      }
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.target_pointer);
                              if (error)
                                  return "target_pointer." + error;
                          }
                      }
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.target_placeholder_id);
                              if (error)
                                  return "target_placeholder_id." + error;
                          }
                      }
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                          if (properties.target === 1)
                              return "target: multiple values";
                          properties.target = 1;
                          {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.target_tensor);
                              if (error)
                                  return "target_tensor." + error;
                          }
                      }
                      if (message.args != null && message.hasOwnProperty("args")) {
                          if (!Array.isArray(message.args))
                              return "args: array expected";
                          for (var i = 0; i < message.args.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                              if (error)
                                  return "args." + error;
                          }
                      }
                      if (message.kwargs != null && message.hasOwnProperty("kwargs")) {
                          if (!$util.isObject(message.kwargs))
                              return "kwargs: object expected";
                          var key = Object.keys(message.kwargs);
                          for (var i = 0; i < key.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Arg.verify(message.kwargs[key[i]]);
                              if (error)
                                  return "kwargs." + error;
                          }
                      }
                      if (message.return_ids != null && message.hasOwnProperty("return_ids")) {
                          if (!Array.isArray(message.return_ids))
                              return "return_ids: array expected";
                          for (var i = 0; i < message.return_ids.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.return_ids[i]);
                              if (error)
                                  return "return_ids." + error;
                          }
                      }
                      if (message.return_placeholder_ids != null && message.hasOwnProperty("return_placeholder_ids")) {
                          if (!Array.isArray(message.return_placeholder_ids))
                              return "return_placeholder_ids: array expected";
                          for (var i = 0; i < message.return_placeholder_ids.length; ++i) {
                              var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.return_placeholder_ids[i]);
                              if (error)
                                  return "return_placeholder_ids." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a StorageAction message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.execution.v1.StorageAction} StorageAction
                   */
                  StorageAction.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.execution.v1.StorageAction)
                          return object;
                      var message = new $root.syft_proto.execution.v1.StorageAction();
                      if (object.command != null)
                          message.command = String(object.command);
                      if (object.target_id != null) {
                          if (typeof object.target_id !== "object")
                              throw TypeError(".syft_proto.execution.v1.StorageAction.target_id: object expected");
                          message.target_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.target_id);
                      }
                      if (object.target_pointer != null) {
                          if (typeof object.target_pointer !== "object")
                              throw TypeError(".syft_proto.execution.v1.StorageAction.target_pointer: object expected");
                          message.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.target_pointer);
                      }
                      if (object.target_placeholder_id != null) {
                          if (typeof object.target_placeholder_id !== "object")
                              throw TypeError(".syft_proto.execution.v1.StorageAction.target_placeholder_id: object expected");
                          message.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.target_placeholder_id);
                      }
                      if (object.target_tensor != null) {
                          if (typeof object.target_tensor !== "object")
                              throw TypeError(".syft_proto.execution.v1.StorageAction.target_tensor: object expected");
                          message.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.target_tensor);
                      }
                      if (object.args) {
                          if (!Array.isArray(object.args))
                              throw TypeError(".syft_proto.execution.v1.StorageAction.args: array expected");
                          message.args = [];
                          for (var i = 0; i < object.args.length; ++i) {
                              if (typeof object.args[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.StorageAction.args: object expected");
                              message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                          }
                      }
                      if (object.kwargs) {
                          if (typeof object.kwargs !== "object")
                              throw TypeError(".syft_proto.execution.v1.StorageAction.kwargs: object expected");
                          message.kwargs = {};
                          for (var keys = Object.keys(object.kwargs), i = 0; i < keys.length; ++i) {
                              if (typeof object.kwargs[keys[i]] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.StorageAction.kwargs: object expected");
                              message.kwargs[keys[i]] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.kwargs[keys[i]]);
                          }
                      }
                      if (object.return_ids) {
                          if (!Array.isArray(object.return_ids))
                              throw TypeError(".syft_proto.execution.v1.StorageAction.return_ids: array expected");
                          message.return_ids = [];
                          for (var i = 0; i < object.return_ids.length; ++i) {
                              if (typeof object.return_ids[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.StorageAction.return_ids: object expected");
                              message.return_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.return_ids[i]);
                          }
                      }
                      if (object.return_placeholder_ids) {
                          if (!Array.isArray(object.return_placeholder_ids))
                              throw TypeError(".syft_proto.execution.v1.StorageAction.return_placeholder_ids: array expected");
                          message.return_placeholder_ids = [];
                          for (var i = 0; i < object.return_placeholder_ids.length; ++i) {
                              if (typeof object.return_placeholder_ids[i] !== "object")
                                  throw TypeError(".syft_proto.execution.v1.StorageAction.return_placeholder_ids: object expected");
                              message.return_placeholder_ids[i] = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.return_placeholder_ids[i]);
                          }
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a StorageAction message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @static
                   * @param {syft_proto.execution.v1.StorageAction} message StorageAction
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  StorageAction.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults) {
                          object.args = [];
                          object.return_ids = [];
                          object.return_placeholder_ids = [];
                      }
                      if (options.objects || options.defaults)
                          object.kwargs = {};
                      if (options.defaults)
                          object.command = "";
                      if (message.command != null && message.hasOwnProperty("command"))
                          object.command = message.command;
                      if (message.target_pointer != null && message.hasOwnProperty("target_pointer")) {
                          object.target_pointer = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.target_pointer, options);
                          if (options.oneofs)
                              object.target = "target_pointer";
                      }
                      if (message.target_placeholder_id != null && message.hasOwnProperty("target_placeholder_id")) {
                          object.target_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.target_placeholder_id, options);
                          if (options.oneofs)
                              object.target = "target_placeholder_id";
                      }
                      if (message.target_tensor != null && message.hasOwnProperty("target_tensor")) {
                          object.target_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.target_tensor, options);
                          if (options.oneofs)
                              object.target = "target_tensor";
                      }
                      if (message.args && message.args.length) {
                          object.args = [];
                          for (var j = 0; j < message.args.length; ++j)
                              object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                      }
                      var keys2;
                      if (message.kwargs && (keys2 = Object.keys(message.kwargs)).length) {
                          object.kwargs = {};
                          for (var j = 0; j < keys2.length; ++j)
                              object.kwargs[keys2[j]] = $root.syft_proto.types.syft.v1.Arg.toObject(message.kwargs[keys2[j]], options);
                      }
                      if (message.return_ids && message.return_ids.length) {
                          object.return_ids = [];
                          for (var j = 0; j < message.return_ids.length; ++j)
                              object.return_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.return_ids[j], options);
                      }
                      if (message.return_placeholder_ids && message.return_placeholder_ids.length) {
                          object.return_placeholder_ids = [];
                          for (var j = 0; j < message.return_placeholder_ids.length; ++j)
                              object.return_placeholder_ids[j] = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.return_placeholder_ids[j], options);
                      }
                      if (message.target_id != null && message.hasOwnProperty("target_id")) {
                          object.target_id = $root.syft_proto.types.syft.v1.Id.toObject(message.target_id, options);
                          if (options.oneofs)
                              object.target = "target_id";
                      }
                      return object;
                  };

                  /**
                   * Converts this StorageAction to JSON.
                   * @function toJSON
                   * @memberof syft_proto.execution.v1.StorageAction
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  StorageAction.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return StorageAction;
              })();

              return v1;
          })();

          return execution;
      })();

      syft_proto.types = (function() {

          /**
           * Namespace types.
           * @memberof syft_proto
           * @namespace
           */
          var types = {};

          types.syft = (function() {

              /**
               * Namespace syft.
               * @memberof syft_proto.types
               * @namespace
               */
              var syft = {};

              syft.v1 = (function() {

                  /**
                   * Namespace v1.
                   * @memberof syft_proto.types.syft
                   * @namespace
                   */
                  var v1 = {};

                  v1.Id = (function() {

                      /**
                       * Properties of an Id.
                       * @memberof syft_proto.types.syft.v1
                       * @interface IId
                       * @property {number|Long|null} [id_int] Id id_int
                       * @property {string|null} [id_str] Id id_str
                       */

                      /**
                       * Constructs a new Id.
                       * @memberof syft_proto.types.syft.v1
                       * @classdesc Represents an Id.
                       * @implements IId
                       * @constructor
                       * @param {syft_proto.types.syft.v1.IId=} [properties] Properties to set
                       */
                      function Id(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * Id id_int.
                       * @member {number|Long} id_int
                       * @memberof syft_proto.types.syft.v1.Id
                       * @instance
                       */
                      Id.prototype.id_int = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                      /**
                       * Id id_str.
                       * @member {string} id_str
                       * @memberof syft_proto.types.syft.v1.Id
                       * @instance
                       */
                      Id.prototype.id_str = "";

                      // OneOf field names bound to virtual getters and setters
                      var $oneOfFields;

                      /**
                       * Id id.
                       * @member {"id_int"|"id_str"|undefined} id
                       * @memberof syft_proto.types.syft.v1.Id
                       * @instance
                       */
                      Object.defineProperty(Id.prototype, "id", {
                          get: $util.oneOfGetter($oneOfFields = ["id_int", "id_str"]),
                          set: $util.oneOfSetter($oneOfFields)
                      });

                      /**
                       * Creates a new Id instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.syft.v1.Id
                       * @static
                       * @param {syft_proto.types.syft.v1.IId=} [properties] Properties to set
                       * @returns {syft_proto.types.syft.v1.Id} Id instance
                       */
                      Id.create = function create(properties) {
                          return new Id(properties);
                      };

                      /**
                       * Encodes the specified Id message. Does not implicitly {@link syft_proto.types.syft.v1.Id.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.syft.v1.Id
                       * @static
                       * @param {syft_proto.types.syft.v1.IId} message Id message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Id.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.id_int != null && message.hasOwnProperty("id_int"))
                              writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id_int);
                          if (message.id_str != null && message.hasOwnProperty("id_str"))
                              writer.uint32(/* id 2, wireType 2 =*/18).string(message.id_str);
                          return writer;
                      };

                      /**
                       * Encodes the specified Id message, length delimited. Does not implicitly {@link syft_proto.types.syft.v1.Id.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.syft.v1.Id
                       * @static
                       * @param {syft_proto.types.syft.v1.IId} message Id message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Id.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes an Id message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.syft.v1.Id
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.syft.v1.Id} Id
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Id.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.syft.v1.Id();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.id_int = reader.int64();
                                  break;
                              case 2:
                                  message.id_str = reader.string();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes an Id message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.syft.v1.Id
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.syft.v1.Id} Id
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Id.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies an Id message.
                       * @function verify
                       * @memberof syft_proto.types.syft.v1.Id
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      Id.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          var properties = {};
                          if (message.id_int != null && message.hasOwnProperty("id_int")) {
                              properties.id = 1;
                              if (!$util.isInteger(message.id_int) && !(message.id_int && $util.isInteger(message.id_int.low) && $util.isInteger(message.id_int.high)))
                                  return "id_int: integer|Long expected";
                          }
                          if (message.id_str != null && message.hasOwnProperty("id_str")) {
                              if (properties.id === 1)
                                  return "id: multiple values";
                              properties.id = 1;
                              if (!$util.isString(message.id_str))
                                  return "id_str: string expected";
                          }
                          return null;
                      };

                      /**
                       * Creates an Id message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.syft.v1.Id
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.syft.v1.Id} Id
                       */
                      Id.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.syft.v1.Id)
                              return object;
                          var message = new $root.syft_proto.types.syft.v1.Id();
                          if (object.id_int != null)
                              if ($util.Long)
                                  (message.id_int = $util.Long.fromValue(object.id_int)).unsigned = false;
                              else if (typeof object.id_int === "string")
                                  message.id_int = parseInt(object.id_int, 10);
                              else if (typeof object.id_int === "number")
                                  message.id_int = object.id_int;
                              else if (typeof object.id_int === "object")
                                  message.id_int = new $util.LongBits(object.id_int.low >>> 0, object.id_int.high >>> 0).toNumber();
                          if (object.id_str != null)
                              message.id_str = String(object.id_str);
                          return message;
                      };

                      /**
                       * Creates a plain object from an Id message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.syft.v1.Id
                       * @static
                       * @param {syft_proto.types.syft.v1.Id} message Id
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      Id.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (message.id_int != null && message.hasOwnProperty("id_int")) {
                              if (typeof message.id_int === "number")
                                  object.id_int = options.longs === String ? String(message.id_int) : message.id_int;
                              else
                                  object.id_int = options.longs === String ? $util.Long.prototype.toString.call(message.id_int) : options.longs === Number ? new $util.LongBits(message.id_int.low >>> 0, message.id_int.high >>> 0).toNumber() : message.id_int;
                              if (options.oneofs)
                                  object.id = "id_int";
                          }
                          if (message.id_str != null && message.hasOwnProperty("id_str")) {
                              object.id_str = message.id_str;
                              if (options.oneofs)
                                  object.id = "id_str";
                          }
                          return object;
                      };

                      /**
                       * Converts this Id to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.syft.v1.Id
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      Id.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return Id;
                  })();

                  v1.Shape = (function() {

                      /**
                       * Properties of a Shape.
                       * @memberof syft_proto.types.syft.v1
                       * @interface IShape
                       * @property {Array.<number>|null} [dims] Shape dims
                       */

                      /**
                       * Constructs a new Shape.
                       * @memberof syft_proto.types.syft.v1
                       * @classdesc Represents a Shape.
                       * @implements IShape
                       * @constructor
                       * @param {syft_proto.types.syft.v1.IShape=} [properties] Properties to set
                       */
                      function Shape(properties) {
                          this.dims = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * Shape dims.
                       * @member {Array.<number>} dims
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @instance
                       */
                      Shape.prototype.dims = $util.emptyArray;

                      /**
                       * Creates a new Shape instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @static
                       * @param {syft_proto.types.syft.v1.IShape=} [properties] Properties to set
                       * @returns {syft_proto.types.syft.v1.Shape} Shape instance
                       */
                      Shape.create = function create(properties) {
                          return new Shape(properties);
                      };

                      /**
                       * Encodes the specified Shape message. Does not implicitly {@link syft_proto.types.syft.v1.Shape.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @static
                       * @param {syft_proto.types.syft.v1.IShape} message Shape message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Shape.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.dims != null && message.dims.length) {
                              writer.uint32(/* id 1, wireType 2 =*/10).fork();
                              for (var i = 0; i < message.dims.length; ++i)
                                  writer.int32(message.dims[i]);
                              writer.ldelim();
                          }
                          return writer;
                      };

                      /**
                       * Encodes the specified Shape message, length delimited. Does not implicitly {@link syft_proto.types.syft.v1.Shape.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @static
                       * @param {syft_proto.types.syft.v1.IShape} message Shape message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Shape.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a Shape message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.syft.v1.Shape} Shape
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Shape.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.syft.v1.Shape();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  if (!(message.dims && message.dims.length))
                                      message.dims = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.dims.push(reader.int32());
                                  } else
                                      message.dims.push(reader.int32());
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a Shape message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.syft.v1.Shape} Shape
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Shape.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a Shape message.
                       * @function verify
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      Shape.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.dims != null && message.hasOwnProperty("dims")) {
                              if (!Array.isArray(message.dims))
                                  return "dims: array expected";
                              for (var i = 0; i < message.dims.length; ++i)
                                  if (!$util.isInteger(message.dims[i]))
                                      return "dims: integer[] expected";
                          }
                          return null;
                      };

                      /**
                       * Creates a Shape message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.syft.v1.Shape} Shape
                       */
                      Shape.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.syft.v1.Shape)
                              return object;
                          var message = new $root.syft_proto.types.syft.v1.Shape();
                          if (object.dims) {
                              if (!Array.isArray(object.dims))
                                  throw TypeError(".syft_proto.types.syft.v1.Shape.dims: array expected");
                              message.dims = [];
                              for (var i = 0; i < object.dims.length; ++i)
                                  message.dims[i] = object.dims[i] | 0;
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a Shape message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @static
                       * @param {syft_proto.types.syft.v1.Shape} message Shape
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      Shape.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults)
                              object.dims = [];
                          if (message.dims && message.dims.length) {
                              object.dims = [];
                              for (var j = 0; j < message.dims.length; ++j)
                                  object.dims[j] = message.dims[j];
                          }
                          return object;
                      };

                      /**
                       * Converts this Shape to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.syft.v1.Shape
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      Shape.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return Shape;
                  })();

                  v1.Arg = (function() {

                      /**
                       * Properties of an Arg.
                       * @memberof syft_proto.types.syft.v1
                       * @interface IArg
                       * @property {boolean|null} [arg_bool] Arg arg_bool
                       * @property {number|Long|null} [arg_int] Arg arg_int
                       * @property {number|null} [arg_float] Arg arg_float
                       * @property {string|null} [arg_str] Arg arg_str
                       * @property {syft_proto.types.syft.v1.IShape|null} [arg_shape] Arg arg_shape
                       * @property {syft_proto.types.torch.v1.ITorchTensor|null} [arg_tensor] Arg arg_tensor
                       * @property {syft_proto.types.torch.v1.IParameter|null} [arg_torch_param] Arg arg_torch_param
                       * @property {syft_proto.generic.pointers.v1.IPointerTensor|null} [arg_pointer_tensor] Arg arg_pointer_tensor
                       * @property {syft_proto.execution.v1.IPlaceholder|null} [arg_placeholder] Arg arg_placeholder
                       * @property {syft_proto.execution.v1.IPlaceholderId|null} [arg_placeholder_id] Arg arg_placeholder_id
                       * @property {syft_proto.types.syft.v1.IArgList|null} [arg_list] Arg arg_list
                       */

                      /**
                       * Constructs a new Arg.
                       * @memberof syft_proto.types.syft.v1
                       * @classdesc Represents an Arg.
                       * @implements IArg
                       * @constructor
                       * @param {syft_proto.types.syft.v1.IArg=} [properties] Properties to set
                       */
                      function Arg(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * Arg arg_bool.
                       * @member {boolean} arg_bool
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_bool = false;

                      /**
                       * Arg arg_int.
                       * @member {number|Long} arg_int
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_int = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                      /**
                       * Arg arg_float.
                       * @member {number} arg_float
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_float = 0;

                      /**
                       * Arg arg_str.
                       * @member {string} arg_str
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_str = "";

                      /**
                       * Arg arg_shape.
                       * @member {syft_proto.types.syft.v1.IShape|null|undefined} arg_shape
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_shape = null;

                      /**
                       * Arg arg_tensor.
                       * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} arg_tensor
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_tensor = null;

                      /**
                       * Arg arg_torch_param.
                       * @member {syft_proto.types.torch.v1.IParameter|null|undefined} arg_torch_param
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_torch_param = null;

                      /**
                       * Arg arg_pointer_tensor.
                       * @member {syft_proto.generic.pointers.v1.IPointerTensor|null|undefined} arg_pointer_tensor
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_pointer_tensor = null;

                      /**
                       * Arg arg_placeholder.
                       * @member {syft_proto.execution.v1.IPlaceholder|null|undefined} arg_placeholder
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_placeholder = null;

                      /**
                       * Arg arg_placeholder_id.
                       * @member {syft_proto.execution.v1.IPlaceholderId|null|undefined} arg_placeholder_id
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_placeholder_id = null;

                      /**
                       * Arg arg_list.
                       * @member {syft_proto.types.syft.v1.IArgList|null|undefined} arg_list
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Arg.prototype.arg_list = null;

                      // OneOf field names bound to virtual getters and setters
                      var $oneOfFields;

                      /**
                       * Arg arg.
                       * @member {"arg_bool"|"arg_int"|"arg_float"|"arg_str"|"arg_shape"|"arg_tensor"|"arg_torch_param"|"arg_pointer_tensor"|"arg_placeholder"|"arg_placeholder_id"|"arg_list"|undefined} arg
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       */
                      Object.defineProperty(Arg.prototype, "arg", {
                          get: $util.oneOfGetter($oneOfFields = ["arg_bool", "arg_int", "arg_float", "arg_str", "arg_shape", "arg_tensor", "arg_torch_param", "arg_pointer_tensor", "arg_placeholder", "arg_placeholder_id", "arg_list"]),
                          set: $util.oneOfSetter($oneOfFields)
                      });

                      /**
                       * Creates a new Arg instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @static
                       * @param {syft_proto.types.syft.v1.IArg=} [properties] Properties to set
                       * @returns {syft_proto.types.syft.v1.Arg} Arg instance
                       */
                      Arg.create = function create(properties) {
                          return new Arg(properties);
                      };

                      /**
                       * Encodes the specified Arg message. Does not implicitly {@link syft_proto.types.syft.v1.Arg.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @static
                       * @param {syft_proto.types.syft.v1.IArg} message Arg message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Arg.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.arg_bool != null && message.hasOwnProperty("arg_bool"))
                              writer.uint32(/* id 1, wireType 0 =*/8).bool(message.arg_bool);
                          if (message.arg_int != null && message.hasOwnProperty("arg_int"))
                              writer.uint32(/* id 2, wireType 0 =*/16).int64(message.arg_int);
                          if (message.arg_float != null && message.hasOwnProperty("arg_float"))
                              writer.uint32(/* id 3, wireType 5 =*/29).float(message.arg_float);
                          if (message.arg_str != null && message.hasOwnProperty("arg_str"))
                              writer.uint32(/* id 4, wireType 2 =*/34).string(message.arg_str);
                          if (message.arg_shape != null && message.hasOwnProperty("arg_shape"))
                              $root.syft_proto.types.syft.v1.Shape.encode(message.arg_shape, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                          if (message.arg_tensor != null && message.hasOwnProperty("arg_tensor"))
                              $root.syft_proto.types.torch.v1.TorchTensor.encode(message.arg_tensor, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                          if (message.arg_torch_param != null && message.hasOwnProperty("arg_torch_param"))
                              $root.syft_proto.types.torch.v1.Parameter.encode(message.arg_torch_param, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                          if (message.arg_pointer_tensor != null && message.hasOwnProperty("arg_pointer_tensor"))
                              $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.arg_pointer_tensor, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                          if (message.arg_placeholder != null && message.hasOwnProperty("arg_placeholder"))
                              $root.syft_proto.execution.v1.Placeholder.encode(message.arg_placeholder, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                          if (message.arg_placeholder_id != null && message.hasOwnProperty("arg_placeholder_id"))
                              $root.syft_proto.execution.v1.PlaceholderId.encode(message.arg_placeholder_id, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                          if (message.arg_list != null && message.hasOwnProperty("arg_list"))
                              $root.syft_proto.types.syft.v1.ArgList.encode(message.arg_list, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                          return writer;
                      };

                      /**
                       * Encodes the specified Arg message, length delimited. Does not implicitly {@link syft_proto.types.syft.v1.Arg.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @static
                       * @param {syft_proto.types.syft.v1.IArg} message Arg message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Arg.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes an Arg message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.syft.v1.Arg} Arg
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Arg.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.syft.v1.Arg();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.arg_bool = reader.bool();
                                  break;
                              case 2:
                                  message.arg_int = reader.int64();
                                  break;
                              case 3:
                                  message.arg_float = reader.float();
                                  break;
                              case 4:
                                  message.arg_str = reader.string();
                                  break;
                              case 5:
                                  message.arg_shape = $root.syft_proto.types.syft.v1.Shape.decode(reader, reader.uint32());
                                  break;
                              case 6:
                                  message.arg_tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                  break;
                              case 7:
                                  message.arg_torch_param = $root.syft_proto.types.torch.v1.Parameter.decode(reader, reader.uint32());
                                  break;
                              case 8:
                                  message.arg_pointer_tensor = $root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32());
                                  break;
                              case 9:
                                  message.arg_placeholder = $root.syft_proto.execution.v1.Placeholder.decode(reader, reader.uint32());
                                  break;
                              case 10:
                                  message.arg_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.decode(reader, reader.uint32());
                                  break;
                              case 11:
                                  message.arg_list = $root.syft_proto.types.syft.v1.ArgList.decode(reader, reader.uint32());
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes an Arg message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.syft.v1.Arg} Arg
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Arg.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies an Arg message.
                       * @function verify
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      Arg.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          var properties = {};
                          if (message.arg_bool != null && message.hasOwnProperty("arg_bool")) {
                              properties.arg = 1;
                              if (typeof message.arg_bool !== "boolean")
                                  return "arg_bool: boolean expected";
                          }
                          if (message.arg_int != null && message.hasOwnProperty("arg_int")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              if (!$util.isInteger(message.arg_int) && !(message.arg_int && $util.isInteger(message.arg_int.low) && $util.isInteger(message.arg_int.high)))
                                  return "arg_int: integer|Long expected";
                          }
                          if (message.arg_float != null && message.hasOwnProperty("arg_float")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              if (typeof message.arg_float !== "number")
                                  return "arg_float: number expected";
                          }
                          if (message.arg_str != null && message.hasOwnProperty("arg_str")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              if (!$util.isString(message.arg_str))
                                  return "arg_str: string expected";
                          }
                          if (message.arg_shape != null && message.hasOwnProperty("arg_shape")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              {
                                  var error = $root.syft_proto.types.syft.v1.Shape.verify(message.arg_shape);
                                  if (error)
                                      return "arg_shape." + error;
                              }
                          }
                          if (message.arg_tensor != null && message.hasOwnProperty("arg_tensor")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              {
                                  var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.arg_tensor);
                                  if (error)
                                      return "arg_tensor." + error;
                              }
                          }
                          if (message.arg_torch_param != null && message.hasOwnProperty("arg_torch_param")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              {
                                  var error = $root.syft_proto.types.torch.v1.Parameter.verify(message.arg_torch_param);
                                  if (error)
                                      return "arg_torch_param." + error;
                              }
                          }
                          if (message.arg_pointer_tensor != null && message.hasOwnProperty("arg_pointer_tensor")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              {
                                  var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.arg_pointer_tensor);
                                  if (error)
                                      return "arg_pointer_tensor." + error;
                              }
                          }
                          if (message.arg_placeholder != null && message.hasOwnProperty("arg_placeholder")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              {
                                  var error = $root.syft_proto.execution.v1.Placeholder.verify(message.arg_placeholder);
                                  if (error)
                                      return "arg_placeholder." + error;
                              }
                          }
                          if (message.arg_placeholder_id != null && message.hasOwnProperty("arg_placeholder_id")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              {
                                  var error = $root.syft_proto.execution.v1.PlaceholderId.verify(message.arg_placeholder_id);
                                  if (error)
                                      return "arg_placeholder_id." + error;
                              }
                          }
                          if (message.arg_list != null && message.hasOwnProperty("arg_list")) {
                              if (properties.arg === 1)
                                  return "arg: multiple values";
                              properties.arg = 1;
                              {
                                  var error = $root.syft_proto.types.syft.v1.ArgList.verify(message.arg_list);
                                  if (error)
                                      return "arg_list." + error;
                              }
                          }
                          return null;
                      };

                      /**
                       * Creates an Arg message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.syft.v1.Arg} Arg
                       */
                      Arg.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.syft.v1.Arg)
                              return object;
                          var message = new $root.syft_proto.types.syft.v1.Arg();
                          if (object.arg_bool != null)
                              message.arg_bool = Boolean(object.arg_bool);
                          if (object.arg_int != null)
                              if ($util.Long)
                                  (message.arg_int = $util.Long.fromValue(object.arg_int)).unsigned = false;
                              else if (typeof object.arg_int === "string")
                                  message.arg_int = parseInt(object.arg_int, 10);
                              else if (typeof object.arg_int === "number")
                                  message.arg_int = object.arg_int;
                              else if (typeof object.arg_int === "object")
                                  message.arg_int = new $util.LongBits(object.arg_int.low >>> 0, object.arg_int.high >>> 0).toNumber();
                          if (object.arg_float != null)
                              message.arg_float = Number(object.arg_float);
                          if (object.arg_str != null)
                              message.arg_str = String(object.arg_str);
                          if (object.arg_shape != null) {
                              if (typeof object.arg_shape !== "object")
                                  throw TypeError(".syft_proto.types.syft.v1.Arg.arg_shape: object expected");
                              message.arg_shape = $root.syft_proto.types.syft.v1.Shape.fromObject(object.arg_shape);
                          }
                          if (object.arg_tensor != null) {
                              if (typeof object.arg_tensor !== "object")
                                  throw TypeError(".syft_proto.types.syft.v1.Arg.arg_tensor: object expected");
                              message.arg_tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.arg_tensor);
                          }
                          if (object.arg_torch_param != null) {
                              if (typeof object.arg_torch_param !== "object")
                                  throw TypeError(".syft_proto.types.syft.v1.Arg.arg_torch_param: object expected");
                              message.arg_torch_param = $root.syft_proto.types.torch.v1.Parameter.fromObject(object.arg_torch_param);
                          }
                          if (object.arg_pointer_tensor != null) {
                              if (typeof object.arg_pointer_tensor !== "object")
                                  throw TypeError(".syft_proto.types.syft.v1.Arg.arg_pointer_tensor: object expected");
                              message.arg_pointer_tensor = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.arg_pointer_tensor);
                          }
                          if (object.arg_placeholder != null) {
                              if (typeof object.arg_placeholder !== "object")
                                  throw TypeError(".syft_proto.types.syft.v1.Arg.arg_placeholder: object expected");
                              message.arg_placeholder = $root.syft_proto.execution.v1.Placeholder.fromObject(object.arg_placeholder);
                          }
                          if (object.arg_placeholder_id != null) {
                              if (typeof object.arg_placeholder_id !== "object")
                                  throw TypeError(".syft_proto.types.syft.v1.Arg.arg_placeholder_id: object expected");
                              message.arg_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.fromObject(object.arg_placeholder_id);
                          }
                          if (object.arg_list != null) {
                              if (typeof object.arg_list !== "object")
                                  throw TypeError(".syft_proto.types.syft.v1.Arg.arg_list: object expected");
                              message.arg_list = $root.syft_proto.types.syft.v1.ArgList.fromObject(object.arg_list);
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from an Arg message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @static
                       * @param {syft_proto.types.syft.v1.Arg} message Arg
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      Arg.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (message.arg_bool != null && message.hasOwnProperty("arg_bool")) {
                              object.arg_bool = message.arg_bool;
                              if (options.oneofs)
                                  object.arg = "arg_bool";
                          }
                          if (message.arg_int != null && message.hasOwnProperty("arg_int")) {
                              if (typeof message.arg_int === "number")
                                  object.arg_int = options.longs === String ? String(message.arg_int) : message.arg_int;
                              else
                                  object.arg_int = options.longs === String ? $util.Long.prototype.toString.call(message.arg_int) : options.longs === Number ? new $util.LongBits(message.arg_int.low >>> 0, message.arg_int.high >>> 0).toNumber() : message.arg_int;
                              if (options.oneofs)
                                  object.arg = "arg_int";
                          }
                          if (message.arg_float != null && message.hasOwnProperty("arg_float")) {
                              object.arg_float = options.json && !isFinite(message.arg_float) ? String(message.arg_float) : message.arg_float;
                              if (options.oneofs)
                                  object.arg = "arg_float";
                          }
                          if (message.arg_str != null && message.hasOwnProperty("arg_str")) {
                              object.arg_str = message.arg_str;
                              if (options.oneofs)
                                  object.arg = "arg_str";
                          }
                          if (message.arg_shape != null && message.hasOwnProperty("arg_shape")) {
                              object.arg_shape = $root.syft_proto.types.syft.v1.Shape.toObject(message.arg_shape, options);
                              if (options.oneofs)
                                  object.arg = "arg_shape";
                          }
                          if (message.arg_tensor != null && message.hasOwnProperty("arg_tensor")) {
                              object.arg_tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.arg_tensor, options);
                              if (options.oneofs)
                                  object.arg = "arg_tensor";
                          }
                          if (message.arg_torch_param != null && message.hasOwnProperty("arg_torch_param")) {
                              object.arg_torch_param = $root.syft_proto.types.torch.v1.Parameter.toObject(message.arg_torch_param, options);
                              if (options.oneofs)
                                  object.arg = "arg_torch_param";
                          }
                          if (message.arg_pointer_tensor != null && message.hasOwnProperty("arg_pointer_tensor")) {
                              object.arg_pointer_tensor = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.arg_pointer_tensor, options);
                              if (options.oneofs)
                                  object.arg = "arg_pointer_tensor";
                          }
                          if (message.arg_placeholder != null && message.hasOwnProperty("arg_placeholder")) {
                              object.arg_placeholder = $root.syft_proto.execution.v1.Placeholder.toObject(message.arg_placeholder, options);
                              if (options.oneofs)
                                  object.arg = "arg_placeholder";
                          }
                          if (message.arg_placeholder_id != null && message.hasOwnProperty("arg_placeholder_id")) {
                              object.arg_placeholder_id = $root.syft_proto.execution.v1.PlaceholderId.toObject(message.arg_placeholder_id, options);
                              if (options.oneofs)
                                  object.arg = "arg_placeholder_id";
                          }
                          if (message.arg_list != null && message.hasOwnProperty("arg_list")) {
                              object.arg_list = $root.syft_proto.types.syft.v1.ArgList.toObject(message.arg_list, options);
                              if (options.oneofs)
                                  object.arg = "arg_list";
                          }
                          return object;
                      };

                      /**
                       * Converts this Arg to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.syft.v1.Arg
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      Arg.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return Arg;
                  })();

                  v1.ArgList = (function() {

                      /**
                       * Properties of an ArgList.
                       * @memberof syft_proto.types.syft.v1
                       * @interface IArgList
                       * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] ArgList args
                       */

                      /**
                       * Constructs a new ArgList.
                       * @memberof syft_proto.types.syft.v1
                       * @classdesc Represents an ArgList.
                       * @implements IArgList
                       * @constructor
                       * @param {syft_proto.types.syft.v1.IArgList=} [properties] Properties to set
                       */
                      function ArgList(properties) {
                          this.args = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * ArgList args.
                       * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @instance
                       */
                      ArgList.prototype.args = $util.emptyArray;

                      /**
                       * Creates a new ArgList instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @static
                       * @param {syft_proto.types.syft.v1.IArgList=} [properties] Properties to set
                       * @returns {syft_proto.types.syft.v1.ArgList} ArgList instance
                       */
                      ArgList.create = function create(properties) {
                          return new ArgList(properties);
                      };

                      /**
                       * Encodes the specified ArgList message. Does not implicitly {@link syft_proto.types.syft.v1.ArgList.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @static
                       * @param {syft_proto.types.syft.v1.IArgList} message ArgList message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      ArgList.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.args != null && message.args.length)
                              for (var i = 0; i < message.args.length; ++i)
                                  $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          return writer;
                      };

                      /**
                       * Encodes the specified ArgList message, length delimited. Does not implicitly {@link syft_proto.types.syft.v1.ArgList.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @static
                       * @param {syft_proto.types.syft.v1.IArgList} message ArgList message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      ArgList.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes an ArgList message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.syft.v1.ArgList} ArgList
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      ArgList.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.syft.v1.ArgList();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  if (!(message.args && message.args.length))
                                      message.args = [];
                                  message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes an ArgList message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.syft.v1.ArgList} ArgList
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      ArgList.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies an ArgList message.
                       * @function verify
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      ArgList.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.args != null && message.hasOwnProperty("args")) {
                              if (!Array.isArray(message.args))
                                  return "args: array expected";
                              for (var i = 0; i < message.args.length; ++i) {
                                  var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                                  if (error)
                                      return "args." + error;
                              }
                          }
                          return null;
                      };

                      /**
                       * Creates an ArgList message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.syft.v1.ArgList} ArgList
                       */
                      ArgList.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.syft.v1.ArgList)
                              return object;
                          var message = new $root.syft_proto.types.syft.v1.ArgList();
                          if (object.args) {
                              if (!Array.isArray(object.args))
                                  throw TypeError(".syft_proto.types.syft.v1.ArgList.args: array expected");
                              message.args = [];
                              for (var i = 0; i < object.args.length; ++i) {
                                  if (typeof object.args[i] !== "object")
                                      throw TypeError(".syft_proto.types.syft.v1.ArgList.args: object expected");
                                  message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                              }
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from an ArgList message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @static
                       * @param {syft_proto.types.syft.v1.ArgList} message ArgList
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      ArgList.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults)
                              object.args = [];
                          if (message.args && message.args.length) {
                              object.args = [];
                              for (var j = 0; j < message.args.length; ++j)
                                  object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                          }
                          return object;
                      };

                      /**
                       * Converts this ArgList to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.syft.v1.ArgList
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      ArgList.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return ArgList;
                  })();

                  return v1;
              })();

              return syft;
          })();

          types.torch = (function() {

              /**
               * Namespace torch.
               * @memberof syft_proto.types
               * @namespace
               */
              var torch = {};

              torch.v1 = (function() {

                  /**
                   * Namespace v1.
                   * @memberof syft_proto.types.torch
                   * @namespace
                   */
                  var v1 = {};

                  v1.TorchTensor = (function() {

                      /**
                       * Properties of a TorchTensor.
                       * @memberof syft_proto.types.torch.v1
                       * @interface ITorchTensor
                       * @property {syft_proto.types.syft.v1.IId|null} [id] TorchTensor id
                       * @property {syft_proto.types.torch.v1.ITensorData|null} [contents_data] TorchTensor contents_data
                       * @property {Uint8Array|null} [contents_bin] TorchTensor contents_bin
                       * @property {syft_proto.types.torch.v1.ITorchTensor|null} [chain] TorchTensor chain
                       * @property {syft_proto.types.torch.v1.ITorchTensor|null} [grad_chain] TorchTensor grad_chain
                       * @property {Array.<string>|null} [tags] TorchTensor tags
                       * @property {string|null} [description] TorchTensor description
                       * @property {syft_proto.types.torch.v1.TorchTensor.Serializer|null} [serializer] TorchTensor serializer
                       */

                      /**
                       * Constructs a new TorchTensor.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a TorchTensor.
                       * @implements ITorchTensor
                       * @constructor
                       * @param {syft_proto.types.torch.v1.ITorchTensor=} [properties] Properties to set
                       */
                      function TorchTensor(properties) {
                          this.tags = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * TorchTensor id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      TorchTensor.prototype.id = null;

                      /**
                       * TorchTensor contents_data.
                       * @member {syft_proto.types.torch.v1.ITensorData|null|undefined} contents_data
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      TorchTensor.prototype.contents_data = null;

                      /**
                       * TorchTensor contents_bin.
                       * @member {Uint8Array} contents_bin
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      TorchTensor.prototype.contents_bin = $util.newBuffer([]);

                      /**
                       * TorchTensor chain.
                       * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} chain
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      TorchTensor.prototype.chain = null;

                      /**
                       * TorchTensor grad_chain.
                       * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} grad_chain
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      TorchTensor.prototype.grad_chain = null;

                      /**
                       * TorchTensor tags.
                       * @member {Array.<string>} tags
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      TorchTensor.prototype.tags = $util.emptyArray;

                      /**
                       * TorchTensor description.
                       * @member {string} description
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      TorchTensor.prototype.description = "";

                      /**
                       * TorchTensor serializer.
                       * @member {syft_proto.types.torch.v1.TorchTensor.Serializer} serializer
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      TorchTensor.prototype.serializer = 0;

                      // OneOf field names bound to virtual getters and setters
                      var $oneOfFields;

                      /**
                       * TorchTensor contents.
                       * @member {"contents_data"|"contents_bin"|undefined} contents
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       */
                      Object.defineProperty(TorchTensor.prototype, "contents", {
                          get: $util.oneOfGetter($oneOfFields = ["contents_data", "contents_bin"]),
                          set: $util.oneOfSetter($oneOfFields)
                      });

                      /**
                       * Creates a new TorchTensor instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @static
                       * @param {syft_proto.types.torch.v1.ITorchTensor=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.TorchTensor} TorchTensor instance
                       */
                      TorchTensor.create = function create(properties) {
                          return new TorchTensor(properties);
                      };

                      /**
                       * Encodes the specified TorchTensor message. Does not implicitly {@link syft_proto.types.torch.v1.TorchTensor.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @static
                       * @param {syft_proto.types.torch.v1.ITorchTensor} message TorchTensor message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TorchTensor.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.id != null && message.hasOwnProperty("id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          if (message.contents_data != null && message.hasOwnProperty("contents_data"))
                              $root.syft_proto.types.torch.v1.TensorData.encode(message.contents_data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                          if (message.contents_bin != null && message.hasOwnProperty("contents_bin"))
                              writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.contents_bin);
                          if (message.chain != null && message.hasOwnProperty("chain"))
                              $root.syft_proto.types.torch.v1.TorchTensor.encode(message.chain, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                          if (message.grad_chain != null && message.hasOwnProperty("grad_chain"))
                              $root.syft_proto.types.torch.v1.TorchTensor.encode(message.grad_chain, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                          if (message.tags != null && message.tags.length)
                              for (var i = 0; i < message.tags.length; ++i)
                                  writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
                          if (message.description != null && message.hasOwnProperty("description"))
                              writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
                          if (message.serializer != null && message.hasOwnProperty("serializer"))
                              writer.uint32(/* id 8, wireType 0 =*/64).int32(message.serializer);
                          return writer;
                      };

                      /**
                       * Encodes the specified TorchTensor message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.TorchTensor.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @static
                       * @param {syft_proto.types.torch.v1.ITorchTensor} message TorchTensor message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TorchTensor.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a TorchTensor message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.TorchTensor} TorchTensor
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TorchTensor.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.TorchTensor();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 2:
                                  message.contents_data = $root.syft_proto.types.torch.v1.TensorData.decode(reader, reader.uint32());
                                  break;
                              case 3:
                                  message.contents_bin = reader.bytes();
                                  break;
                              case 4:
                                  message.chain = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                  break;
                              case 5:
                                  message.grad_chain = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                  break;
                              case 6:
                                  if (!(message.tags && message.tags.length))
                                      message.tags = [];
                                  message.tags.push(reader.string());
                                  break;
                              case 7:
                                  message.description = reader.string();
                                  break;
                              case 8:
                                  message.serializer = reader.int32();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a TorchTensor message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.TorchTensor} TorchTensor
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TorchTensor.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a TorchTensor message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      TorchTensor.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          var properties = {};
                          if (message.id != null && message.hasOwnProperty("id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                              if (error)
                                  return "id." + error;
                          }
                          if (message.contents_data != null && message.hasOwnProperty("contents_data")) {
                              properties.contents = 1;
                              {
                                  var error = $root.syft_proto.types.torch.v1.TensorData.verify(message.contents_data);
                                  if (error)
                                      return "contents_data." + error;
                              }
                          }
                          if (message.contents_bin != null && message.hasOwnProperty("contents_bin")) {
                              if (properties.contents === 1)
                                  return "contents: multiple values";
                              properties.contents = 1;
                              if (!(message.contents_bin && typeof message.contents_bin.length === "number" || $util.isString(message.contents_bin)))
                                  return "contents_bin: buffer expected";
                          }
                          if (message.chain != null && message.hasOwnProperty("chain")) {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.chain);
                              if (error)
                                  return "chain." + error;
                          }
                          if (message.grad_chain != null && message.hasOwnProperty("grad_chain")) {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.grad_chain);
                              if (error)
                                  return "grad_chain." + error;
                          }
                          if (message.tags != null && message.hasOwnProperty("tags")) {
                              if (!Array.isArray(message.tags))
                                  return "tags: array expected";
                              for (var i = 0; i < message.tags.length; ++i)
                                  if (!$util.isString(message.tags[i]))
                                      return "tags: string[] expected";
                          }
                          if (message.description != null && message.hasOwnProperty("description"))
                              if (!$util.isString(message.description))
                                  return "description: string expected";
                          if (message.serializer != null && message.hasOwnProperty("serializer"))
                              switch (message.serializer) {
                              default:
                                  return "serializer: enum value expected";
                              case 0:
                              case 1:
                              case 2:
                              case 3:
                              case 4:
                                  break;
                              }
                          return null;
                      };

                      /**
                       * Creates a TorchTensor message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.TorchTensor} TorchTensor
                       */
                      TorchTensor.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.TorchTensor)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.TorchTensor();
                          if (object.id != null) {
                              if (typeof object.id !== "object")
                                  throw TypeError(".syft_proto.types.torch.v1.TorchTensor.id: object expected");
                              message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                          }
                          if (object.contents_data != null) {
                              if (typeof object.contents_data !== "object")
                                  throw TypeError(".syft_proto.types.torch.v1.TorchTensor.contents_data: object expected");
                              message.contents_data = $root.syft_proto.types.torch.v1.TensorData.fromObject(object.contents_data);
                          }
                          if (object.contents_bin != null)
                              if (typeof object.contents_bin === "string")
                                  $util.base64.decode(object.contents_bin, message.contents_bin = $util.newBuffer($util.base64.length(object.contents_bin)), 0);
                              else if (object.contents_bin.length)
                                  message.contents_bin = object.contents_bin;
                          if (object.chain != null) {
                              if (typeof object.chain !== "object")
                                  throw TypeError(".syft_proto.types.torch.v1.TorchTensor.chain: object expected");
                              message.chain = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.chain);
                          }
                          if (object.grad_chain != null) {
                              if (typeof object.grad_chain !== "object")
                                  throw TypeError(".syft_proto.types.torch.v1.TorchTensor.grad_chain: object expected");
                              message.grad_chain = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.grad_chain);
                          }
                          if (object.tags) {
                              if (!Array.isArray(object.tags))
                                  throw TypeError(".syft_proto.types.torch.v1.TorchTensor.tags: array expected");
                              message.tags = [];
                              for (var i = 0; i < object.tags.length; ++i)
                                  message.tags[i] = String(object.tags[i]);
                          }
                          if (object.description != null)
                              message.description = String(object.description);
                          switch (object.serializer) {
                          case "SERIALIZER_UNSPECIFIED":
                          case 0:
                              message.serializer = 0;
                              break;
                          case "SERIALIZER_TORCH":
                          case 1:
                              message.serializer = 1;
                              break;
                          case "SERIALIZER_NUMPY":
                          case 2:
                              message.serializer = 2;
                              break;
                          case "SERIALIZER_TF":
                          case 3:
                              message.serializer = 3;
                              break;
                          case "SERIALIZER_ALL":
                          case 4:
                              message.serializer = 4;
                              break;
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a TorchTensor message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @static
                       * @param {syft_proto.types.torch.v1.TorchTensor} message TorchTensor
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      TorchTensor.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults)
                              object.tags = [];
                          if (options.defaults) {
                              object.id = null;
                              object.chain = null;
                              object.grad_chain = null;
                              object.description = "";
                              object.serializer = options.enums === String ? "SERIALIZER_UNSPECIFIED" : 0;
                          }
                          if (message.id != null && message.hasOwnProperty("id"))
                              object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                          if (message.contents_data != null && message.hasOwnProperty("contents_data")) {
                              object.contents_data = $root.syft_proto.types.torch.v1.TensorData.toObject(message.contents_data, options);
                              if (options.oneofs)
                                  object.contents = "contents_data";
                          }
                          if (message.contents_bin != null && message.hasOwnProperty("contents_bin")) {
                              object.contents_bin = options.bytes === String ? $util.base64.encode(message.contents_bin, 0, message.contents_bin.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents_bin) : message.contents_bin;
                              if (options.oneofs)
                                  object.contents = "contents_bin";
                          }
                          if (message.chain != null && message.hasOwnProperty("chain"))
                              object.chain = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.chain, options);
                          if (message.grad_chain != null && message.hasOwnProperty("grad_chain"))
                              object.grad_chain = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.grad_chain, options);
                          if (message.tags && message.tags.length) {
                              object.tags = [];
                              for (var j = 0; j < message.tags.length; ++j)
                                  object.tags[j] = message.tags[j];
                          }
                          if (message.description != null && message.hasOwnProperty("description"))
                              object.description = message.description;
                          if (message.serializer != null && message.hasOwnProperty("serializer"))
                              object.serializer = options.enums === String ? $root.syft_proto.types.torch.v1.TorchTensor.Serializer[message.serializer] : message.serializer;
                          return object;
                      };

                      /**
                       * Converts this TorchTensor to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.TorchTensor
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      TorchTensor.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      /**
                       * Serializer enum.
                       * @name syft_proto.types.torch.v1.TorchTensor.Serializer
                       * @enum {string}
                       * @property {number} SERIALIZER_UNSPECIFIED=0 SERIALIZER_UNSPECIFIED value
                       * @property {number} SERIALIZER_TORCH=1 SERIALIZER_TORCH value
                       * @property {number} SERIALIZER_NUMPY=2 SERIALIZER_NUMPY value
                       * @property {number} SERIALIZER_TF=3 SERIALIZER_TF value
                       * @property {number} SERIALIZER_ALL=4 SERIALIZER_ALL value
                       */
                      TorchTensor.Serializer = (function() {
                          var valuesById = {}, values = Object.create(valuesById);
                          values[valuesById[0] = "SERIALIZER_UNSPECIFIED"] = 0;
                          values[valuesById[1] = "SERIALIZER_TORCH"] = 1;
                          values[valuesById[2] = "SERIALIZER_NUMPY"] = 2;
                          values[valuesById[3] = "SERIALIZER_TF"] = 3;
                          values[valuesById[4] = "SERIALIZER_ALL"] = 4;
                          return values;
                      })();

                      return TorchTensor;
                  })();

                  v1.TensorData = (function() {

                      /**
                       * Properties of a TensorData.
                       * @memberof syft_proto.types.torch.v1
                       * @interface ITensorData
                       * @property {syft_proto.types.torch.v1.ISize|null} [shape] TensorData shape
                       * @property {string|null} [dtype] TensorData dtype
                       * @property {boolean|null} [is_quantized] TensorData is_quantized
                       * @property {number|null} [scale] TensorData scale
                       * @property {number|null} [zero_point] TensorData zero_point
                       * @property {Array.<number>|null} [contents_uint8] TensorData contents_uint8
                       * @property {Array.<number>|null} [contents_int8] TensorData contents_int8
                       * @property {Array.<number>|null} [contents_int16] TensorData contents_int16
                       * @property {Array.<number>|null} [contents_int32] TensorData contents_int32
                       * @property {Array.<number|Long>|null} [contents_int64] TensorData contents_int64
                       * @property {Array.<number>|null} [contents_float16] TensorData contents_float16
                       * @property {Array.<number>|null} [contents_float32] TensorData contents_float32
                       * @property {Array.<number>|null} [contents_float64] TensorData contents_float64
                       * @property {Array.<boolean>|null} [contents_bool] TensorData contents_bool
                       * @property {Array.<number>|null} [contents_qint8] TensorData contents_qint8
                       * @property {Array.<number>|null} [contents_quint8] TensorData contents_quint8
                       * @property {Array.<number>|null} [contents_qint32] TensorData contents_qint32
                       * @property {Array.<number>|null} [contents_bfloat16] TensorData contents_bfloat16
                       */

                      /**
                       * Constructs a new TensorData.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a TensorData.
                       * @implements ITensorData
                       * @constructor
                       * @param {syft_proto.types.torch.v1.ITensorData=} [properties] Properties to set
                       */
                      function TensorData(properties) {
                          this.contents_uint8 = [];
                          this.contents_int8 = [];
                          this.contents_int16 = [];
                          this.contents_int32 = [];
                          this.contents_int64 = [];
                          this.contents_float16 = [];
                          this.contents_float32 = [];
                          this.contents_float64 = [];
                          this.contents_bool = [];
                          this.contents_qint8 = [];
                          this.contents_quint8 = [];
                          this.contents_qint32 = [];
                          this.contents_bfloat16 = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * TensorData shape.
                       * @member {syft_proto.types.torch.v1.ISize|null|undefined} shape
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.shape = null;

                      /**
                       * TensorData dtype.
                       * @member {string} dtype
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.dtype = "";

                      /**
                       * TensorData is_quantized.
                       * @member {boolean} is_quantized
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.is_quantized = false;

                      /**
                       * TensorData scale.
                       * @member {number} scale
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.scale = 0;

                      /**
                       * TensorData zero_point.
                       * @member {number} zero_point
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.zero_point = 0;

                      /**
                       * TensorData contents_uint8.
                       * @member {Array.<number>} contents_uint8
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_uint8 = $util.emptyArray;

                      /**
                       * TensorData contents_int8.
                       * @member {Array.<number>} contents_int8
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_int8 = $util.emptyArray;

                      /**
                       * TensorData contents_int16.
                       * @member {Array.<number>} contents_int16
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_int16 = $util.emptyArray;

                      /**
                       * TensorData contents_int32.
                       * @member {Array.<number>} contents_int32
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_int32 = $util.emptyArray;

                      /**
                       * TensorData contents_int64.
                       * @member {Array.<number|Long>} contents_int64
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_int64 = $util.emptyArray;

                      /**
                       * TensorData contents_float16.
                       * @member {Array.<number>} contents_float16
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_float16 = $util.emptyArray;

                      /**
                       * TensorData contents_float32.
                       * @member {Array.<number>} contents_float32
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_float32 = $util.emptyArray;

                      /**
                       * TensorData contents_float64.
                       * @member {Array.<number>} contents_float64
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_float64 = $util.emptyArray;

                      /**
                       * TensorData contents_bool.
                       * @member {Array.<boolean>} contents_bool
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_bool = $util.emptyArray;

                      /**
                       * TensorData contents_qint8.
                       * @member {Array.<number>} contents_qint8
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_qint8 = $util.emptyArray;

                      /**
                       * TensorData contents_quint8.
                       * @member {Array.<number>} contents_quint8
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_quint8 = $util.emptyArray;

                      /**
                       * TensorData contents_qint32.
                       * @member {Array.<number>} contents_qint32
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_qint32 = $util.emptyArray;

                      /**
                       * TensorData contents_bfloat16.
                       * @member {Array.<number>} contents_bfloat16
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       */
                      TensorData.prototype.contents_bfloat16 = $util.emptyArray;

                      /**
                       * Creates a new TensorData instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @static
                       * @param {syft_proto.types.torch.v1.ITensorData=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.TensorData} TensorData instance
                       */
                      TensorData.create = function create(properties) {
                          return new TensorData(properties);
                      };

                      /**
                       * Encodes the specified TensorData message. Does not implicitly {@link syft_proto.types.torch.v1.TensorData.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @static
                       * @param {syft_proto.types.torch.v1.ITensorData} message TensorData message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TensorData.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.shape != null && message.hasOwnProperty("shape"))
                              $root.syft_proto.types.torch.v1.Size.encode(message.shape, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          if (message.dtype != null && message.hasOwnProperty("dtype"))
                              writer.uint32(/* id 2, wireType 2 =*/18).string(message.dtype);
                          if (message.is_quantized != null && message.hasOwnProperty("is_quantized"))
                              writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_quantized);
                          if (message.scale != null && message.hasOwnProperty("scale"))
                              writer.uint32(/* id 4, wireType 5 =*/37).float(message.scale);
                          if (message.zero_point != null && message.hasOwnProperty("zero_point"))
                              writer.uint32(/* id 5, wireType 0 =*/40).int32(message.zero_point);
                          if (message.contents_uint8 != null && message.contents_uint8.length) {
                              writer.uint32(/* id 16, wireType 2 =*/130).fork();
                              for (var i = 0; i < message.contents_uint8.length; ++i)
                                  writer.uint32(message.contents_uint8[i]);
                              writer.ldelim();
                          }
                          if (message.contents_int8 != null && message.contents_int8.length) {
                              writer.uint32(/* id 17, wireType 2 =*/138).fork();
                              for (var i = 0; i < message.contents_int8.length; ++i)
                                  writer.int32(message.contents_int8[i]);
                              writer.ldelim();
                          }
                          if (message.contents_int16 != null && message.contents_int16.length) {
                              writer.uint32(/* id 18, wireType 2 =*/146).fork();
                              for (var i = 0; i < message.contents_int16.length; ++i)
                                  writer.int32(message.contents_int16[i]);
                              writer.ldelim();
                          }
                          if (message.contents_int32 != null && message.contents_int32.length) {
                              writer.uint32(/* id 19, wireType 2 =*/154).fork();
                              for (var i = 0; i < message.contents_int32.length; ++i)
                                  writer.int32(message.contents_int32[i]);
                              writer.ldelim();
                          }
                          if (message.contents_int64 != null && message.contents_int64.length) {
                              writer.uint32(/* id 20, wireType 2 =*/162).fork();
                              for (var i = 0; i < message.contents_int64.length; ++i)
                                  writer.int64(message.contents_int64[i]);
                              writer.ldelim();
                          }
                          if (message.contents_float16 != null && message.contents_float16.length) {
                              writer.uint32(/* id 21, wireType 2 =*/170).fork();
                              for (var i = 0; i < message.contents_float16.length; ++i)
                                  writer.float(message.contents_float16[i]);
                              writer.ldelim();
                          }
                          if (message.contents_float32 != null && message.contents_float32.length) {
                              writer.uint32(/* id 22, wireType 2 =*/178).fork();
                              for (var i = 0; i < message.contents_float32.length; ++i)
                                  writer.float(message.contents_float32[i]);
                              writer.ldelim();
                          }
                          if (message.contents_float64 != null && message.contents_float64.length) {
                              writer.uint32(/* id 23, wireType 2 =*/186).fork();
                              for (var i = 0; i < message.contents_float64.length; ++i)
                                  writer.double(message.contents_float64[i]);
                              writer.ldelim();
                          }
                          if (message.contents_bool != null && message.contents_bool.length) {
                              writer.uint32(/* id 24, wireType 2 =*/194).fork();
                              for (var i = 0; i < message.contents_bool.length; ++i)
                                  writer.bool(message.contents_bool[i]);
                              writer.ldelim();
                          }
                          if (message.contents_qint8 != null && message.contents_qint8.length) {
                              writer.uint32(/* id 25, wireType 2 =*/202).fork();
                              for (var i = 0; i < message.contents_qint8.length; ++i)
                                  writer.sint32(message.contents_qint8[i]);
                              writer.ldelim();
                          }
                          if (message.contents_quint8 != null && message.contents_quint8.length) {
                              writer.uint32(/* id 26, wireType 2 =*/210).fork();
                              for (var i = 0; i < message.contents_quint8.length; ++i)
                                  writer.uint32(message.contents_quint8[i]);
                              writer.ldelim();
                          }
                          if (message.contents_qint32 != null && message.contents_qint32.length) {
                              writer.uint32(/* id 27, wireType 2 =*/218).fork();
                              for (var i = 0; i < message.contents_qint32.length; ++i)
                                  writer.sint32(message.contents_qint32[i]);
                              writer.ldelim();
                          }
                          if (message.contents_bfloat16 != null && message.contents_bfloat16.length) {
                              writer.uint32(/* id 28, wireType 2 =*/226).fork();
                              for (var i = 0; i < message.contents_bfloat16.length; ++i)
                                  writer.float(message.contents_bfloat16[i]);
                              writer.ldelim();
                          }
                          return writer;
                      };

                      /**
                       * Encodes the specified TensorData message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.TensorData.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @static
                       * @param {syft_proto.types.torch.v1.ITensorData} message TensorData message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TensorData.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a TensorData message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.TensorData} TensorData
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TensorData.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.TensorData();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.shape = $root.syft_proto.types.torch.v1.Size.decode(reader, reader.uint32());
                                  break;
                              case 2:
                                  message.dtype = reader.string();
                                  break;
                              case 3:
                                  message.is_quantized = reader.bool();
                                  break;
                              case 4:
                                  message.scale = reader.float();
                                  break;
                              case 5:
                                  message.zero_point = reader.int32();
                                  break;
                              case 16:
                                  if (!(message.contents_uint8 && message.contents_uint8.length))
                                      message.contents_uint8 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_uint8.push(reader.uint32());
                                  } else
                                      message.contents_uint8.push(reader.uint32());
                                  break;
                              case 17:
                                  if (!(message.contents_int8 && message.contents_int8.length))
                                      message.contents_int8 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_int8.push(reader.int32());
                                  } else
                                      message.contents_int8.push(reader.int32());
                                  break;
                              case 18:
                                  if (!(message.contents_int16 && message.contents_int16.length))
                                      message.contents_int16 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_int16.push(reader.int32());
                                  } else
                                      message.contents_int16.push(reader.int32());
                                  break;
                              case 19:
                                  if (!(message.contents_int32 && message.contents_int32.length))
                                      message.contents_int32 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_int32.push(reader.int32());
                                  } else
                                      message.contents_int32.push(reader.int32());
                                  break;
                              case 20:
                                  if (!(message.contents_int64 && message.contents_int64.length))
                                      message.contents_int64 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_int64.push(reader.int64());
                                  } else
                                      message.contents_int64.push(reader.int64());
                                  break;
                              case 21:
                                  if (!(message.contents_float16 && message.contents_float16.length))
                                      message.contents_float16 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_float16.push(reader.float());
                                  } else
                                      message.contents_float16.push(reader.float());
                                  break;
                              case 22:
                                  if (!(message.contents_float32 && message.contents_float32.length))
                                      message.contents_float32 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_float32.push(reader.float());
                                  } else
                                      message.contents_float32.push(reader.float());
                                  break;
                              case 23:
                                  if (!(message.contents_float64 && message.contents_float64.length))
                                      message.contents_float64 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_float64.push(reader.double());
                                  } else
                                      message.contents_float64.push(reader.double());
                                  break;
                              case 24:
                                  if (!(message.contents_bool && message.contents_bool.length))
                                      message.contents_bool = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_bool.push(reader.bool());
                                  } else
                                      message.contents_bool.push(reader.bool());
                                  break;
                              case 25:
                                  if (!(message.contents_qint8 && message.contents_qint8.length))
                                      message.contents_qint8 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_qint8.push(reader.sint32());
                                  } else
                                      message.contents_qint8.push(reader.sint32());
                                  break;
                              case 26:
                                  if (!(message.contents_quint8 && message.contents_quint8.length))
                                      message.contents_quint8 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_quint8.push(reader.uint32());
                                  } else
                                      message.contents_quint8.push(reader.uint32());
                                  break;
                              case 27:
                                  if (!(message.contents_qint32 && message.contents_qint32.length))
                                      message.contents_qint32 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_qint32.push(reader.sint32());
                                  } else
                                      message.contents_qint32.push(reader.sint32());
                                  break;
                              case 28:
                                  if (!(message.contents_bfloat16 && message.contents_bfloat16.length))
                                      message.contents_bfloat16 = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.contents_bfloat16.push(reader.float());
                                  } else
                                      message.contents_bfloat16.push(reader.float());
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a TensorData message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.TensorData} TensorData
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TensorData.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a TensorData message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      TensorData.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.shape != null && message.hasOwnProperty("shape")) {
                              var error = $root.syft_proto.types.torch.v1.Size.verify(message.shape);
                              if (error)
                                  return "shape." + error;
                          }
                          if (message.dtype != null && message.hasOwnProperty("dtype"))
                              if (!$util.isString(message.dtype))
                                  return "dtype: string expected";
                          if (message.is_quantized != null && message.hasOwnProperty("is_quantized"))
                              if (typeof message.is_quantized !== "boolean")
                                  return "is_quantized: boolean expected";
                          if (message.scale != null && message.hasOwnProperty("scale"))
                              if (typeof message.scale !== "number")
                                  return "scale: number expected";
                          if (message.zero_point != null && message.hasOwnProperty("zero_point"))
                              if (!$util.isInteger(message.zero_point))
                                  return "zero_point: integer expected";
                          if (message.contents_uint8 != null && message.hasOwnProperty("contents_uint8")) {
                              if (!Array.isArray(message.contents_uint8))
                                  return "contents_uint8: array expected";
                              for (var i = 0; i < message.contents_uint8.length; ++i)
                                  if (!$util.isInteger(message.contents_uint8[i]))
                                      return "contents_uint8: integer[] expected";
                          }
                          if (message.contents_int8 != null && message.hasOwnProperty("contents_int8")) {
                              if (!Array.isArray(message.contents_int8))
                                  return "contents_int8: array expected";
                              for (var i = 0; i < message.contents_int8.length; ++i)
                                  if (!$util.isInteger(message.contents_int8[i]))
                                      return "contents_int8: integer[] expected";
                          }
                          if (message.contents_int16 != null && message.hasOwnProperty("contents_int16")) {
                              if (!Array.isArray(message.contents_int16))
                                  return "contents_int16: array expected";
                              for (var i = 0; i < message.contents_int16.length; ++i)
                                  if (!$util.isInteger(message.contents_int16[i]))
                                      return "contents_int16: integer[] expected";
                          }
                          if (message.contents_int32 != null && message.hasOwnProperty("contents_int32")) {
                              if (!Array.isArray(message.contents_int32))
                                  return "contents_int32: array expected";
                              for (var i = 0; i < message.contents_int32.length; ++i)
                                  if (!$util.isInteger(message.contents_int32[i]))
                                      return "contents_int32: integer[] expected";
                          }
                          if (message.contents_int64 != null && message.hasOwnProperty("contents_int64")) {
                              if (!Array.isArray(message.contents_int64))
                                  return "contents_int64: array expected";
                              for (var i = 0; i < message.contents_int64.length; ++i)
                                  if (!$util.isInteger(message.contents_int64[i]) && !(message.contents_int64[i] && $util.isInteger(message.contents_int64[i].low) && $util.isInteger(message.contents_int64[i].high)))
                                      return "contents_int64: integer|Long[] expected";
                          }
                          if (message.contents_float16 != null && message.hasOwnProperty("contents_float16")) {
                              if (!Array.isArray(message.contents_float16))
                                  return "contents_float16: array expected";
                              for (var i = 0; i < message.contents_float16.length; ++i)
                                  if (typeof message.contents_float16[i] !== "number")
                                      return "contents_float16: number[] expected";
                          }
                          if (message.contents_float32 != null && message.hasOwnProperty("contents_float32")) {
                              if (!Array.isArray(message.contents_float32))
                                  return "contents_float32: array expected";
                              for (var i = 0; i < message.contents_float32.length; ++i)
                                  if (typeof message.contents_float32[i] !== "number")
                                      return "contents_float32: number[] expected";
                          }
                          if (message.contents_float64 != null && message.hasOwnProperty("contents_float64")) {
                              if (!Array.isArray(message.contents_float64))
                                  return "contents_float64: array expected";
                              for (var i = 0; i < message.contents_float64.length; ++i)
                                  if (typeof message.contents_float64[i] !== "number")
                                      return "contents_float64: number[] expected";
                          }
                          if (message.contents_bool != null && message.hasOwnProperty("contents_bool")) {
                              if (!Array.isArray(message.contents_bool))
                                  return "contents_bool: array expected";
                              for (var i = 0; i < message.contents_bool.length; ++i)
                                  if (typeof message.contents_bool[i] !== "boolean")
                                      return "contents_bool: boolean[] expected";
                          }
                          if (message.contents_qint8 != null && message.hasOwnProperty("contents_qint8")) {
                              if (!Array.isArray(message.contents_qint8))
                                  return "contents_qint8: array expected";
                              for (var i = 0; i < message.contents_qint8.length; ++i)
                                  if (!$util.isInteger(message.contents_qint8[i]))
                                      return "contents_qint8: integer[] expected";
                          }
                          if (message.contents_quint8 != null && message.hasOwnProperty("contents_quint8")) {
                              if (!Array.isArray(message.contents_quint8))
                                  return "contents_quint8: array expected";
                              for (var i = 0; i < message.contents_quint8.length; ++i)
                                  if (!$util.isInteger(message.contents_quint8[i]))
                                      return "contents_quint8: integer[] expected";
                          }
                          if (message.contents_qint32 != null && message.hasOwnProperty("contents_qint32")) {
                              if (!Array.isArray(message.contents_qint32))
                                  return "contents_qint32: array expected";
                              for (var i = 0; i < message.contents_qint32.length; ++i)
                                  if (!$util.isInteger(message.contents_qint32[i]))
                                      return "contents_qint32: integer[] expected";
                          }
                          if (message.contents_bfloat16 != null && message.hasOwnProperty("contents_bfloat16")) {
                              if (!Array.isArray(message.contents_bfloat16))
                                  return "contents_bfloat16: array expected";
                              for (var i = 0; i < message.contents_bfloat16.length; ++i)
                                  if (typeof message.contents_bfloat16[i] !== "number")
                                      return "contents_bfloat16: number[] expected";
                          }
                          return null;
                      };

                      /**
                       * Creates a TensorData message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.TensorData} TensorData
                       */
                      TensorData.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.TensorData)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.TensorData();
                          if (object.shape != null) {
                              if (typeof object.shape !== "object")
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.shape: object expected");
                              message.shape = $root.syft_proto.types.torch.v1.Size.fromObject(object.shape);
                          }
                          if (object.dtype != null)
                              message.dtype = String(object.dtype);
                          if (object.is_quantized != null)
                              message.is_quantized = Boolean(object.is_quantized);
                          if (object.scale != null)
                              message.scale = Number(object.scale);
                          if (object.zero_point != null)
                              message.zero_point = object.zero_point | 0;
                          if (object.contents_uint8) {
                              if (!Array.isArray(object.contents_uint8))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_uint8: array expected");
                              message.contents_uint8 = [];
                              for (var i = 0; i < object.contents_uint8.length; ++i)
                                  message.contents_uint8[i] = object.contents_uint8[i] >>> 0;
                          }
                          if (object.contents_int8) {
                              if (!Array.isArray(object.contents_int8))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_int8: array expected");
                              message.contents_int8 = [];
                              for (var i = 0; i < object.contents_int8.length; ++i)
                                  message.contents_int8[i] = object.contents_int8[i] | 0;
                          }
                          if (object.contents_int16) {
                              if (!Array.isArray(object.contents_int16))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_int16: array expected");
                              message.contents_int16 = [];
                              for (var i = 0; i < object.contents_int16.length; ++i)
                                  message.contents_int16[i] = object.contents_int16[i] | 0;
                          }
                          if (object.contents_int32) {
                              if (!Array.isArray(object.contents_int32))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_int32: array expected");
                              message.contents_int32 = [];
                              for (var i = 0; i < object.contents_int32.length; ++i)
                                  message.contents_int32[i] = object.contents_int32[i] | 0;
                          }
                          if (object.contents_int64) {
                              if (!Array.isArray(object.contents_int64))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_int64: array expected");
                              message.contents_int64 = [];
                              for (var i = 0; i < object.contents_int64.length; ++i)
                                  if ($util.Long)
                                      (message.contents_int64[i] = $util.Long.fromValue(object.contents_int64[i])).unsigned = false;
                                  else if (typeof object.contents_int64[i] === "string")
                                      message.contents_int64[i] = parseInt(object.contents_int64[i], 10);
                                  else if (typeof object.contents_int64[i] === "number")
                                      message.contents_int64[i] = object.contents_int64[i];
                                  else if (typeof object.contents_int64[i] === "object")
                                      message.contents_int64[i] = new $util.LongBits(object.contents_int64[i].low >>> 0, object.contents_int64[i].high >>> 0).toNumber();
                          }
                          if (object.contents_float16) {
                              if (!Array.isArray(object.contents_float16))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_float16: array expected");
                              message.contents_float16 = [];
                              for (var i = 0; i < object.contents_float16.length; ++i)
                                  message.contents_float16[i] = Number(object.contents_float16[i]);
                          }
                          if (object.contents_float32) {
                              if (!Array.isArray(object.contents_float32))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_float32: array expected");
                              message.contents_float32 = [];
                              for (var i = 0; i < object.contents_float32.length; ++i)
                                  message.contents_float32[i] = Number(object.contents_float32[i]);
                          }
                          if (object.contents_float64) {
                              if (!Array.isArray(object.contents_float64))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_float64: array expected");
                              message.contents_float64 = [];
                              for (var i = 0; i < object.contents_float64.length; ++i)
                                  message.contents_float64[i] = Number(object.contents_float64[i]);
                          }
                          if (object.contents_bool) {
                              if (!Array.isArray(object.contents_bool))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_bool: array expected");
                              message.contents_bool = [];
                              for (var i = 0; i < object.contents_bool.length; ++i)
                                  message.contents_bool[i] = Boolean(object.contents_bool[i]);
                          }
                          if (object.contents_qint8) {
                              if (!Array.isArray(object.contents_qint8))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_qint8: array expected");
                              message.contents_qint8 = [];
                              for (var i = 0; i < object.contents_qint8.length; ++i)
                                  message.contents_qint8[i] = object.contents_qint8[i] | 0;
                          }
                          if (object.contents_quint8) {
                              if (!Array.isArray(object.contents_quint8))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_quint8: array expected");
                              message.contents_quint8 = [];
                              for (var i = 0; i < object.contents_quint8.length; ++i)
                                  message.contents_quint8[i] = object.contents_quint8[i] >>> 0;
                          }
                          if (object.contents_qint32) {
                              if (!Array.isArray(object.contents_qint32))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_qint32: array expected");
                              message.contents_qint32 = [];
                              for (var i = 0; i < object.contents_qint32.length; ++i)
                                  message.contents_qint32[i] = object.contents_qint32[i] | 0;
                          }
                          if (object.contents_bfloat16) {
                              if (!Array.isArray(object.contents_bfloat16))
                                  throw TypeError(".syft_proto.types.torch.v1.TensorData.contents_bfloat16: array expected");
                              message.contents_bfloat16 = [];
                              for (var i = 0; i < object.contents_bfloat16.length; ++i)
                                  message.contents_bfloat16[i] = Number(object.contents_bfloat16[i]);
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a TensorData message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @static
                       * @param {syft_proto.types.torch.v1.TensorData} message TensorData
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      TensorData.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults) {
                              object.contents_uint8 = [];
                              object.contents_int8 = [];
                              object.contents_int16 = [];
                              object.contents_int32 = [];
                              object.contents_int64 = [];
                              object.contents_float16 = [];
                              object.contents_float32 = [];
                              object.contents_float64 = [];
                              object.contents_bool = [];
                              object.contents_qint8 = [];
                              object.contents_quint8 = [];
                              object.contents_qint32 = [];
                              object.contents_bfloat16 = [];
                          }
                          if (options.defaults) {
                              object.shape = null;
                              object.dtype = "";
                              object.is_quantized = false;
                              object.scale = 0;
                              object.zero_point = 0;
                          }
                          if (message.shape != null && message.hasOwnProperty("shape"))
                              object.shape = $root.syft_proto.types.torch.v1.Size.toObject(message.shape, options);
                          if (message.dtype != null && message.hasOwnProperty("dtype"))
                              object.dtype = message.dtype;
                          if (message.is_quantized != null && message.hasOwnProperty("is_quantized"))
                              object.is_quantized = message.is_quantized;
                          if (message.scale != null && message.hasOwnProperty("scale"))
                              object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
                          if (message.zero_point != null && message.hasOwnProperty("zero_point"))
                              object.zero_point = message.zero_point;
                          if (message.contents_uint8 && message.contents_uint8.length) {
                              object.contents_uint8 = [];
                              for (var j = 0; j < message.contents_uint8.length; ++j)
                                  object.contents_uint8[j] = message.contents_uint8[j];
                          }
                          if (message.contents_int8 && message.contents_int8.length) {
                              object.contents_int8 = [];
                              for (var j = 0; j < message.contents_int8.length; ++j)
                                  object.contents_int8[j] = message.contents_int8[j];
                          }
                          if (message.contents_int16 && message.contents_int16.length) {
                              object.contents_int16 = [];
                              for (var j = 0; j < message.contents_int16.length; ++j)
                                  object.contents_int16[j] = message.contents_int16[j];
                          }
                          if (message.contents_int32 && message.contents_int32.length) {
                              object.contents_int32 = [];
                              for (var j = 0; j < message.contents_int32.length; ++j)
                                  object.contents_int32[j] = message.contents_int32[j];
                          }
                          if (message.contents_int64 && message.contents_int64.length) {
                              object.contents_int64 = [];
                              for (var j = 0; j < message.contents_int64.length; ++j)
                                  if (typeof message.contents_int64[j] === "number")
                                      object.contents_int64[j] = options.longs === String ? String(message.contents_int64[j]) : message.contents_int64[j];
                                  else
                                      object.contents_int64[j] = options.longs === String ? $util.Long.prototype.toString.call(message.contents_int64[j]) : options.longs === Number ? new $util.LongBits(message.contents_int64[j].low >>> 0, message.contents_int64[j].high >>> 0).toNumber() : message.contents_int64[j];
                          }
                          if (message.contents_float16 && message.contents_float16.length) {
                              object.contents_float16 = [];
                              for (var j = 0; j < message.contents_float16.length; ++j)
                                  object.contents_float16[j] = options.json && !isFinite(message.contents_float16[j]) ? String(message.contents_float16[j]) : message.contents_float16[j];
                          }
                          if (message.contents_float32 && message.contents_float32.length) {
                              object.contents_float32 = [];
                              for (var j = 0; j < message.contents_float32.length; ++j)
                                  object.contents_float32[j] = options.json && !isFinite(message.contents_float32[j]) ? String(message.contents_float32[j]) : message.contents_float32[j];
                          }
                          if (message.contents_float64 && message.contents_float64.length) {
                              object.contents_float64 = [];
                              for (var j = 0; j < message.contents_float64.length; ++j)
                                  object.contents_float64[j] = options.json && !isFinite(message.contents_float64[j]) ? String(message.contents_float64[j]) : message.contents_float64[j];
                          }
                          if (message.contents_bool && message.contents_bool.length) {
                              object.contents_bool = [];
                              for (var j = 0; j < message.contents_bool.length; ++j)
                                  object.contents_bool[j] = message.contents_bool[j];
                          }
                          if (message.contents_qint8 && message.contents_qint8.length) {
                              object.contents_qint8 = [];
                              for (var j = 0; j < message.contents_qint8.length; ++j)
                                  object.contents_qint8[j] = message.contents_qint8[j];
                          }
                          if (message.contents_quint8 && message.contents_quint8.length) {
                              object.contents_quint8 = [];
                              for (var j = 0; j < message.contents_quint8.length; ++j)
                                  object.contents_quint8[j] = message.contents_quint8[j];
                          }
                          if (message.contents_qint32 && message.contents_qint32.length) {
                              object.contents_qint32 = [];
                              for (var j = 0; j < message.contents_qint32.length; ++j)
                                  object.contents_qint32[j] = message.contents_qint32[j];
                          }
                          if (message.contents_bfloat16 && message.contents_bfloat16.length) {
                              object.contents_bfloat16 = [];
                              for (var j = 0; j < message.contents_bfloat16.length; ++j)
                                  object.contents_bfloat16[j] = options.json && !isFinite(message.contents_bfloat16[j]) ? String(message.contents_bfloat16[j]) : message.contents_bfloat16[j];
                          }
                          return object;
                      };

                      /**
                       * Converts this TensorData to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.TensorData
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      TensorData.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return TensorData;
                  })();

                  v1.Size = (function() {

                      /**
                       * Properties of a Size.
                       * @memberof syft_proto.types.torch.v1
                       * @interface ISize
                       * @property {Array.<number>|null} [dims] Size dims
                       */

                      /**
                       * Constructs a new Size.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a Size.
                       * @implements ISize
                       * @constructor
                       * @param {syft_proto.types.torch.v1.ISize=} [properties] Properties to set
                       */
                      function Size(properties) {
                          this.dims = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * Size dims.
                       * @member {Array.<number>} dims
                       * @memberof syft_proto.types.torch.v1.Size
                       * @instance
                       */
                      Size.prototype.dims = $util.emptyArray;

                      /**
                       * Creates a new Size instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.Size
                       * @static
                       * @param {syft_proto.types.torch.v1.ISize=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.Size} Size instance
                       */
                      Size.create = function create(properties) {
                          return new Size(properties);
                      };

                      /**
                       * Encodes the specified Size message. Does not implicitly {@link syft_proto.types.torch.v1.Size.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.Size
                       * @static
                       * @param {syft_proto.types.torch.v1.ISize} message Size message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Size.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.dims != null && message.dims.length) {
                              writer.uint32(/* id 1, wireType 2 =*/10).fork();
                              for (var i = 0; i < message.dims.length; ++i)
                                  writer.int32(message.dims[i]);
                              writer.ldelim();
                          }
                          return writer;
                      };

                      /**
                       * Encodes the specified Size message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.Size.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.Size
                       * @static
                       * @param {syft_proto.types.torch.v1.ISize} message Size message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Size.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a Size message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.Size
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.Size} Size
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Size.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.Size();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  if (!(message.dims && message.dims.length))
                                      message.dims = [];
                                  if ((tag & 7) === 2) {
                                      var end2 = reader.uint32() + reader.pos;
                                      while (reader.pos < end2)
                                          message.dims.push(reader.int32());
                                  } else
                                      message.dims.push(reader.int32());
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a Size message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.Size
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.Size} Size
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Size.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a Size message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.Size
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      Size.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.dims != null && message.hasOwnProperty("dims")) {
                              if (!Array.isArray(message.dims))
                                  return "dims: array expected";
                              for (var i = 0; i < message.dims.length; ++i)
                                  if (!$util.isInteger(message.dims[i]))
                                      return "dims: integer[] expected";
                          }
                          return null;
                      };

                      /**
                       * Creates a Size message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.Size
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.Size} Size
                       */
                      Size.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.Size)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.Size();
                          if (object.dims) {
                              if (!Array.isArray(object.dims))
                                  throw TypeError(".syft_proto.types.torch.v1.Size.dims: array expected");
                              message.dims = [];
                              for (var i = 0; i < object.dims.length; ++i)
                                  message.dims[i] = object.dims[i] | 0;
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a Size message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.Size
                       * @static
                       * @param {syft_proto.types.torch.v1.Size} message Size
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      Size.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults)
                              object.dims = [];
                          if (message.dims && message.dims.length) {
                              object.dims = [];
                              for (var j = 0; j < message.dims.length; ++j)
                                  object.dims[j] = message.dims[j];
                          }
                          return object;
                      };

                      /**
                       * Converts this Size to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.Size
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      Size.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return Size;
                  })();

                  v1.Parameter = (function() {

                      /**
                       * Properties of a Parameter.
                       * @memberof syft_proto.types.torch.v1
                       * @interface IParameter
                       * @property {syft_proto.types.syft.v1.IId|null} [id] Parameter id
                       * @property {syft_proto.types.torch.v1.ITorchTensor|null} [tensor] Parameter tensor
                       * @property {boolean|null} [requires_grad] Parameter requires_grad
                       * @property {syft_proto.types.torch.v1.ITorchTensor|null} [grad] Parameter grad
                       */

                      /**
                       * Constructs a new Parameter.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a Parameter.
                       * @implements IParameter
                       * @constructor
                       * @param {syft_proto.types.torch.v1.IParameter=} [properties] Properties to set
                       */
                      function Parameter(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * Parameter id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @instance
                       */
                      Parameter.prototype.id = null;

                      /**
                       * Parameter tensor.
                       * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} tensor
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @instance
                       */
                      Parameter.prototype.tensor = null;

                      /**
                       * Parameter requires_grad.
                       * @member {boolean} requires_grad
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @instance
                       */
                      Parameter.prototype.requires_grad = false;

                      /**
                       * Parameter grad.
                       * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} grad
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @instance
                       */
                      Parameter.prototype.grad = null;

                      /**
                       * Creates a new Parameter instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @static
                       * @param {syft_proto.types.torch.v1.IParameter=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.Parameter} Parameter instance
                       */
                      Parameter.create = function create(properties) {
                          return new Parameter(properties);
                      };

                      /**
                       * Encodes the specified Parameter message. Does not implicitly {@link syft_proto.types.torch.v1.Parameter.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @static
                       * @param {syft_proto.types.torch.v1.IParameter} message Parameter message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Parameter.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.id != null && message.hasOwnProperty("id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          if (message.tensor != null && message.hasOwnProperty("tensor"))
                              $root.syft_proto.types.torch.v1.TorchTensor.encode(message.tensor, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                          if (message.requires_grad != null && message.hasOwnProperty("requires_grad"))
                              writer.uint32(/* id 3, wireType 0 =*/24).bool(message.requires_grad);
                          if (message.grad != null && message.hasOwnProperty("grad"))
                              $root.syft_proto.types.torch.v1.TorchTensor.encode(message.grad, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                          return writer;
                      };

                      /**
                       * Encodes the specified Parameter message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.Parameter.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @static
                       * @param {syft_proto.types.torch.v1.IParameter} message Parameter message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Parameter.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a Parameter message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.Parameter} Parameter
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Parameter.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.Parameter();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 2:
                                  message.tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                  break;
                              case 3:
                                  message.requires_grad = reader.bool();
                                  break;
                              case 4:
                                  message.grad = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a Parameter message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.Parameter} Parameter
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Parameter.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a Parameter message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      Parameter.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.id != null && message.hasOwnProperty("id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                              if (error)
                                  return "id." + error;
                          }
                          if (message.tensor != null && message.hasOwnProperty("tensor")) {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.tensor);
                              if (error)
                                  return "tensor." + error;
                          }
                          if (message.requires_grad != null && message.hasOwnProperty("requires_grad"))
                              if (typeof message.requires_grad !== "boolean")
                                  return "requires_grad: boolean expected";
                          if (message.grad != null && message.hasOwnProperty("grad")) {
                              var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.grad);
                              if (error)
                                  return "grad." + error;
                          }
                          return null;
                      };

                      /**
                       * Creates a Parameter message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.Parameter} Parameter
                       */
                      Parameter.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.Parameter)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.Parameter();
                          if (object.id != null) {
                              if (typeof object.id !== "object")
                                  throw TypeError(".syft_proto.types.torch.v1.Parameter.id: object expected");
                              message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                          }
                          if (object.tensor != null) {
                              if (typeof object.tensor !== "object")
                                  throw TypeError(".syft_proto.types.torch.v1.Parameter.tensor: object expected");
                              message.tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.tensor);
                          }
                          if (object.requires_grad != null)
                              message.requires_grad = Boolean(object.requires_grad);
                          if (object.grad != null) {
                              if (typeof object.grad !== "object")
                                  throw TypeError(".syft_proto.types.torch.v1.Parameter.grad: object expected");
                              message.grad = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.grad);
                          }
                          return message;
                      };

                      /**
                       * Creates a plain object from a Parameter message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @static
                       * @param {syft_proto.types.torch.v1.Parameter} message Parameter
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      Parameter.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults) {
                              object.id = null;
                              object.tensor = null;
                              object.requires_grad = false;
                              object.grad = null;
                          }
                          if (message.id != null && message.hasOwnProperty("id"))
                              object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                          if (message.tensor != null && message.hasOwnProperty("tensor"))
                              object.tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.tensor, options);
                          if (message.requires_grad != null && message.hasOwnProperty("requires_grad"))
                              object.requires_grad = message.requires_grad;
                          if (message.grad != null && message.hasOwnProperty("grad"))
                              object.grad = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.grad, options);
                          return object;
                      };

                      /**
                       * Converts this Parameter to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.Parameter
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      Parameter.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return Parameter;
                  })();

                  v1.CFunction = (function() {

                      /**
                       * Properties of a CFunction.
                       * @memberof syft_proto.types.torch.v1
                       * @interface ICFunction
                       * @property {Uint8Array|null} [obj] CFunction obj
                       */

                      /**
                       * Constructs a new CFunction.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a CFunction.
                       * @implements ICFunction
                       * @constructor
                       * @param {syft_proto.types.torch.v1.ICFunction=} [properties] Properties to set
                       */
                      function CFunction(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * CFunction obj.
                       * @member {Uint8Array} obj
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @instance
                       */
                      CFunction.prototype.obj = $util.newBuffer([]);

                      /**
                       * Creates a new CFunction instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @static
                       * @param {syft_proto.types.torch.v1.ICFunction=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.CFunction} CFunction instance
                       */
                      CFunction.create = function create(properties) {
                          return new CFunction(properties);
                      };

                      /**
                       * Encodes the specified CFunction message. Does not implicitly {@link syft_proto.types.torch.v1.CFunction.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @static
                       * @param {syft_proto.types.torch.v1.ICFunction} message CFunction message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      CFunction.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.obj);
                          return writer;
                      };

                      /**
                       * Encodes the specified CFunction message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.CFunction.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @static
                       * @param {syft_proto.types.torch.v1.ICFunction} message CFunction message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      CFunction.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a CFunction message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.CFunction} CFunction
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      CFunction.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.CFunction();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.obj = reader.bytes();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a CFunction message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.CFunction} CFunction
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      CFunction.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a CFunction message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      CFunction.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                                  return "obj: buffer expected";
                          return null;
                      };

                      /**
                       * Creates a CFunction message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.CFunction} CFunction
                       */
                      CFunction.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.CFunction)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.CFunction();
                          if (object.obj != null)
                              if (typeof object.obj === "string")
                                  $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                              else if (object.obj.length)
                                  message.obj = object.obj;
                          return message;
                      };

                      /**
                       * Creates a plain object from a CFunction message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @static
                       * @param {syft_proto.types.torch.v1.CFunction} message CFunction
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      CFunction.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults)
                              if (options.bytes === String)
                                  object.obj = "";
                              else {
                                  object.obj = [];
                                  if (options.bytes !== Array)
                                      object.obj = $util.newBuffer(object.obj);
                              }
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                          return object;
                      };

                      /**
                       * Converts this CFunction to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.CFunction
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      CFunction.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return CFunction;
                  })();

                  v1.Device = (function() {

                      /**
                       * Properties of a Device.
                       * @memberof syft_proto.types.torch.v1
                       * @interface IDevice
                       * @property {string|null} [type] Device type
                       */

                      /**
                       * Constructs a new Device.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a Device.
                       * @implements IDevice
                       * @constructor
                       * @param {syft_proto.types.torch.v1.IDevice=} [properties] Properties to set
                       */
                      function Device(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * Device type.
                       * @member {string} type
                       * @memberof syft_proto.types.torch.v1.Device
                       * @instance
                       */
                      Device.prototype.type = "";

                      /**
                       * Creates a new Device instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.Device
                       * @static
                       * @param {syft_proto.types.torch.v1.IDevice=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.Device} Device instance
                       */
                      Device.create = function create(properties) {
                          return new Device(properties);
                      };

                      /**
                       * Encodes the specified Device message. Does not implicitly {@link syft_proto.types.torch.v1.Device.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.Device
                       * @static
                       * @param {syft_proto.types.torch.v1.IDevice} message Device message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Device.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.type != null && message.hasOwnProperty("type"))
                              writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                          return writer;
                      };

                      /**
                       * Encodes the specified Device message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.Device.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.Device
                       * @static
                       * @param {syft_proto.types.torch.v1.IDevice} message Device message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      Device.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a Device message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.Device
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.Device} Device
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Device.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.Device();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.type = reader.string();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a Device message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.Device
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.Device} Device
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      Device.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a Device message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.Device
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      Device.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.type != null && message.hasOwnProperty("type"))
                              if (!$util.isString(message.type))
                                  return "type: string expected";
                          return null;
                      };

                      /**
                       * Creates a Device message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.Device
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.Device} Device
                       */
                      Device.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.Device)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.Device();
                          if (object.type != null)
                              message.type = String(object.type);
                          return message;
                      };

                      /**
                       * Creates a plain object from a Device message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.Device
                       * @static
                       * @param {syft_proto.types.torch.v1.Device} message Device
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      Device.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults)
                              object.type = "";
                          if (message.type != null && message.hasOwnProperty("type"))
                              object.type = message.type;
                          return object;
                      };

                      /**
                       * Converts this Device to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.Device
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      Device.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return Device;
                  })();

                  v1.TorchDType = (function() {

                      /**
                       * Properties of a TorchDType.
                       * @memberof syft_proto.types.torch.v1
                       * @interface ITorchDType
                       * @property {string|null} [torch_type] TorchDType torch_type
                       */

                      /**
                       * Constructs a new TorchDType.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a TorchDType.
                       * @implements ITorchDType
                       * @constructor
                       * @param {syft_proto.types.torch.v1.ITorchDType=} [properties] Properties to set
                       */
                      function TorchDType(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * TorchDType torch_type.
                       * @member {string} torch_type
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @instance
                       */
                      TorchDType.prototype.torch_type = "";

                      /**
                       * Creates a new TorchDType instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @static
                       * @param {syft_proto.types.torch.v1.ITorchDType=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.TorchDType} TorchDType instance
                       */
                      TorchDType.create = function create(properties) {
                          return new TorchDType(properties);
                      };

                      /**
                       * Encodes the specified TorchDType message. Does not implicitly {@link syft_proto.types.torch.v1.TorchDType.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @static
                       * @param {syft_proto.types.torch.v1.ITorchDType} message TorchDType message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TorchDType.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.torch_type != null && message.hasOwnProperty("torch_type"))
                              writer.uint32(/* id 1, wireType 2 =*/10).string(message.torch_type);
                          return writer;
                      };

                      /**
                       * Encodes the specified TorchDType message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.TorchDType.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @static
                       * @param {syft_proto.types.torch.v1.ITorchDType} message TorchDType message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TorchDType.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a TorchDType message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.TorchDType} TorchDType
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TorchDType.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.TorchDType();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.torch_type = reader.string();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a TorchDType message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.TorchDType} TorchDType
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TorchDType.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a TorchDType message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      TorchDType.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.torch_type != null && message.hasOwnProperty("torch_type"))
                              if (!$util.isString(message.torch_type))
                                  return "torch_type: string expected";
                          return null;
                      };

                      /**
                       * Creates a TorchDType message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.TorchDType} TorchDType
                       */
                      TorchDType.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.TorchDType)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.TorchDType();
                          if (object.torch_type != null)
                              message.torch_type = String(object.torch_type);
                          return message;
                      };

                      /**
                       * Creates a plain object from a TorchDType message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @static
                       * @param {syft_proto.types.torch.v1.TorchDType} message TorchDType
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      TorchDType.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults)
                              object.torch_type = "";
                          if (message.torch_type != null && message.hasOwnProperty("torch_type"))
                              object.torch_type = message.torch_type;
                          return object;
                      };

                      /**
                       * Converts this TorchDType to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.TorchDType
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      TorchDType.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return TorchDType;
                  })();

                  v1.MemoryFormat = (function() {

                      /**
                       * Properties of a MemoryFormat.
                       * @memberof syft_proto.types.torch.v1
                       * @interface IMemoryFormat
                       * @property {string|null} [memory_format_type] MemoryFormat memory_format_type
                       */

                      /**
                       * Constructs a new MemoryFormat.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a MemoryFormat.
                       * @implements IMemoryFormat
                       * @constructor
                       * @param {syft_proto.types.torch.v1.IMemoryFormat=} [properties] Properties to set
                       */
                      function MemoryFormat(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * MemoryFormat memory_format_type.
                       * @member {string} memory_format_type
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @instance
                       */
                      MemoryFormat.prototype.memory_format_type = "";

                      /**
                       * Creates a new MemoryFormat instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @static
                       * @param {syft_proto.types.torch.v1.IMemoryFormat=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.MemoryFormat} MemoryFormat instance
                       */
                      MemoryFormat.create = function create(properties) {
                          return new MemoryFormat(properties);
                      };

                      /**
                       * Encodes the specified MemoryFormat message. Does not implicitly {@link syft_proto.types.torch.v1.MemoryFormat.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @static
                       * @param {syft_proto.types.torch.v1.IMemoryFormat} message MemoryFormat message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      MemoryFormat.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.memory_format_type != null && message.hasOwnProperty("memory_format_type"))
                              writer.uint32(/* id 1, wireType 2 =*/10).string(message.memory_format_type);
                          return writer;
                      };

                      /**
                       * Encodes the specified MemoryFormat message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.MemoryFormat.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @static
                       * @param {syft_proto.types.torch.v1.IMemoryFormat} message MemoryFormat message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      MemoryFormat.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a MemoryFormat message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.MemoryFormat} MemoryFormat
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      MemoryFormat.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.MemoryFormat();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.memory_format_type = reader.string();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a MemoryFormat message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.MemoryFormat} MemoryFormat
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      MemoryFormat.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a MemoryFormat message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      MemoryFormat.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.memory_format_type != null && message.hasOwnProperty("memory_format_type"))
                              if (!$util.isString(message.memory_format_type))
                                  return "memory_format_type: string expected";
                          return null;
                      };

                      /**
                       * Creates a MemoryFormat message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.MemoryFormat} MemoryFormat
                       */
                      MemoryFormat.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.MemoryFormat)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.MemoryFormat();
                          if (object.memory_format_type != null)
                              message.memory_format_type = String(object.memory_format_type);
                          return message;
                      };

                      /**
                       * Creates a plain object from a MemoryFormat message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @static
                       * @param {syft_proto.types.torch.v1.MemoryFormat} message MemoryFormat
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      MemoryFormat.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults)
                              object.memory_format_type = "";
                          if (message.memory_format_type != null && message.hasOwnProperty("memory_format_type"))
                              object.memory_format_type = message.memory_format_type;
                          return object;
                      };

                      /**
                       * Converts this MemoryFormat to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.MemoryFormat
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      MemoryFormat.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return MemoryFormat;
                  })();

                  v1.ScriptFunction = (function() {

                      /**
                       * Properties of a ScriptFunction.
                       * @memberof syft_proto.types.torch.v1
                       * @interface IScriptFunction
                       * @property {Uint8Array|null} [obj] ScriptFunction obj
                       */

                      /**
                       * Constructs a new ScriptFunction.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a ScriptFunction.
                       * @implements IScriptFunction
                       * @constructor
                       * @param {syft_proto.types.torch.v1.IScriptFunction=} [properties] Properties to set
                       */
                      function ScriptFunction(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * ScriptFunction obj.
                       * @member {Uint8Array} obj
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @instance
                       */
                      ScriptFunction.prototype.obj = $util.newBuffer([]);

                      /**
                       * Creates a new ScriptFunction instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @static
                       * @param {syft_proto.types.torch.v1.IScriptFunction=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.ScriptFunction} ScriptFunction instance
                       */
                      ScriptFunction.create = function create(properties) {
                          return new ScriptFunction(properties);
                      };

                      /**
                       * Encodes the specified ScriptFunction message. Does not implicitly {@link syft_proto.types.torch.v1.ScriptFunction.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @static
                       * @param {syft_proto.types.torch.v1.IScriptFunction} message ScriptFunction message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      ScriptFunction.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.obj);
                          return writer;
                      };

                      /**
                       * Encodes the specified ScriptFunction message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.ScriptFunction.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @static
                       * @param {syft_proto.types.torch.v1.IScriptFunction} message ScriptFunction message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      ScriptFunction.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a ScriptFunction message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.ScriptFunction} ScriptFunction
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      ScriptFunction.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.ScriptFunction();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.obj = reader.bytes();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a ScriptFunction message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.ScriptFunction} ScriptFunction
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      ScriptFunction.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a ScriptFunction message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      ScriptFunction.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                                  return "obj: buffer expected";
                          return null;
                      };

                      /**
                       * Creates a ScriptFunction message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.ScriptFunction} ScriptFunction
                       */
                      ScriptFunction.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.ScriptFunction)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.ScriptFunction();
                          if (object.obj != null)
                              if (typeof object.obj === "string")
                                  $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                              else if (object.obj.length)
                                  message.obj = object.obj;
                          return message;
                      };

                      /**
                       * Creates a plain object from a ScriptFunction message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @static
                       * @param {syft_proto.types.torch.v1.ScriptFunction} message ScriptFunction
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      ScriptFunction.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults)
                              if (options.bytes === String)
                                  object.obj = "";
                              else {
                                  object.obj = [];
                                  if (options.bytes !== Array)
                                      object.obj = $util.newBuffer(object.obj);
                              }
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                          return object;
                      };

                      /**
                       * Converts this ScriptFunction to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.ScriptFunction
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      ScriptFunction.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return ScriptFunction;
                  })();

                  v1.ScriptModule = (function() {

                      /**
                       * Properties of a ScriptModule.
                       * @memberof syft_proto.types.torch.v1
                       * @interface IScriptModule
                       * @property {Uint8Array|null} [obj] ScriptModule obj
                       */

                      /**
                       * Constructs a new ScriptModule.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a ScriptModule.
                       * @implements IScriptModule
                       * @constructor
                       * @param {syft_proto.types.torch.v1.IScriptModule=} [properties] Properties to set
                       */
                      function ScriptModule(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * ScriptModule obj.
                       * @member {Uint8Array} obj
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @instance
                       */
                      ScriptModule.prototype.obj = $util.newBuffer([]);

                      /**
                       * Creates a new ScriptModule instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @static
                       * @param {syft_proto.types.torch.v1.IScriptModule=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.ScriptModule} ScriptModule instance
                       */
                      ScriptModule.create = function create(properties) {
                          return new ScriptModule(properties);
                      };

                      /**
                       * Encodes the specified ScriptModule message. Does not implicitly {@link syft_proto.types.torch.v1.ScriptModule.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @static
                       * @param {syft_proto.types.torch.v1.IScriptModule} message ScriptModule message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      ScriptModule.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.obj);
                          return writer;
                      };

                      /**
                       * Encodes the specified ScriptModule message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.ScriptModule.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @static
                       * @param {syft_proto.types.torch.v1.IScriptModule} message ScriptModule message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      ScriptModule.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a ScriptModule message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.ScriptModule} ScriptModule
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      ScriptModule.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.ScriptModule();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.obj = reader.bytes();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a ScriptModule message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.ScriptModule} ScriptModule
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      ScriptModule.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a ScriptModule message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      ScriptModule.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                                  return "obj: buffer expected";
                          return null;
                      };

                      /**
                       * Creates a ScriptModule message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.ScriptModule} ScriptModule
                       */
                      ScriptModule.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.ScriptModule)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.ScriptModule();
                          if (object.obj != null)
                              if (typeof object.obj === "string")
                                  $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                              else if (object.obj.length)
                                  message.obj = object.obj;
                          return message;
                      };

                      /**
                       * Creates a plain object from a ScriptModule message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @static
                       * @param {syft_proto.types.torch.v1.ScriptModule} message ScriptModule
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      ScriptModule.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults)
                              if (options.bytes === String)
                                  object.obj = "";
                              else {
                                  object.obj = [];
                                  if (options.bytes !== Array)
                                      object.obj = $util.newBuffer(object.obj);
                              }
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                          return object;
                      };

                      /**
                       * Converts this ScriptModule to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.ScriptModule
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      ScriptModule.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return ScriptModule;
                  })();

                  v1.TracedModule = (function() {

                      /**
                       * Properties of a TracedModule.
                       * @memberof syft_proto.types.torch.v1
                       * @interface ITracedModule
                       * @property {Uint8Array|null} [obj] TracedModule obj
                       */

                      /**
                       * Constructs a new TracedModule.
                       * @memberof syft_proto.types.torch.v1
                       * @classdesc Represents a TracedModule.
                       * @implements ITracedModule
                       * @constructor
                       * @param {syft_proto.types.torch.v1.ITracedModule=} [properties] Properties to set
                       */
                      function TracedModule(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * TracedModule obj.
                       * @member {Uint8Array} obj
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @instance
                       */
                      TracedModule.prototype.obj = $util.newBuffer([]);

                      /**
                       * Creates a new TracedModule instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @static
                       * @param {syft_proto.types.torch.v1.ITracedModule=} [properties] Properties to set
                       * @returns {syft_proto.types.torch.v1.TracedModule} TracedModule instance
                       */
                      TracedModule.create = function create(properties) {
                          return new TracedModule(properties);
                      };

                      /**
                       * Encodes the specified TracedModule message. Does not implicitly {@link syft_proto.types.torch.v1.TracedModule.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @static
                       * @param {syft_proto.types.torch.v1.ITracedModule} message TracedModule message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TracedModule.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.obj);
                          return writer;
                      };

                      /**
                       * Encodes the specified TracedModule message, length delimited. Does not implicitly {@link syft_proto.types.torch.v1.TracedModule.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @static
                       * @param {syft_proto.types.torch.v1.ITracedModule} message TracedModule message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      TracedModule.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a TracedModule message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.types.torch.v1.TracedModule} TracedModule
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TracedModule.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.types.torch.v1.TracedModule();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.obj = reader.bytes();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a TracedModule message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.types.torch.v1.TracedModule} TracedModule
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      TracedModule.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a TracedModule message.
                       * @function verify
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      TracedModule.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                                  return "obj: buffer expected";
                          return null;
                      };

                      /**
                       * Creates a TracedModule message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.types.torch.v1.TracedModule} TracedModule
                       */
                      TracedModule.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.types.torch.v1.TracedModule)
                              return object;
                          var message = new $root.syft_proto.types.torch.v1.TracedModule();
                          if (object.obj != null)
                              if (typeof object.obj === "string")
                                  $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                              else if (object.obj.length)
                                  message.obj = object.obj;
                          return message;
                      };

                      /**
                       * Creates a plain object from a TracedModule message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @static
                       * @param {syft_proto.types.torch.v1.TracedModule} message TracedModule
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      TracedModule.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults)
                              if (options.bytes === String)
                                  object.obj = "";
                              else {
                                  object.obj = [];
                                  if (options.bytes !== Array)
                                      object.obj = $util.newBuffer(object.obj);
                              }
                          if (message.obj != null && message.hasOwnProperty("obj"))
                              object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                          return object;
                      };

                      /**
                       * Converts this TracedModule to JSON.
                       * @function toJSON
                       * @memberof syft_proto.types.torch.v1.TracedModule
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      TracedModule.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return TracedModule;
                  })();

                  return v1;
              })();

              return torch;
          })();

          return types;
      })();

      syft_proto.generic = (function() {

          /**
           * Namespace generic.
           * @memberof syft_proto
           * @namespace
           */
          var generic = {};

          generic.pointers = (function() {

              /**
               * Namespace pointers.
               * @memberof syft_proto.generic
               * @namespace
               */
              var pointers = {};

              pointers.v1 = (function() {

                  /**
                   * Namespace v1.
                   * @memberof syft_proto.generic.pointers
                   * @namespace
                   */
                  var v1 = {};

                  v1.PointerTensor = (function() {

                      /**
                       * Properties of a PointerTensor.
                       * @memberof syft_proto.generic.pointers.v1
                       * @interface IPointerTensor
                       * @property {syft_proto.types.syft.v1.IId|null} [object_id] PointerTensor object_id
                       * @property {syft_proto.types.syft.v1.IId|null} [location_id] PointerTensor location_id
                       * @property {syft_proto.types.syft.v1.IId|null} [object_id_at_location] PointerTensor object_id_at_location
                       * @property {syft_proto.types.syft.v1.IShape|null} [shape] PointerTensor shape
                       * @property {string|null} [point_to_attr] PointerTensor point_to_attr
                       * @property {boolean|null} [garbage_collect_data] PointerTensor garbage_collect_data
                       */

                      /**
                       * Constructs a new PointerTensor.
                       * @memberof syft_proto.generic.pointers.v1
                       * @classdesc Represents a PointerTensor.
                       * @implements IPointerTensor
                       * @constructor
                       * @param {syft_proto.generic.pointers.v1.IPointerTensor=} [properties] Properties to set
                       */
                      function PointerTensor(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * PointerTensor object_id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @instance
                       */
                      PointerTensor.prototype.object_id = null;

                      /**
                       * PointerTensor location_id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} location_id
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @instance
                       */
                      PointerTensor.prototype.location_id = null;

                      /**
                       * PointerTensor object_id_at_location.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id_at_location
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @instance
                       */
                      PointerTensor.prototype.object_id_at_location = null;

                      /**
                       * PointerTensor shape.
                       * @member {syft_proto.types.syft.v1.IShape|null|undefined} shape
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @instance
                       */
                      PointerTensor.prototype.shape = null;

                      /**
                       * PointerTensor point_to_attr.
                       * @member {string} point_to_attr
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @instance
                       */
                      PointerTensor.prototype.point_to_attr = "";

                      /**
                       * PointerTensor garbage_collect_data.
                       * @member {boolean} garbage_collect_data
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @instance
                       */
                      PointerTensor.prototype.garbage_collect_data = false;

                      /**
                       * Creates a new PointerTensor instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerTensor=} [properties] Properties to set
                       * @returns {syft_proto.generic.pointers.v1.PointerTensor} PointerTensor instance
                       */
                      PointerTensor.create = function create(properties) {
                          return new PointerTensor(properties);
                      };

                      /**
                       * Encodes the specified PointerTensor message. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerTensor.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerTensor} message PointerTensor message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      PointerTensor.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.object_id != null && message.hasOwnProperty("object_id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          if (message.location_id != null && message.hasOwnProperty("location_id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.location_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.object_id_at_location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                          if (message.shape != null && message.hasOwnProperty("shape"))
                              $root.syft_proto.types.syft.v1.Shape.encode(message.shape, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                          if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                              writer.uint32(/* id 5, wireType 2 =*/42).string(message.point_to_attr);
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              writer.uint32(/* id 6, wireType 0 =*/48).bool(message.garbage_collect_data);
                          return writer;
                      };

                      /**
                       * Encodes the specified PointerTensor message, length delimited. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerTensor.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerTensor} message PointerTensor message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      PointerTensor.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a PointerTensor message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.generic.pointers.v1.PointerTensor} PointerTensor
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      PointerTensor.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.generic.pointers.v1.PointerTensor();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 2:
                                  message.location_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 3:
                                  message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 4:
                                  message.shape = $root.syft_proto.types.syft.v1.Shape.decode(reader, reader.uint32());
                                  break;
                              case 5:
                                  message.point_to_attr = reader.string();
                                  break;
                              case 6:
                                  message.garbage_collect_data = reader.bool();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a PointerTensor message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.generic.pointers.v1.PointerTensor} PointerTensor
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      PointerTensor.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a PointerTensor message.
                       * @function verify
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      PointerTensor.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.object_id != null && message.hasOwnProperty("object_id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                              if (error)
                                  return "object_id." + error;
                          }
                          if (message.location_id != null && message.hasOwnProperty("location_id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_id);
                              if (error)
                                  return "location_id." + error;
                          }
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id_at_location);
                              if (error)
                                  return "object_id_at_location." + error;
                          }
                          if (message.shape != null && message.hasOwnProperty("shape")) {
                              var error = $root.syft_proto.types.syft.v1.Shape.verify(message.shape);
                              if (error)
                                  return "shape." + error;
                          }
                          if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                              if (!$util.isString(message.point_to_attr))
                                  return "point_to_attr: string expected";
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              if (typeof message.garbage_collect_data !== "boolean")
                                  return "garbage_collect_data: boolean expected";
                          return null;
                      };

                      /**
                       * Creates a PointerTensor message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.generic.pointers.v1.PointerTensor} PointerTensor
                       */
                      PointerTensor.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.generic.pointers.v1.PointerTensor)
                              return object;
                          var message = new $root.syft_proto.generic.pointers.v1.PointerTensor();
                          if (object.object_id != null) {
                              if (typeof object.object_id !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerTensor.object_id: object expected");
                              message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                          }
                          if (object.location_id != null) {
                              if (typeof object.location_id !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerTensor.location_id: object expected");
                              message.location_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_id);
                          }
                          if (object.object_id_at_location != null) {
                              if (typeof object.object_id_at_location !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerTensor.object_id_at_location: object expected");
                              message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id_at_location);
                          }
                          if (object.shape != null) {
                              if (typeof object.shape !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerTensor.shape: object expected");
                              message.shape = $root.syft_proto.types.syft.v1.Shape.fromObject(object.shape);
                          }
                          if (object.point_to_attr != null)
                              message.point_to_attr = String(object.point_to_attr);
                          if (object.garbage_collect_data != null)
                              message.garbage_collect_data = Boolean(object.garbage_collect_data);
                          return message;
                      };

                      /**
                       * Creates a plain object from a PointerTensor message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @static
                       * @param {syft_proto.generic.pointers.v1.PointerTensor} message PointerTensor
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      PointerTensor.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults) {
                              object.object_id = null;
                              object.location_id = null;
                              object.object_id_at_location = null;
                              object.shape = null;
                              object.point_to_attr = "";
                              object.garbage_collect_data = false;
                          }
                          if (message.object_id != null && message.hasOwnProperty("object_id"))
                              object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                          if (message.location_id != null && message.hasOwnProperty("location_id"))
                              object.location_id = $root.syft_proto.types.syft.v1.Id.toObject(message.location_id, options);
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                              object.object_id_at_location = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id_at_location, options);
                          if (message.shape != null && message.hasOwnProperty("shape"))
                              object.shape = $root.syft_proto.types.syft.v1.Shape.toObject(message.shape, options);
                          if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                              object.point_to_attr = message.point_to_attr;
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              object.garbage_collect_data = message.garbage_collect_data;
                          return object;
                      };

                      /**
                       * Converts this PointerTensor to JSON.
                       * @function toJSON
                       * @memberof syft_proto.generic.pointers.v1.PointerTensor
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      PointerTensor.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return PointerTensor;
                  })();

                  v1.ObjectPointer = (function() {

                      /**
                       * Properties of an ObjectPointer.
                       * @memberof syft_proto.generic.pointers.v1
                       * @interface IObjectPointer
                       * @property {syft_proto.types.syft.v1.IId|null} [object_id] ObjectPointer object_id
                       * @property {syft_proto.types.syft.v1.IId|null} [location_id] ObjectPointer location_id
                       * @property {syft_proto.types.syft.v1.IId|null} [object_id_at_location] ObjectPointer object_id_at_location
                       * @property {string|null} [point_to_attr] ObjectPointer point_to_attr
                       */

                      /**
                       * Constructs a new ObjectPointer.
                       * @memberof syft_proto.generic.pointers.v1
                       * @classdesc Represents an ObjectPointer.
                       * @implements IObjectPointer
                       * @constructor
                       * @param {syft_proto.generic.pointers.v1.IObjectPointer=} [properties] Properties to set
                       */
                      function ObjectPointer(properties) {
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * ObjectPointer object_id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @instance
                       */
                      ObjectPointer.prototype.object_id = null;

                      /**
                       * ObjectPointer location_id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} location_id
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @instance
                       */
                      ObjectPointer.prototype.location_id = null;

                      /**
                       * ObjectPointer object_id_at_location.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id_at_location
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @instance
                       */
                      ObjectPointer.prototype.object_id_at_location = null;

                      /**
                       * ObjectPointer point_to_attr.
                       * @member {string} point_to_attr
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @instance
                       */
                      ObjectPointer.prototype.point_to_attr = "";

                      /**
                       * Creates a new ObjectPointer instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IObjectPointer=} [properties] Properties to set
                       * @returns {syft_proto.generic.pointers.v1.ObjectPointer} ObjectPointer instance
                       */
                      ObjectPointer.create = function create(properties) {
                          return new ObjectPointer(properties);
                      };

                      /**
                       * Encodes the specified ObjectPointer message. Does not implicitly {@link syft_proto.generic.pointers.v1.ObjectPointer.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IObjectPointer} message ObjectPointer message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      ObjectPointer.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.object_id != null && message.hasOwnProperty("object_id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          if (message.location_id != null && message.hasOwnProperty("location_id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.location_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.object_id_at_location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                          if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                              writer.uint32(/* id 4, wireType 2 =*/34).string(message.point_to_attr);
                          return writer;
                      };

                      /**
                       * Encodes the specified ObjectPointer message, length delimited. Does not implicitly {@link syft_proto.generic.pointers.v1.ObjectPointer.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IObjectPointer} message ObjectPointer message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      ObjectPointer.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes an ObjectPointer message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.generic.pointers.v1.ObjectPointer} ObjectPointer
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      ObjectPointer.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.generic.pointers.v1.ObjectPointer();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 2:
                                  message.location_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 3:
                                  message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 4:
                                  message.point_to_attr = reader.string();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes an ObjectPointer message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.generic.pointers.v1.ObjectPointer} ObjectPointer
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      ObjectPointer.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies an ObjectPointer message.
                       * @function verify
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      ObjectPointer.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.object_id != null && message.hasOwnProperty("object_id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                              if (error)
                                  return "object_id." + error;
                          }
                          if (message.location_id != null && message.hasOwnProperty("location_id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_id);
                              if (error)
                                  return "location_id." + error;
                          }
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id_at_location);
                              if (error)
                                  return "object_id_at_location." + error;
                          }
                          if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                              if (!$util.isString(message.point_to_attr))
                                  return "point_to_attr: string expected";
                          return null;
                      };

                      /**
                       * Creates an ObjectPointer message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.generic.pointers.v1.ObjectPointer} ObjectPointer
                       */
                      ObjectPointer.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.generic.pointers.v1.ObjectPointer)
                              return object;
                          var message = new $root.syft_proto.generic.pointers.v1.ObjectPointer();
                          if (object.object_id != null) {
                              if (typeof object.object_id !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.ObjectPointer.object_id: object expected");
                              message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                          }
                          if (object.location_id != null) {
                              if (typeof object.location_id !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.ObjectPointer.location_id: object expected");
                              message.location_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_id);
                          }
                          if (object.object_id_at_location != null) {
                              if (typeof object.object_id_at_location !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.ObjectPointer.object_id_at_location: object expected");
                              message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id_at_location);
                          }
                          if (object.point_to_attr != null)
                              message.point_to_attr = String(object.point_to_attr);
                          return message;
                      };

                      /**
                       * Creates a plain object from an ObjectPointer message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @static
                       * @param {syft_proto.generic.pointers.v1.ObjectPointer} message ObjectPointer
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      ObjectPointer.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.defaults) {
                              object.object_id = null;
                              object.location_id = null;
                              object.object_id_at_location = null;
                              object.point_to_attr = "";
                          }
                          if (message.object_id != null && message.hasOwnProperty("object_id"))
                              object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                          if (message.location_id != null && message.hasOwnProperty("location_id"))
                              object.location_id = $root.syft_proto.types.syft.v1.Id.toObject(message.location_id, options);
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                              object.object_id_at_location = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id_at_location, options);
                          if (message.point_to_attr != null && message.hasOwnProperty("point_to_attr"))
                              object.point_to_attr = message.point_to_attr;
                          return object;
                      };

                      /**
                       * Converts this ObjectPointer to JSON.
                       * @function toJSON
                       * @memberof syft_proto.generic.pointers.v1.ObjectPointer
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      ObjectPointer.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return ObjectPointer;
                  })();

                  v1.PointerDataset = (function() {

                      /**
                       * Properties of a PointerDataset.
                       * @memberof syft_proto.generic.pointers.v1
                       * @interface IPointerDataset
                       * @property {syft_proto.types.syft.v1.IId|null} [object_id] PointerDataset object_id
                       * @property {syft_proto.types.syft.v1.IId|null} [location_id] PointerDataset location_id
                       * @property {syft_proto.types.syft.v1.IId|null} [object_id_at_location] PointerDataset object_id_at_location
                       * @property {Array.<string>|null} [tags] PointerDataset tags
                       * @property {string|null} [description] PointerDataset description
                       * @property {boolean|null} [garbage_collect_data] PointerDataset garbage_collect_data
                       */

                      /**
                       * Constructs a new PointerDataset.
                       * @memberof syft_proto.generic.pointers.v1
                       * @classdesc Represents a PointerDataset.
                       * @implements IPointerDataset
                       * @constructor
                       * @param {syft_proto.generic.pointers.v1.IPointerDataset=} [properties] Properties to set
                       */
                      function PointerDataset(properties) {
                          this.tags = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * PointerDataset object_id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @instance
                       */
                      PointerDataset.prototype.object_id = null;

                      /**
                       * PointerDataset location_id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} location_id
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @instance
                       */
                      PointerDataset.prototype.location_id = null;

                      /**
                       * PointerDataset object_id_at_location.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id_at_location
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @instance
                       */
                      PointerDataset.prototype.object_id_at_location = null;

                      /**
                       * PointerDataset tags.
                       * @member {Array.<string>} tags
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @instance
                       */
                      PointerDataset.prototype.tags = $util.emptyArray;

                      /**
                       * PointerDataset description.
                       * @member {string} description
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @instance
                       */
                      PointerDataset.prototype.description = "";

                      /**
                       * PointerDataset garbage_collect_data.
                       * @member {boolean} garbage_collect_data
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @instance
                       */
                      PointerDataset.prototype.garbage_collect_data = false;

                      /**
                       * Creates a new PointerDataset instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerDataset=} [properties] Properties to set
                       * @returns {syft_proto.generic.pointers.v1.PointerDataset} PointerDataset instance
                       */
                      PointerDataset.create = function create(properties) {
                          return new PointerDataset(properties);
                      };

                      /**
                       * Encodes the specified PointerDataset message. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerDataset.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerDataset} message PointerDataset message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      PointerDataset.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.object_id != null && message.hasOwnProperty("object_id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          if (message.location_id != null && message.hasOwnProperty("location_id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.location_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.object_id_at_location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                          if (message.tags != null && message.tags.length)
                              for (var i = 0; i < message.tags.length; ++i)
                                  writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                          if (message.description != null && message.hasOwnProperty("description"))
                              writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              writer.uint32(/* id 6, wireType 0 =*/48).bool(message.garbage_collect_data);
                          return writer;
                      };

                      /**
                       * Encodes the specified PointerDataset message, length delimited. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerDataset.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerDataset} message PointerDataset message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      PointerDataset.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a PointerDataset message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.generic.pointers.v1.PointerDataset} PointerDataset
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      PointerDataset.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.generic.pointers.v1.PointerDataset();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 2:
                                  message.location_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 3:
                                  message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 4:
                                  if (!(message.tags && message.tags.length))
                                      message.tags = [];
                                  message.tags.push(reader.string());
                                  break;
                              case 5:
                                  message.description = reader.string();
                                  break;
                              case 6:
                                  message.garbage_collect_data = reader.bool();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a PointerDataset message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.generic.pointers.v1.PointerDataset} PointerDataset
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      PointerDataset.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a PointerDataset message.
                       * @function verify
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      PointerDataset.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.object_id != null && message.hasOwnProperty("object_id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                              if (error)
                                  return "object_id." + error;
                          }
                          if (message.location_id != null && message.hasOwnProperty("location_id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_id);
                              if (error)
                                  return "location_id." + error;
                          }
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id_at_location);
                              if (error)
                                  return "object_id_at_location." + error;
                          }
                          if (message.tags != null && message.hasOwnProperty("tags")) {
                              if (!Array.isArray(message.tags))
                                  return "tags: array expected";
                              for (var i = 0; i < message.tags.length; ++i)
                                  if (!$util.isString(message.tags[i]))
                                      return "tags: string[] expected";
                          }
                          if (message.description != null && message.hasOwnProperty("description"))
                              if (!$util.isString(message.description))
                                  return "description: string expected";
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              if (typeof message.garbage_collect_data !== "boolean")
                                  return "garbage_collect_data: boolean expected";
                          return null;
                      };

                      /**
                       * Creates a PointerDataset message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.generic.pointers.v1.PointerDataset} PointerDataset
                       */
                      PointerDataset.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.generic.pointers.v1.PointerDataset)
                              return object;
                          var message = new $root.syft_proto.generic.pointers.v1.PointerDataset();
                          if (object.object_id != null) {
                              if (typeof object.object_id !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerDataset.object_id: object expected");
                              message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                          }
                          if (object.location_id != null) {
                              if (typeof object.location_id !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerDataset.location_id: object expected");
                              message.location_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_id);
                          }
                          if (object.object_id_at_location != null) {
                              if (typeof object.object_id_at_location !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerDataset.object_id_at_location: object expected");
                              message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id_at_location);
                          }
                          if (object.tags) {
                              if (!Array.isArray(object.tags))
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerDataset.tags: array expected");
                              message.tags = [];
                              for (var i = 0; i < object.tags.length; ++i)
                                  message.tags[i] = String(object.tags[i]);
                          }
                          if (object.description != null)
                              message.description = String(object.description);
                          if (object.garbage_collect_data != null)
                              message.garbage_collect_data = Boolean(object.garbage_collect_data);
                          return message;
                      };

                      /**
                       * Creates a plain object from a PointerDataset message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @static
                       * @param {syft_proto.generic.pointers.v1.PointerDataset} message PointerDataset
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      PointerDataset.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults)
                              object.tags = [];
                          if (options.defaults) {
                              object.object_id = null;
                              object.location_id = null;
                              object.object_id_at_location = null;
                              object.description = "";
                              object.garbage_collect_data = false;
                          }
                          if (message.object_id != null && message.hasOwnProperty("object_id"))
                              object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                          if (message.location_id != null && message.hasOwnProperty("location_id"))
                              object.location_id = $root.syft_proto.types.syft.v1.Id.toObject(message.location_id, options);
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                              object.object_id_at_location = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id_at_location, options);
                          if (message.tags && message.tags.length) {
                              object.tags = [];
                              for (var j = 0; j < message.tags.length; ++j)
                                  object.tags[j] = message.tags[j];
                          }
                          if (message.description != null && message.hasOwnProperty("description"))
                              object.description = message.description;
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              object.garbage_collect_data = message.garbage_collect_data;
                          return object;
                      };

                      /**
                       * Converts this PointerDataset to JSON.
                       * @function toJSON
                       * @memberof syft_proto.generic.pointers.v1.PointerDataset
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      PointerDataset.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return PointerDataset;
                  })();

                  v1.PointerPlan = (function() {

                      /**
                       * Properties of a PointerPlan.
                       * @memberof syft_proto.generic.pointers.v1
                       * @interface IPointerPlan
                       * @property {syft_proto.types.syft.v1.IId|null} [object_id] PointerPlan object_id
                       * @property {syft_proto.types.syft.v1.IId|null} [location_id] PointerPlan location_id
                       * @property {syft_proto.types.syft.v1.IId|null} [object_id_at_location] PointerPlan object_id_at_location
                       * @property {Array.<string>|null} [tags] PointerPlan tags
                       * @property {boolean|null} [garbage_collect_data] PointerPlan garbage_collect_data
                       */

                      /**
                       * Constructs a new PointerPlan.
                       * @memberof syft_proto.generic.pointers.v1
                       * @classdesc Represents a PointerPlan.
                       * @implements IPointerPlan
                       * @constructor
                       * @param {syft_proto.generic.pointers.v1.IPointerPlan=} [properties] Properties to set
                       */
                      function PointerPlan(properties) {
                          this.tags = [];
                          if (properties)
                              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                  if (properties[keys[i]] != null)
                                      this[keys[i]] = properties[keys[i]];
                      }

                      /**
                       * PointerPlan object_id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @instance
                       */
                      PointerPlan.prototype.object_id = null;

                      /**
                       * PointerPlan location_id.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} location_id
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @instance
                       */
                      PointerPlan.prototype.location_id = null;

                      /**
                       * PointerPlan object_id_at_location.
                       * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id_at_location
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @instance
                       */
                      PointerPlan.prototype.object_id_at_location = null;

                      /**
                       * PointerPlan tags.
                       * @member {Array.<string>} tags
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @instance
                       */
                      PointerPlan.prototype.tags = $util.emptyArray;

                      /**
                       * PointerPlan garbage_collect_data.
                       * @member {boolean} garbage_collect_data
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @instance
                       */
                      PointerPlan.prototype.garbage_collect_data = false;

                      /**
                       * Creates a new PointerPlan instance using the specified properties.
                       * @function create
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerPlan=} [properties] Properties to set
                       * @returns {syft_proto.generic.pointers.v1.PointerPlan} PointerPlan instance
                       */
                      PointerPlan.create = function create(properties) {
                          return new PointerPlan(properties);
                      };

                      /**
                       * Encodes the specified PointerPlan message. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerPlan.verify|verify} messages.
                       * @function encode
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerPlan} message PointerPlan message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      PointerPlan.encode = function encode(message, writer) {
                          if (!writer)
                              writer = $Writer.create();
                          if (message.object_id != null && message.hasOwnProperty("object_id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                          if (message.location_id != null && message.hasOwnProperty("location_id"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.location_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                              $root.syft_proto.types.syft.v1.Id.encode(message.object_id_at_location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                          if (message.tags != null && message.tags.length)
                              for (var i = 0; i < message.tags.length; ++i)
                                  writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              writer.uint32(/* id 5, wireType 0 =*/40).bool(message.garbage_collect_data);
                          return writer;
                      };

                      /**
                       * Encodes the specified PointerPlan message, length delimited. Does not implicitly {@link syft_proto.generic.pointers.v1.PointerPlan.verify|verify} messages.
                       * @function encodeDelimited
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @static
                       * @param {syft_proto.generic.pointers.v1.IPointerPlan} message PointerPlan message or plain object to encode
                       * @param {$protobuf.Writer} [writer] Writer to encode to
                       * @returns {$protobuf.Writer} Writer
                       */
                      PointerPlan.encodeDelimited = function encodeDelimited(message, writer) {
                          return this.encode(message, writer).ldelim();
                      };

                      /**
                       * Decodes a PointerPlan message from the specified reader or buffer.
                       * @function decode
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @param {number} [length] Message length if known beforehand
                       * @returns {syft_proto.generic.pointers.v1.PointerPlan} PointerPlan
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      PointerPlan.decode = function decode(reader, length) {
                          if (!(reader instanceof $Reader))
                              reader = $Reader.create(reader);
                          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.generic.pointers.v1.PointerPlan();
                          while (reader.pos < end) {
                              var tag = reader.uint32();
                              switch (tag >>> 3) {
                              case 1:
                                  message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 2:
                                  message.location_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 3:
                                  message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                  break;
                              case 4:
                                  if (!(message.tags && message.tags.length))
                                      message.tags = [];
                                  message.tags.push(reader.string());
                                  break;
                              case 5:
                                  message.garbage_collect_data = reader.bool();
                                  break;
                              default:
                                  reader.skipType(tag & 7);
                                  break;
                              }
                          }
                          return message;
                      };

                      /**
                       * Decodes a PointerPlan message from the specified reader or buffer, length delimited.
                       * @function decodeDelimited
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @static
                       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                       * @returns {syft_proto.generic.pointers.v1.PointerPlan} PointerPlan
                       * @throws {Error} If the payload is not a reader or valid buffer
                       * @throws {$protobuf.util.ProtocolError} If required fields are missing
                       */
                      PointerPlan.decodeDelimited = function decodeDelimited(reader) {
                          if (!(reader instanceof $Reader))
                              reader = new $Reader(reader);
                          return this.decode(reader, reader.uint32());
                      };

                      /**
                       * Verifies a PointerPlan message.
                       * @function verify
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @static
                       * @param {Object.<string,*>} message Plain object to verify
                       * @returns {string|null} `null` if valid, otherwise the reason why it is not
                       */
                      PointerPlan.verify = function verify(message) {
                          if (typeof message !== "object" || message === null)
                              return "object expected";
                          if (message.object_id != null && message.hasOwnProperty("object_id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                              if (error)
                                  return "object_id." + error;
                          }
                          if (message.location_id != null && message.hasOwnProperty("location_id")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_id);
                              if (error)
                                  return "location_id." + error;
                          }
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location")) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id_at_location);
                              if (error)
                                  return "object_id_at_location." + error;
                          }
                          if (message.tags != null && message.hasOwnProperty("tags")) {
                              if (!Array.isArray(message.tags))
                                  return "tags: array expected";
                              for (var i = 0; i < message.tags.length; ++i)
                                  if (!$util.isString(message.tags[i]))
                                      return "tags: string[] expected";
                          }
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              if (typeof message.garbage_collect_data !== "boolean")
                                  return "garbage_collect_data: boolean expected";
                          return null;
                      };

                      /**
                       * Creates a PointerPlan message from a plain object. Also converts values to their respective internal types.
                       * @function fromObject
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @static
                       * @param {Object.<string,*>} object Plain object
                       * @returns {syft_proto.generic.pointers.v1.PointerPlan} PointerPlan
                       */
                      PointerPlan.fromObject = function fromObject(object) {
                          if (object instanceof $root.syft_proto.generic.pointers.v1.PointerPlan)
                              return object;
                          var message = new $root.syft_proto.generic.pointers.v1.PointerPlan();
                          if (object.object_id != null) {
                              if (typeof object.object_id !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerPlan.object_id: object expected");
                              message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                          }
                          if (object.location_id != null) {
                              if (typeof object.location_id !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerPlan.location_id: object expected");
                              message.location_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_id);
                          }
                          if (object.object_id_at_location != null) {
                              if (typeof object.object_id_at_location !== "object")
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerPlan.object_id_at_location: object expected");
                              message.object_id_at_location = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id_at_location);
                          }
                          if (object.tags) {
                              if (!Array.isArray(object.tags))
                                  throw TypeError(".syft_proto.generic.pointers.v1.PointerPlan.tags: array expected");
                              message.tags = [];
                              for (var i = 0; i < object.tags.length; ++i)
                                  message.tags[i] = String(object.tags[i]);
                          }
                          if (object.garbage_collect_data != null)
                              message.garbage_collect_data = Boolean(object.garbage_collect_data);
                          return message;
                      };

                      /**
                       * Creates a plain object from a PointerPlan message. Also converts values to other types if specified.
                       * @function toObject
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @static
                       * @param {syft_proto.generic.pointers.v1.PointerPlan} message PointerPlan
                       * @param {$protobuf.IConversionOptions} [options] Conversion options
                       * @returns {Object.<string,*>} Plain object
                       */
                      PointerPlan.toObject = function toObject(message, options) {
                          if (!options)
                              options = {};
                          var object = {};
                          if (options.arrays || options.defaults)
                              object.tags = [];
                          if (options.defaults) {
                              object.object_id = null;
                              object.location_id = null;
                              object.object_id_at_location = null;
                              object.garbage_collect_data = false;
                          }
                          if (message.object_id != null && message.hasOwnProperty("object_id"))
                              object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                          if (message.location_id != null && message.hasOwnProperty("location_id"))
                              object.location_id = $root.syft_proto.types.syft.v1.Id.toObject(message.location_id, options);
                          if (message.object_id_at_location != null && message.hasOwnProperty("object_id_at_location"))
                              object.object_id_at_location = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id_at_location, options);
                          if (message.tags && message.tags.length) {
                              object.tags = [];
                              for (var j = 0; j < message.tags.length; ++j)
                                  object.tags[j] = message.tags[j];
                          }
                          if (message.garbage_collect_data != null && message.hasOwnProperty("garbage_collect_data"))
                              object.garbage_collect_data = message.garbage_collect_data;
                          return object;
                      };

                      /**
                       * Converts this PointerPlan to JSON.
                       * @function toJSON
                       * @memberof syft_proto.generic.pointers.v1.PointerPlan
                       * @instance
                       * @returns {Object.<string,*>} JSON object
                       */
                      PointerPlan.prototype.toJSON = function toJSON() {
                          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                      };

                      return PointerPlan;
                  })();

                  return v1;
              })();

              return pointers;
          })();

          return generic;
      })();

      syft_proto.frameworks = (function() {

          /**
           * Namespace frameworks.
           * @memberof syft_proto
           * @namespace
           */
          var frameworks = {};

          frameworks.torch = (function() {

              /**
               * Namespace torch.
               * @memberof syft_proto.frameworks
               * @namespace
               */
              var torch = {};

              torch.fl = (function() {

                  /**
                   * Namespace fl.
                   * @memberof syft_proto.frameworks.torch
                   * @namespace
                   */
                  var fl = {};

                  fl.v1 = (function() {

                      /**
                       * Namespace v1.
                       * @memberof syft_proto.frameworks.torch.fl
                       * @namespace
                       */
                      var v1 = {};

                      v1.BaseDataset = (function() {

                          /**
                           * Properties of a BaseDataset.
                           * @memberof syft_proto.frameworks.torch.fl.v1
                           * @interface IBaseDataset
                           * @property {syft_proto.types.torch.v1.ITorchTensor|null} [data] BaseDataset data
                           * @property {syft_proto.types.torch.v1.ITorchTensor|null} [targets] BaseDataset targets
                           * @property {syft_proto.types.syft.v1.IId|null} [id] BaseDataset id
                           * @property {Array.<string>|null} [tags] BaseDataset tags
                           * @property {string|null} [description] BaseDataset description
                           * @property {syft_proto.types.torch.v1.ITorchTensor|null} [child] BaseDataset child
                           */

                          /**
                           * Constructs a new BaseDataset.
                           * @memberof syft_proto.frameworks.torch.fl.v1
                           * @classdesc Represents a BaseDataset.
                           * @implements IBaseDataset
                           * @constructor
                           * @param {syft_proto.frameworks.torch.fl.v1.IBaseDataset=} [properties] Properties to set
                           */
                          function BaseDataset(properties) {
                              this.tags = [];
                              if (properties)
                                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                      if (properties[keys[i]] != null)
                                          this[keys[i]] = properties[keys[i]];
                          }

                          /**
                           * BaseDataset data.
                           * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} data
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @instance
                           */
                          BaseDataset.prototype.data = null;

                          /**
                           * BaseDataset targets.
                           * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} targets
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @instance
                           */
                          BaseDataset.prototype.targets = null;

                          /**
                           * BaseDataset id.
                           * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @instance
                           */
                          BaseDataset.prototype.id = null;

                          /**
                           * BaseDataset tags.
                           * @member {Array.<string>} tags
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @instance
                           */
                          BaseDataset.prototype.tags = $util.emptyArray;

                          /**
                           * BaseDataset description.
                           * @member {string} description
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @instance
                           */
                          BaseDataset.prototype.description = "";

                          /**
                           * BaseDataset child.
                           * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} child
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @instance
                           */
                          BaseDataset.prototype.child = null;

                          /**
                           * Creates a new BaseDataset instance using the specified properties.
                           * @function create
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @static
                           * @param {syft_proto.frameworks.torch.fl.v1.IBaseDataset=} [properties] Properties to set
                           * @returns {syft_proto.frameworks.torch.fl.v1.BaseDataset} BaseDataset instance
                           */
                          BaseDataset.create = function create(properties) {
                              return new BaseDataset(properties);
                          };

                          /**
                           * Encodes the specified BaseDataset message. Does not implicitly {@link syft_proto.frameworks.torch.fl.v1.BaseDataset.verify|verify} messages.
                           * @function encode
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @static
                           * @param {syft_proto.frameworks.torch.fl.v1.IBaseDataset} message BaseDataset message or plain object to encode
                           * @param {$protobuf.Writer} [writer] Writer to encode to
                           * @returns {$protobuf.Writer} Writer
                           */
                          BaseDataset.encode = function encode(message, writer) {
                              if (!writer)
                                  writer = $Writer.create();
                              if (message.data != null && message.hasOwnProperty("data"))
                                  $root.syft_proto.types.torch.v1.TorchTensor.encode(message.data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                              if (message.targets != null && message.hasOwnProperty("targets"))
                                  $root.syft_proto.types.torch.v1.TorchTensor.encode(message.targets, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                              if (message.id != null && message.hasOwnProperty("id"))
                                  $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                              if (message.tags != null && message.tags.length)
                                  for (var i = 0; i < message.tags.length; ++i)
                                      writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                              if (message.description != null && message.hasOwnProperty("description"))
                                  writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                              if (message.child != null && message.hasOwnProperty("child"))
                                  $root.syft_proto.types.torch.v1.TorchTensor.encode(message.child, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                              return writer;
                          };

                          /**
                           * Encodes the specified BaseDataset message, length delimited. Does not implicitly {@link syft_proto.frameworks.torch.fl.v1.BaseDataset.verify|verify} messages.
                           * @function encodeDelimited
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @static
                           * @param {syft_proto.frameworks.torch.fl.v1.IBaseDataset} message BaseDataset message or plain object to encode
                           * @param {$protobuf.Writer} [writer] Writer to encode to
                           * @returns {$protobuf.Writer} Writer
                           */
                          BaseDataset.encodeDelimited = function encodeDelimited(message, writer) {
                              return this.encode(message, writer).ldelim();
                          };

                          /**
                           * Decodes a BaseDataset message from the specified reader or buffer.
                           * @function decode
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @static
                           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                           * @param {number} [length] Message length if known beforehand
                           * @returns {syft_proto.frameworks.torch.fl.v1.BaseDataset} BaseDataset
                           * @throws {Error} If the payload is not a reader or valid buffer
                           * @throws {$protobuf.util.ProtocolError} If required fields are missing
                           */
                          BaseDataset.decode = function decode(reader, length) {
                              if (!(reader instanceof $Reader))
                                  reader = $Reader.create(reader);
                              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.frameworks.torch.fl.v1.BaseDataset();
                              while (reader.pos < end) {
                                  var tag = reader.uint32();
                                  switch (tag >>> 3) {
                                  case 1:
                                      message.data = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                      break;
                                  case 2:
                                      message.targets = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                      break;
                                  case 3:
                                      message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                      break;
                                  case 4:
                                      if (!(message.tags && message.tags.length))
                                          message.tags = [];
                                      message.tags.push(reader.string());
                                      break;
                                  case 5:
                                      message.description = reader.string();
                                      break;
                                  case 6:
                                      message.child = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                                      break;
                                  default:
                                      reader.skipType(tag & 7);
                                      break;
                                  }
                              }
                              return message;
                          };

                          /**
                           * Decodes a BaseDataset message from the specified reader or buffer, length delimited.
                           * @function decodeDelimited
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @static
                           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                           * @returns {syft_proto.frameworks.torch.fl.v1.BaseDataset} BaseDataset
                           * @throws {Error} If the payload is not a reader or valid buffer
                           * @throws {$protobuf.util.ProtocolError} If required fields are missing
                           */
                          BaseDataset.decodeDelimited = function decodeDelimited(reader) {
                              if (!(reader instanceof $Reader))
                                  reader = new $Reader(reader);
                              return this.decode(reader, reader.uint32());
                          };

                          /**
                           * Verifies a BaseDataset message.
                           * @function verify
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @static
                           * @param {Object.<string,*>} message Plain object to verify
                           * @returns {string|null} `null` if valid, otherwise the reason why it is not
                           */
                          BaseDataset.verify = function verify(message) {
                              if (typeof message !== "object" || message === null)
                                  return "object expected";
                              if (message.data != null && message.hasOwnProperty("data")) {
                                  var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.data);
                                  if (error)
                                      return "data." + error;
                              }
                              if (message.targets != null && message.hasOwnProperty("targets")) {
                                  var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.targets);
                                  if (error)
                                      return "targets." + error;
                              }
                              if (message.id != null && message.hasOwnProperty("id")) {
                                  var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                                  if (error)
                                      return "id." + error;
                              }
                              if (message.tags != null && message.hasOwnProperty("tags")) {
                                  if (!Array.isArray(message.tags))
                                      return "tags: array expected";
                                  for (var i = 0; i < message.tags.length; ++i)
                                      if (!$util.isString(message.tags[i]))
                                          return "tags: string[] expected";
                              }
                              if (message.description != null && message.hasOwnProperty("description"))
                                  if (!$util.isString(message.description))
                                      return "description: string expected";
                              if (message.child != null && message.hasOwnProperty("child")) {
                                  var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.child);
                                  if (error)
                                      return "child." + error;
                              }
                              return null;
                          };

                          /**
                           * Creates a BaseDataset message from a plain object. Also converts values to their respective internal types.
                           * @function fromObject
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @static
                           * @param {Object.<string,*>} object Plain object
                           * @returns {syft_proto.frameworks.torch.fl.v1.BaseDataset} BaseDataset
                           */
                          BaseDataset.fromObject = function fromObject(object) {
                              if (object instanceof $root.syft_proto.frameworks.torch.fl.v1.BaseDataset)
                                  return object;
                              var message = new $root.syft_proto.frameworks.torch.fl.v1.BaseDataset();
                              if (object.data != null) {
                                  if (typeof object.data !== "object")
                                      throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.data: object expected");
                                  message.data = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.data);
                              }
                              if (object.targets != null) {
                                  if (typeof object.targets !== "object")
                                      throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.targets: object expected");
                                  message.targets = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.targets);
                              }
                              if (object.id != null) {
                                  if (typeof object.id !== "object")
                                      throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.id: object expected");
                                  message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                              }
                              if (object.tags) {
                                  if (!Array.isArray(object.tags))
                                      throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.tags: array expected");
                                  message.tags = [];
                                  for (var i = 0; i < object.tags.length; ++i)
                                      message.tags[i] = String(object.tags[i]);
                              }
                              if (object.description != null)
                                  message.description = String(object.description);
                              if (object.child != null) {
                                  if (typeof object.child !== "object")
                                      throw TypeError(".syft_proto.frameworks.torch.fl.v1.BaseDataset.child: object expected");
                                  message.child = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.child);
                              }
                              return message;
                          };

                          /**
                           * Creates a plain object from a BaseDataset message. Also converts values to other types if specified.
                           * @function toObject
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @static
                           * @param {syft_proto.frameworks.torch.fl.v1.BaseDataset} message BaseDataset
                           * @param {$protobuf.IConversionOptions} [options] Conversion options
                           * @returns {Object.<string,*>} Plain object
                           */
                          BaseDataset.toObject = function toObject(message, options) {
                              if (!options)
                                  options = {};
                              var object = {};
                              if (options.arrays || options.defaults)
                                  object.tags = [];
                              if (options.defaults) {
                                  object.data = null;
                                  object.targets = null;
                                  object.id = null;
                                  object.description = "";
                                  object.child = null;
                              }
                              if (message.data != null && message.hasOwnProperty("data"))
                                  object.data = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.data, options);
                              if (message.targets != null && message.hasOwnProperty("targets"))
                                  object.targets = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.targets, options);
                              if (message.id != null && message.hasOwnProperty("id"))
                                  object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                              if (message.tags && message.tags.length) {
                                  object.tags = [];
                                  for (var j = 0; j < message.tags.length; ++j)
                                      object.tags[j] = message.tags[j];
                              }
                              if (message.description != null && message.hasOwnProperty("description"))
                                  object.description = message.description;
                              if (message.child != null && message.hasOwnProperty("child"))
                                  object.child = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.child, options);
                              return object;
                          };

                          /**
                           * Converts this BaseDataset to JSON.
                           * @function toJSON
                           * @memberof syft_proto.frameworks.torch.fl.v1.BaseDataset
                           * @instance
                           * @returns {Object.<string,*>} JSON object
                           */
                          BaseDataset.prototype.toJSON = function toJSON() {
                              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                          };

                          return BaseDataset;
                      })();

                      return v1;
                  })();

                  return fl;
              })();

              torch.tensors = (function() {

                  /**
                   * Namespace tensors.
                   * @memberof syft_proto.frameworks.torch
                   * @namespace
                   */
                  var tensors = {};

                  tensors.interpreters = (function() {

                      /**
                       * Namespace interpreters.
                       * @memberof syft_proto.frameworks.torch.tensors
                       * @namespace
                       */
                      var interpreters = {};

                      interpreters.v1 = (function() {

                          /**
                           * Namespace v1.
                           * @memberof syft_proto.frameworks.torch.tensors.interpreters
                           * @namespace
                           */
                          var v1 = {};

                          v1.AdditiveSharingTensor = (function() {

                              /**
                               * Properties of an AdditiveSharingTensor.
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1
                               * @interface IAdditiveSharingTensor
                               * @property {syft_proto.types.syft.v1.IId|null} [id] AdditiveSharingTensor id
                               * @property {number|Long|null} [field_int] AdditiveSharingTensor field_int
                               * @property {string|null} [field_str] AdditiveSharingTensor field_str
                               * @property {string|null} [dtype] AdditiveSharingTensor dtype
                               * @property {syft_proto.types.syft.v1.IId|null} [crypto_provider_id] AdditiveSharingTensor crypto_provider_id
                               * @property {Array.<syft_proto.types.syft.v1.IId>|null} [location_ids] AdditiveSharingTensor location_ids
                               * @property {Array.<syft_proto.generic.pointers.v1.IPointerTensor>|null} [shares] AdditiveSharingTensor shares
                               */

                              /**
                               * Constructs a new AdditiveSharingTensor.
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1
                               * @classdesc Represents an AdditiveSharingTensor.
                               * @implements IAdditiveSharingTensor
                               * @constructor
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor=} [properties] Properties to set
                               */
                              function AdditiveSharingTensor(properties) {
                                  this.location_ids = [];
                                  this.shares = [];
                                  if (properties)
                                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                          if (properties[keys[i]] != null)
                                              this[keys[i]] = properties[keys[i]];
                              }

                              /**
                               * AdditiveSharingTensor id.
                               * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               */
                              AdditiveSharingTensor.prototype.id = null;

                              /**
                               * AdditiveSharingTensor field_int.
                               * @member {number|Long} field_int
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               */
                              AdditiveSharingTensor.prototype.field_int = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                              /**
                               * AdditiveSharingTensor field_str.
                               * @member {string} field_str
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               */
                              AdditiveSharingTensor.prototype.field_str = "";

                              /**
                               * AdditiveSharingTensor dtype.
                               * @member {string} dtype
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               */
                              AdditiveSharingTensor.prototype.dtype = "";

                              /**
                               * AdditiveSharingTensor crypto_provider_id.
                               * @member {syft_proto.types.syft.v1.IId|null|undefined} crypto_provider_id
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               */
                              AdditiveSharingTensor.prototype.crypto_provider_id = null;

                              /**
                               * AdditiveSharingTensor location_ids.
                               * @member {Array.<syft_proto.types.syft.v1.IId>} location_ids
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               */
                              AdditiveSharingTensor.prototype.location_ids = $util.emptyArray;

                              /**
                               * AdditiveSharingTensor shares.
                               * @member {Array.<syft_proto.generic.pointers.v1.IPointerTensor>} shares
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               */
                              AdditiveSharingTensor.prototype.shares = $util.emptyArray;

                              // OneOf field names bound to virtual getters and setters
                              var $oneOfFields;

                              /**
                               * AdditiveSharingTensor field_size.
                               * @member {"field_int"|"field_str"|undefined} field_size
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               */
                              Object.defineProperty(AdditiveSharingTensor.prototype, "field_size", {
                                  get: $util.oneOfGetter($oneOfFields = ["field_int", "field_str"]),
                                  set: $util.oneOfSetter($oneOfFields)
                              });

                              /**
                               * Creates a new AdditiveSharingTensor instance using the specified properties.
                               * @function create
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @static
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor=} [properties] Properties to set
                               * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} AdditiveSharingTensor instance
                               */
                              AdditiveSharingTensor.create = function create(properties) {
                                  return new AdditiveSharingTensor(properties);
                              };

                              /**
                               * Encodes the specified AdditiveSharingTensor message. Does not implicitly {@link syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.verify|verify} messages.
                               * @function encode
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @static
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor} message AdditiveSharingTensor message or plain object to encode
                               * @param {$protobuf.Writer} [writer] Writer to encode to
                               * @returns {$protobuf.Writer} Writer
                               */
                              AdditiveSharingTensor.encode = function encode(message, writer) {
                                  if (!writer)
                                      writer = $Writer.create();
                                  if (message.id != null && message.hasOwnProperty("id"))
                                      $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                  if (message.field_int != null && message.hasOwnProperty("field_int"))
                                      writer.uint32(/* id 2, wireType 0 =*/16).int64(message.field_int);
                                  if (message.field_str != null && message.hasOwnProperty("field_str"))
                                      writer.uint32(/* id 3, wireType 2 =*/26).string(message.field_str);
                                  if (message.dtype != null && message.hasOwnProperty("dtype"))
                                      writer.uint32(/* id 4, wireType 2 =*/34).string(message.dtype);
                                  if (message.crypto_provider_id != null && message.hasOwnProperty("crypto_provider_id"))
                                      $root.syft_proto.types.syft.v1.Id.encode(message.crypto_provider_id, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                                  if (message.location_ids != null && message.location_ids.length)
                                      for (var i = 0; i < message.location_ids.length; ++i)
                                          $root.syft_proto.types.syft.v1.Id.encode(message.location_ids[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                                  if (message.shares != null && message.shares.length)
                                      for (var i = 0; i < message.shares.length; ++i)
                                          $root.syft_proto.generic.pointers.v1.PointerTensor.encode(message.shares[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                                  return writer;
                              };

                              /**
                               * Encodes the specified AdditiveSharingTensor message, length delimited. Does not implicitly {@link syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.verify|verify} messages.
                               * @function encodeDelimited
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @static
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor} message AdditiveSharingTensor message or plain object to encode
                               * @param {$protobuf.Writer} [writer] Writer to encode to
                               * @returns {$protobuf.Writer} Writer
                               */
                              AdditiveSharingTensor.encodeDelimited = function encodeDelimited(message, writer) {
                                  return this.encode(message, writer).ldelim();
                              };

                              /**
                               * Decodes an AdditiveSharingTensor message from the specified reader or buffer.
                               * @function decode
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @static
                               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                               * @param {number} [length] Message length if known beforehand
                               * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} AdditiveSharingTensor
                               * @throws {Error} If the payload is not a reader or valid buffer
                               * @throws {$protobuf.util.ProtocolError} If required fields are missing
                               */
                              AdditiveSharingTensor.decode = function decode(reader, length) {
                                  if (!(reader instanceof $Reader))
                                      reader = $Reader.create(reader);
                                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor();
                                  while (reader.pos < end) {
                                      var tag = reader.uint32();
                                      switch (tag >>> 3) {
                                      case 1:
                                          message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                          break;
                                      case 2:
                                          message.field_int = reader.int64();
                                          break;
                                      case 3:
                                          message.field_str = reader.string();
                                          break;
                                      case 4:
                                          message.dtype = reader.string();
                                          break;
                                      case 5:
                                          message.crypto_provider_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                          break;
                                      case 6:
                                          if (!(message.location_ids && message.location_ids.length))
                                              message.location_ids = [];
                                          message.location_ids.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                                          break;
                                      case 7:
                                          if (!(message.shares && message.shares.length))
                                              message.shares = [];
                                          message.shares.push($root.syft_proto.generic.pointers.v1.PointerTensor.decode(reader, reader.uint32()));
                                          break;
                                      default:
                                          reader.skipType(tag & 7);
                                          break;
                                      }
                                  }
                                  return message;
                              };

                              /**
                               * Decodes an AdditiveSharingTensor message from the specified reader or buffer, length delimited.
                               * @function decodeDelimited
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @static
                               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                               * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} AdditiveSharingTensor
                               * @throws {Error} If the payload is not a reader or valid buffer
                               * @throws {$protobuf.util.ProtocolError} If required fields are missing
                               */
                              AdditiveSharingTensor.decodeDelimited = function decodeDelimited(reader) {
                                  if (!(reader instanceof $Reader))
                                      reader = new $Reader(reader);
                                  return this.decode(reader, reader.uint32());
                              };

                              /**
                               * Verifies an AdditiveSharingTensor message.
                               * @function verify
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @static
                               * @param {Object.<string,*>} message Plain object to verify
                               * @returns {string|null} `null` if valid, otherwise the reason why it is not
                               */
                              AdditiveSharingTensor.verify = function verify(message) {
                                  if (typeof message !== "object" || message === null)
                                      return "object expected";
                                  var properties = {};
                                  if (message.id != null && message.hasOwnProperty("id")) {
                                      var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                                      if (error)
                                          return "id." + error;
                                  }
                                  if (message.field_int != null && message.hasOwnProperty("field_int")) {
                                      properties.field_size = 1;
                                      if (!$util.isInteger(message.field_int) && !(message.field_int && $util.isInteger(message.field_int.low) && $util.isInteger(message.field_int.high)))
                                          return "field_int: integer|Long expected";
                                  }
                                  if (message.field_str != null && message.hasOwnProperty("field_str")) {
                                      if (properties.field_size === 1)
                                          return "field_size: multiple values";
                                      properties.field_size = 1;
                                      if (!$util.isString(message.field_str))
                                          return "field_str: string expected";
                                  }
                                  if (message.dtype != null && message.hasOwnProperty("dtype"))
                                      if (!$util.isString(message.dtype))
                                          return "dtype: string expected";
                                  if (message.crypto_provider_id != null && message.hasOwnProperty("crypto_provider_id")) {
                                      var error = $root.syft_proto.types.syft.v1.Id.verify(message.crypto_provider_id);
                                      if (error)
                                          return "crypto_provider_id." + error;
                                  }
                                  if (message.location_ids != null && message.hasOwnProperty("location_ids")) {
                                      if (!Array.isArray(message.location_ids))
                                          return "location_ids: array expected";
                                      for (var i = 0; i < message.location_ids.length; ++i) {
                                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.location_ids[i]);
                                          if (error)
                                              return "location_ids." + error;
                                      }
                                  }
                                  if (message.shares != null && message.hasOwnProperty("shares")) {
                                      if (!Array.isArray(message.shares))
                                          return "shares: array expected";
                                      for (var i = 0; i < message.shares.length; ++i) {
                                          var error = $root.syft_proto.generic.pointers.v1.PointerTensor.verify(message.shares[i]);
                                          if (error)
                                              return "shares." + error;
                                      }
                                  }
                                  return null;
                              };

                              /**
                               * Creates an AdditiveSharingTensor message from a plain object. Also converts values to their respective internal types.
                               * @function fromObject
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @static
                               * @param {Object.<string,*>} object Plain object
                               * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} AdditiveSharingTensor
                               */
                              AdditiveSharingTensor.fromObject = function fromObject(object) {
                                  if (object instanceof $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor)
                                      return object;
                                  var message = new $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor();
                                  if (object.id != null) {
                                      if (typeof object.id !== "object")
                                          throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.id: object expected");
                                      message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                                  }
                                  if (object.field_int != null)
                                      if ($util.Long)
                                          (message.field_int = $util.Long.fromValue(object.field_int)).unsigned = false;
                                      else if (typeof object.field_int === "string")
                                          message.field_int = parseInt(object.field_int, 10);
                                      else if (typeof object.field_int === "number")
                                          message.field_int = object.field_int;
                                      else if (typeof object.field_int === "object")
                                          message.field_int = new $util.LongBits(object.field_int.low >>> 0, object.field_int.high >>> 0).toNumber();
                                  if (object.field_str != null)
                                      message.field_str = String(object.field_str);
                                  if (object.dtype != null)
                                      message.dtype = String(object.dtype);
                                  if (object.crypto_provider_id != null) {
                                      if (typeof object.crypto_provider_id !== "object")
                                          throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.crypto_provider_id: object expected");
                                      message.crypto_provider_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.crypto_provider_id);
                                  }
                                  if (object.location_ids) {
                                      if (!Array.isArray(object.location_ids))
                                          throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.location_ids: array expected");
                                      message.location_ids = [];
                                      for (var i = 0; i < object.location_ids.length; ++i) {
                                          if (typeof object.location_ids[i] !== "object")
                                              throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.location_ids: object expected");
                                          message.location_ids[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.location_ids[i]);
                                      }
                                  }
                                  if (object.shares) {
                                      if (!Array.isArray(object.shares))
                                          throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.shares: array expected");
                                      message.shares = [];
                                      for (var i = 0; i < object.shares.length; ++i) {
                                          if (typeof object.shares[i] !== "object")
                                              throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.shares: object expected");
                                          message.shares[i] = $root.syft_proto.generic.pointers.v1.PointerTensor.fromObject(object.shares[i]);
                                      }
                                  }
                                  return message;
                              };

                              /**
                               * Creates a plain object from an AdditiveSharingTensor message. Also converts values to other types if specified.
                               * @function toObject
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @static
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor} message AdditiveSharingTensor
                               * @param {$protobuf.IConversionOptions} [options] Conversion options
                               * @returns {Object.<string,*>} Plain object
                               */
                              AdditiveSharingTensor.toObject = function toObject(message, options) {
                                  if (!options)
                                      options = {};
                                  var object = {};
                                  if (options.arrays || options.defaults) {
                                      object.location_ids = [];
                                      object.shares = [];
                                  }
                                  if (options.defaults) {
                                      object.id = null;
                                      object.dtype = "";
                                      object.crypto_provider_id = null;
                                  }
                                  if (message.id != null && message.hasOwnProperty("id"))
                                      object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                                  if (message.field_int != null && message.hasOwnProperty("field_int")) {
                                      if (typeof message.field_int === "number")
                                          object.field_int = options.longs === String ? String(message.field_int) : message.field_int;
                                      else
                                          object.field_int = options.longs === String ? $util.Long.prototype.toString.call(message.field_int) : options.longs === Number ? new $util.LongBits(message.field_int.low >>> 0, message.field_int.high >>> 0).toNumber() : message.field_int;
                                      if (options.oneofs)
                                          object.field_size = "field_int";
                                  }
                                  if (message.field_str != null && message.hasOwnProperty("field_str")) {
                                      object.field_str = message.field_str;
                                      if (options.oneofs)
                                          object.field_size = "field_str";
                                  }
                                  if (message.dtype != null && message.hasOwnProperty("dtype"))
                                      object.dtype = message.dtype;
                                  if (message.crypto_provider_id != null && message.hasOwnProperty("crypto_provider_id"))
                                      object.crypto_provider_id = $root.syft_proto.types.syft.v1.Id.toObject(message.crypto_provider_id, options);
                                  if (message.location_ids && message.location_ids.length) {
                                      object.location_ids = [];
                                      for (var j = 0; j < message.location_ids.length; ++j)
                                          object.location_ids[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.location_ids[j], options);
                                  }
                                  if (message.shares && message.shares.length) {
                                      object.shares = [];
                                      for (var j = 0; j < message.shares.length; ++j)
                                          object.shares[j] = $root.syft_proto.generic.pointers.v1.PointerTensor.toObject(message.shares[j], options);
                                  }
                                  return object;
                              };

                              /**
                               * Converts this AdditiveSharingTensor to JSON.
                               * @function toJSON
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor
                               * @instance
                               * @returns {Object.<string,*>} JSON object
                               */
                              AdditiveSharingTensor.prototype.toJSON = function toJSON() {
                                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                              };

                              return AdditiveSharingTensor;
                          })();

                          v1.FixedPrecisionTensor = (function() {

                              /**
                               * Properties of a FixedPrecisionTensor.
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1
                               * @interface IFixedPrecisionTensor
                               * @property {syft_proto.types.syft.v1.IId|null} [id] FixedPrecisionTensor id
                               * @property {string|null} [field] FixedPrecisionTensor field
                               * @property {string|null} [dtype] FixedPrecisionTensor dtype
                               * @property {number|null} [base] FixedPrecisionTensor base
                               * @property {number|null} [kappa] FixedPrecisionTensor kappa
                               * @property {number|null} [precision_fractional] FixedPrecisionTensor precision_fractional
                               * @property {Array.<string>|null} [tags] FixedPrecisionTensor tags
                               * @property {string|null} [description] FixedPrecisionTensor description
                               * @property {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor|null} [child] FixedPrecisionTensor child
                               */

                              /**
                               * Constructs a new FixedPrecisionTensor.
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1
                               * @classdesc Represents a FixedPrecisionTensor.
                               * @implements IFixedPrecisionTensor
                               * @constructor
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IFixedPrecisionTensor=} [properties] Properties to set
                               */
                              function FixedPrecisionTensor(properties) {
                                  this.tags = [];
                                  if (properties)
                                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                          if (properties[keys[i]] != null)
                                              this[keys[i]] = properties[keys[i]];
                              }

                              /**
                               * FixedPrecisionTensor id.
                               * @member {syft_proto.types.syft.v1.IId|null|undefined} id
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.id = null;

                              /**
                               * FixedPrecisionTensor field.
                               * @member {string} field
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.field = "";

                              /**
                               * FixedPrecisionTensor dtype.
                               * @member {string} dtype
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.dtype = "";

                              /**
                               * FixedPrecisionTensor base.
                               * @member {number} base
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.base = 0;

                              /**
                               * FixedPrecisionTensor kappa.
                               * @member {number} kappa
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.kappa = 0;

                              /**
                               * FixedPrecisionTensor precision_fractional.
                               * @member {number} precision_fractional
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.precision_fractional = 0;

                              /**
                               * FixedPrecisionTensor tags.
                               * @member {Array.<string>} tags
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.tags = $util.emptyArray;

                              /**
                               * FixedPrecisionTensor description.
                               * @member {string} description
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.description = "";

                              /**
                               * FixedPrecisionTensor child.
                               * @member {syft_proto.frameworks.torch.tensors.interpreters.v1.IAdditiveSharingTensor|null|undefined} child
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               */
                              FixedPrecisionTensor.prototype.child = null;

                              /**
                               * Creates a new FixedPrecisionTensor instance using the specified properties.
                               * @function create
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @static
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IFixedPrecisionTensor=} [properties] Properties to set
                               * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} FixedPrecisionTensor instance
                               */
                              FixedPrecisionTensor.create = function create(properties) {
                                  return new FixedPrecisionTensor(properties);
                              };

                              /**
                               * Encodes the specified FixedPrecisionTensor message. Does not implicitly {@link syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.verify|verify} messages.
                               * @function encode
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @static
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IFixedPrecisionTensor} message FixedPrecisionTensor message or plain object to encode
                               * @param {$protobuf.Writer} [writer] Writer to encode to
                               * @returns {$protobuf.Writer} Writer
                               */
                              FixedPrecisionTensor.encode = function encode(message, writer) {
                                  if (!writer)
                                      writer = $Writer.create();
                                  if (message.id != null && message.hasOwnProperty("id"))
                                      $root.syft_proto.types.syft.v1.Id.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                  if (message.field != null && message.hasOwnProperty("field"))
                                      writer.uint32(/* id 3, wireType 2 =*/26).string(message.field);
                                  if (message.dtype != null && message.hasOwnProperty("dtype"))
                                      writer.uint32(/* id 4, wireType 2 =*/34).string(message.dtype);
                                  if (message.base != null && message.hasOwnProperty("base"))
                                      writer.uint32(/* id 5, wireType 0 =*/40).int32(message.base);
                                  if (message.kappa != null && message.hasOwnProperty("kappa"))
                                      writer.uint32(/* id 6, wireType 0 =*/48).int32(message.kappa);
                                  if (message.precision_fractional != null && message.hasOwnProperty("precision_fractional"))
                                      writer.uint32(/* id 7, wireType 0 =*/56).int32(message.precision_fractional);
                                  if (message.tags != null && message.tags.length)
                                      for (var i = 0; i < message.tags.length; ++i)
                                          writer.uint32(/* id 8, wireType 2 =*/66).string(message.tags[i]);
                                  if (message.description != null && message.hasOwnProperty("description"))
                                      writer.uint32(/* id 9, wireType 2 =*/74).string(message.description);
                                  if (message.child != null && message.hasOwnProperty("child"))
                                      $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.encode(message.child, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                                  return writer;
                              };

                              /**
                               * Encodes the specified FixedPrecisionTensor message, length delimited. Does not implicitly {@link syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.verify|verify} messages.
                               * @function encodeDelimited
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @static
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.IFixedPrecisionTensor} message FixedPrecisionTensor message or plain object to encode
                               * @param {$protobuf.Writer} [writer] Writer to encode to
                               * @returns {$protobuf.Writer} Writer
                               */
                              FixedPrecisionTensor.encodeDelimited = function encodeDelimited(message, writer) {
                                  return this.encode(message, writer).ldelim();
                              };

                              /**
                               * Decodes a FixedPrecisionTensor message from the specified reader or buffer.
                               * @function decode
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @static
                               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                               * @param {number} [length] Message length if known beforehand
                               * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} FixedPrecisionTensor
                               * @throws {Error} If the payload is not a reader or valid buffer
                               * @throws {$protobuf.util.ProtocolError} If required fields are missing
                               */
                              FixedPrecisionTensor.decode = function decode(reader, length) {
                                  if (!(reader instanceof $Reader))
                                      reader = $Reader.create(reader);
                                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor();
                                  while (reader.pos < end) {
                                      var tag = reader.uint32();
                                      switch (tag >>> 3) {
                                      case 1:
                                          message.id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                                          break;
                                      case 3:
                                          message.field = reader.string();
                                          break;
                                      case 4:
                                          message.dtype = reader.string();
                                          break;
                                      case 5:
                                          message.base = reader.int32();
                                          break;
                                      case 6:
                                          message.kappa = reader.int32();
                                          break;
                                      case 7:
                                          message.precision_fractional = reader.int32();
                                          break;
                                      case 8:
                                          if (!(message.tags && message.tags.length))
                                              message.tags = [];
                                          message.tags.push(reader.string());
                                          break;
                                      case 9:
                                          message.description = reader.string();
                                          break;
                                      case 10:
                                          message.child = $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.decode(reader, reader.uint32());
                                          break;
                                      default:
                                          reader.skipType(tag & 7);
                                          break;
                                      }
                                  }
                                  return message;
                              };

                              /**
                               * Decodes a FixedPrecisionTensor message from the specified reader or buffer, length delimited.
                               * @function decodeDelimited
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @static
                               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                               * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} FixedPrecisionTensor
                               * @throws {Error} If the payload is not a reader or valid buffer
                               * @throws {$protobuf.util.ProtocolError} If required fields are missing
                               */
                              FixedPrecisionTensor.decodeDelimited = function decodeDelimited(reader) {
                                  if (!(reader instanceof $Reader))
                                      reader = new $Reader(reader);
                                  return this.decode(reader, reader.uint32());
                              };

                              /**
                               * Verifies a FixedPrecisionTensor message.
                               * @function verify
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @static
                               * @param {Object.<string,*>} message Plain object to verify
                               * @returns {string|null} `null` if valid, otherwise the reason why it is not
                               */
                              FixedPrecisionTensor.verify = function verify(message) {
                                  if (typeof message !== "object" || message === null)
                                      return "object expected";
                                  if (message.id != null && message.hasOwnProperty("id")) {
                                      var error = $root.syft_proto.types.syft.v1.Id.verify(message.id);
                                      if (error)
                                          return "id." + error;
                                  }
                                  if (message.field != null && message.hasOwnProperty("field"))
                                      if (!$util.isString(message.field))
                                          return "field: string expected";
                                  if (message.dtype != null && message.hasOwnProperty("dtype"))
                                      if (!$util.isString(message.dtype))
                                          return "dtype: string expected";
                                  if (message.base != null && message.hasOwnProperty("base"))
                                      if (!$util.isInteger(message.base))
                                          return "base: integer expected";
                                  if (message.kappa != null && message.hasOwnProperty("kappa"))
                                      if (!$util.isInteger(message.kappa))
                                          return "kappa: integer expected";
                                  if (message.precision_fractional != null && message.hasOwnProperty("precision_fractional"))
                                      if (!$util.isInteger(message.precision_fractional))
                                          return "precision_fractional: integer expected";
                                  if (message.tags != null && message.hasOwnProperty("tags")) {
                                      if (!Array.isArray(message.tags))
                                          return "tags: array expected";
                                      for (var i = 0; i < message.tags.length; ++i)
                                          if (!$util.isString(message.tags[i]))
                                              return "tags: string[] expected";
                                  }
                                  if (message.description != null && message.hasOwnProperty("description"))
                                      if (!$util.isString(message.description))
                                          return "description: string expected";
                                  if (message.child != null && message.hasOwnProperty("child")) {
                                      var error = $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.verify(message.child);
                                      if (error)
                                          return "child." + error;
                                  }
                                  return null;
                              };

                              /**
                               * Creates a FixedPrecisionTensor message from a plain object. Also converts values to their respective internal types.
                               * @function fromObject
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @static
                               * @param {Object.<string,*>} object Plain object
                               * @returns {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} FixedPrecisionTensor
                               */
                              FixedPrecisionTensor.fromObject = function fromObject(object) {
                                  if (object instanceof $root.syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor)
                                      return object;
                                  var message = new $root.syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor();
                                  if (object.id != null) {
                                      if (typeof object.id !== "object")
                                          throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.id: object expected");
                                      message.id = $root.syft_proto.types.syft.v1.Id.fromObject(object.id);
                                  }
                                  if (object.field != null)
                                      message.field = String(object.field);
                                  if (object.dtype != null)
                                      message.dtype = String(object.dtype);
                                  if (object.base != null)
                                      message.base = object.base | 0;
                                  if (object.kappa != null)
                                      message.kappa = object.kappa | 0;
                                  if (object.precision_fractional != null)
                                      message.precision_fractional = object.precision_fractional | 0;
                                  if (object.tags) {
                                      if (!Array.isArray(object.tags))
                                          throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.tags: array expected");
                                      message.tags = [];
                                      for (var i = 0; i < object.tags.length; ++i)
                                          message.tags[i] = String(object.tags[i]);
                                  }
                                  if (object.description != null)
                                      message.description = String(object.description);
                                  if (object.child != null) {
                                      if (typeof object.child !== "object")
                                          throw TypeError(".syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor.child: object expected");
                                      message.child = $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.fromObject(object.child);
                                  }
                                  return message;
                              };

                              /**
                               * Creates a plain object from a FixedPrecisionTensor message. Also converts values to other types if specified.
                               * @function toObject
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @static
                               * @param {syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor} message FixedPrecisionTensor
                               * @param {$protobuf.IConversionOptions} [options] Conversion options
                               * @returns {Object.<string,*>} Plain object
                               */
                              FixedPrecisionTensor.toObject = function toObject(message, options) {
                                  if (!options)
                                      options = {};
                                  var object = {};
                                  if (options.arrays || options.defaults)
                                      object.tags = [];
                                  if (options.defaults) {
                                      object.id = null;
                                      object.field = "";
                                      object.dtype = "";
                                      object.base = 0;
                                      object.kappa = 0;
                                      object.precision_fractional = 0;
                                      object.description = "";
                                      object.child = null;
                                  }
                                  if (message.id != null && message.hasOwnProperty("id"))
                                      object.id = $root.syft_proto.types.syft.v1.Id.toObject(message.id, options);
                                  if (message.field != null && message.hasOwnProperty("field"))
                                      object.field = message.field;
                                  if (message.dtype != null && message.hasOwnProperty("dtype"))
                                      object.dtype = message.dtype;
                                  if (message.base != null && message.hasOwnProperty("base"))
                                      object.base = message.base;
                                  if (message.kappa != null && message.hasOwnProperty("kappa"))
                                      object.kappa = message.kappa;
                                  if (message.precision_fractional != null && message.hasOwnProperty("precision_fractional"))
                                      object.precision_fractional = message.precision_fractional;
                                  if (message.tags && message.tags.length) {
                                      object.tags = [];
                                      for (var j = 0; j < message.tags.length; ++j)
                                          object.tags[j] = message.tags[j];
                                  }
                                  if (message.description != null && message.hasOwnProperty("description"))
                                      object.description = message.description;
                                  if (message.child != null && message.hasOwnProperty("child"))
                                      object.child = $root.syft_proto.frameworks.torch.tensors.interpreters.v1.AdditiveSharingTensor.toObject(message.child, options);
                                  return object;
                              };

                              /**
                               * Converts this FixedPrecisionTensor to JSON.
                               * @function toJSON
                               * @memberof syft_proto.frameworks.torch.tensors.interpreters.v1.FixedPrecisionTensor
                               * @instance
                               * @returns {Object.<string,*>} JSON object
                               */
                              FixedPrecisionTensor.prototype.toJSON = function toJSON() {
                                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                              };

                              return FixedPrecisionTensor;
                          })();

                          return v1;
                      })();

                      return interpreters;
                  })();

                  return tensors;
              })();

              return torch;
          })();

          return frameworks;
      })();

      syft_proto.messaging = (function() {

          /**
           * Namespace messaging.
           * @memberof syft_proto
           * @namespace
           */
          var messaging = {};

          messaging.v1 = (function() {

              /**
               * Namespace v1.
               * @memberof syft_proto.messaging
               * @namespace
               */
              var v1 = {};

              v1.String = (function() {

                  /**
                   * Properties of a String.
                   * @memberof syft_proto.messaging.v1
                   * @interface IString
                   * @property {string|null} [child] String child
                   * @property {Array.<string>|null} [tags] String tags
                   * @property {string|null} [description] String description
                   */

                  /**
                   * Constructs a new String.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents a String.
                   * @implements IString
                   * @constructor
                   * @param {syft_proto.messaging.v1.IString=} [properties] Properties to set
                   */
                  function String(properties) {
                      this.tags = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * String child.
                   * @member {string} child
                   * @memberof syft_proto.messaging.v1.String
                   * @instance
                   */
                  String.prototype.child = "";

                  /**
                   * String tags.
                   * @member {Array.<string>} tags
                   * @memberof syft_proto.messaging.v1.String
                   * @instance
                   */
                  String.prototype.tags = $util.emptyArray;

                  /**
                   * String description.
                   * @member {string} description
                   * @memberof syft_proto.messaging.v1.String
                   * @instance
                   */
                  String.prototype.description = "";

                  /**
                   * Creates a new String instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.String
                   * @static
                   * @param {syft_proto.messaging.v1.IString=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.String} String instance
                   */
                  String.create = function create(properties) {
                      return new String(properties);
                  };

                  /**
                   * Encodes the specified String message. Does not implicitly {@link syft_proto.messaging.v1.String.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.String
                   * @static
                   * @param {syft_proto.messaging.v1.IString} message String message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  String.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.child != null && message.hasOwnProperty("child"))
                          writer.uint32(/* id 1, wireType 2 =*/10).string(message.child);
                      if (message.tags != null && message.tags.length)
                          for (var i = 0; i < message.tags.length; ++i)
                              writer.uint32(/* id 2, wireType 2 =*/18).string(message.tags[i]);
                      if (message.description != null && message.hasOwnProperty("description"))
                          writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                      return writer;
                  };

                  /**
                   * Encodes the specified String message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.String.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.String
                   * @static
                   * @param {syft_proto.messaging.v1.IString} message String message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  String.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a String message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.String
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.String} String
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  String.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.String();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.child = reader.string();
                              break;
                          case 2:
                              if (!(message.tags && message.tags.length))
                                  message.tags = [];
                              message.tags.push(reader.string());
                              break;
                          case 3:
                              message.description = reader.string();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a String message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.String
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.String} String
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  String.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a String message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.String
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  String.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.child != null && message.hasOwnProperty("child"))
                          if (!$util.isString(message.child))
                              return "child: string expected";
                      if (message.tags != null && message.hasOwnProperty("tags")) {
                          if (!Array.isArray(message.tags))
                              return "tags: array expected";
                          for (var i = 0; i < message.tags.length; ++i)
                              if (!$util.isString(message.tags[i]))
                                  return "tags: string[] expected";
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          if (!$util.isString(message.description))
                              return "description: string expected";
                      return null;
                  };

                  /**
                   * Creates a String message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.String
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.String} String
                   */
                  String.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.String)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.String();
                      if (object.child != null)
                          message.child = String(object.child);
                      if (object.tags) {
                          if (!Array.isArray(object.tags))
                              throw TypeError(".syft_proto.messaging.v1.String.tags: array expected");
                          message.tags = [];
                          for (var i = 0; i < object.tags.length; ++i)
                              message.tags[i] = String(object.tags[i]);
                      }
                      if (object.description != null)
                          message.description = String(object.description);
                      return message;
                  };

                  /**
                   * Creates a plain object from a String message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.String
                   * @static
                   * @param {syft_proto.messaging.v1.String} message String
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  String.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults)
                          object.tags = [];
                      if (options.defaults) {
                          object.child = "";
                          object.description = "";
                      }
                      if (message.child != null && message.hasOwnProperty("child"))
                          object.child = message.child;
                      if (message.tags && message.tags.length) {
                          object.tags = [];
                          for (var j = 0; j < message.tags.length; ++j)
                              object.tags[j] = message.tags[j];
                      }
                      if (message.description != null && message.hasOwnProperty("description"))
                          object.description = message.description;
                      return object;
                  };

                  /**
                   * Converts this String to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.String
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  String.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return String;
              })();

              v1.SyftMessage = (function() {

                  /**
                   * Properties of a SyftMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface ISyftMessage
                   * @property {google.protobuf.IEmpty|null} [contents_empty_msg] SyftMessage contents_empty_msg
                   * @property {syft_proto.messaging.v1.IForceObjectDeleteMessage|null} [contents_delete_msg] SyftMessage contents_delete_msg
                   * @property {syft_proto.messaging.v1.IGetShapeMessage|null} [contents_get_shape_msg] SyftMessage contents_get_shape_msg
                   * @property {syft_proto.messaging.v1.IIsNoneMessage|null} [contents_is_none_msg] SyftMessage contents_is_none_msg
                   * @property {syft_proto.messaging.v1.IObjectMessage|null} [contents_object_msg] SyftMessage contents_object_msg
                   * @property {syft_proto.messaging.v1.IObjectRequestMessage|null} [contents_object_request_msg] SyftMessage contents_object_request_msg
                   * @property {syft_proto.messaging.v1.ITensorCommandMessage|null} [contents_tensor_cmd_msg] SyftMessage contents_tensor_cmd_msg
                   * @property {syft_proto.messaging.v1.IPlanCommandMessage|null} [contents_plan_cmd_msg] SyftMessage contents_plan_cmd_msg
                   * @property {syft_proto.messaging.v1.IWorkerCommandMessage|null} [contents_worker_cmd_msg] SyftMessage contents_worker_cmd_msg
                   * @property {syft_proto.messaging.v1.ISearchMessage|null} [contents_search_msg] SyftMessage contents_search_msg
                   */

                  /**
                   * Constructs a new SyftMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents a SyftMessage.
                   * @implements ISyftMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.ISyftMessage=} [properties] Properties to set
                   */
                  function SyftMessage(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * SyftMessage contents_empty_msg.
                   * @member {google.protobuf.IEmpty|null|undefined} contents_empty_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_empty_msg = null;

                  /**
                   * SyftMessage contents_delete_msg.
                   * @member {syft_proto.messaging.v1.IForceObjectDeleteMessage|null|undefined} contents_delete_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_delete_msg = null;

                  /**
                   * SyftMessage contents_get_shape_msg.
                   * @member {syft_proto.messaging.v1.IGetShapeMessage|null|undefined} contents_get_shape_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_get_shape_msg = null;

                  /**
                   * SyftMessage contents_is_none_msg.
                   * @member {syft_proto.messaging.v1.IIsNoneMessage|null|undefined} contents_is_none_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_is_none_msg = null;

                  /**
                   * SyftMessage contents_object_msg.
                   * @member {syft_proto.messaging.v1.IObjectMessage|null|undefined} contents_object_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_object_msg = null;

                  /**
                   * SyftMessage contents_object_request_msg.
                   * @member {syft_proto.messaging.v1.IObjectRequestMessage|null|undefined} contents_object_request_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_object_request_msg = null;

                  /**
                   * SyftMessage contents_tensor_cmd_msg.
                   * @member {syft_proto.messaging.v1.ITensorCommandMessage|null|undefined} contents_tensor_cmd_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_tensor_cmd_msg = null;

                  /**
                   * SyftMessage contents_plan_cmd_msg.
                   * @member {syft_proto.messaging.v1.IPlanCommandMessage|null|undefined} contents_plan_cmd_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_plan_cmd_msg = null;

                  /**
                   * SyftMessage contents_worker_cmd_msg.
                   * @member {syft_proto.messaging.v1.IWorkerCommandMessage|null|undefined} contents_worker_cmd_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_worker_cmd_msg = null;

                  /**
                   * SyftMessage contents_search_msg.
                   * @member {syft_proto.messaging.v1.ISearchMessage|null|undefined} contents_search_msg
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  SyftMessage.prototype.contents_search_msg = null;

                  // OneOf field names bound to virtual getters and setters
                  var $oneOfFields;

                  /**
                   * SyftMessage contents.
                   * @member {"contents_empty_msg"|"contents_delete_msg"|"contents_get_shape_msg"|"contents_is_none_msg"|"contents_object_msg"|"contents_object_request_msg"|"contents_tensor_cmd_msg"|"contents_plan_cmd_msg"|"contents_worker_cmd_msg"|"contents_search_msg"|undefined} contents
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   */
                  Object.defineProperty(SyftMessage.prototype, "contents", {
                      get: $util.oneOfGetter($oneOfFields = ["contents_empty_msg", "contents_delete_msg", "contents_get_shape_msg", "contents_is_none_msg", "contents_object_msg", "contents_object_request_msg", "contents_tensor_cmd_msg", "contents_plan_cmd_msg", "contents_worker_cmd_msg", "contents_search_msg"]),
                      set: $util.oneOfSetter($oneOfFields)
                  });

                  /**
                   * Creates a new SyftMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ISyftMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.SyftMessage} SyftMessage instance
                   */
                  SyftMessage.create = function create(properties) {
                      return new SyftMessage(properties);
                  };

                  /**
                   * Encodes the specified SyftMessage message. Does not implicitly {@link syft_proto.messaging.v1.SyftMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ISyftMessage} message SyftMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  SyftMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.contents_empty_msg != null && message.hasOwnProperty("contents_empty_msg"))
                          $root.google.protobuf.Empty.encode(message.contents_empty_msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.contents_delete_msg != null && message.hasOwnProperty("contents_delete_msg"))
                          $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.encode(message.contents_delete_msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      if (message.contents_get_shape_msg != null && message.hasOwnProperty("contents_get_shape_msg"))
                          $root.syft_proto.messaging.v1.GetShapeMessage.encode(message.contents_get_shape_msg, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                      if (message.contents_is_none_msg != null && message.hasOwnProperty("contents_is_none_msg"))
                          $root.syft_proto.messaging.v1.IsNoneMessage.encode(message.contents_is_none_msg, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                      if (message.contents_object_msg != null && message.hasOwnProperty("contents_object_msg"))
                          $root.syft_proto.messaging.v1.ObjectMessage.encode(message.contents_object_msg, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                      if (message.contents_object_request_msg != null && message.hasOwnProperty("contents_object_request_msg"))
                          $root.syft_proto.messaging.v1.ObjectRequestMessage.encode(message.contents_object_request_msg, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                      if (message.contents_tensor_cmd_msg != null && message.hasOwnProperty("contents_tensor_cmd_msg"))
                          $root.syft_proto.messaging.v1.TensorCommandMessage.encode(message.contents_tensor_cmd_msg, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                      if (message.contents_plan_cmd_msg != null && message.hasOwnProperty("contents_plan_cmd_msg"))
                          $root.syft_proto.messaging.v1.PlanCommandMessage.encode(message.contents_plan_cmd_msg, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                      if (message.contents_worker_cmd_msg != null && message.hasOwnProperty("contents_worker_cmd_msg"))
                          $root.syft_proto.messaging.v1.WorkerCommandMessage.encode(message.contents_worker_cmd_msg, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                      if (message.contents_search_msg != null && message.hasOwnProperty("contents_search_msg"))
                          $root.syft_proto.messaging.v1.SearchMessage.encode(message.contents_search_msg, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified SyftMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.SyftMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ISyftMessage} message SyftMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  SyftMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a SyftMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.SyftMessage} SyftMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  SyftMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.SyftMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.contents_empty_msg = $root.google.protobuf.Empty.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.contents_delete_msg = $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.decode(reader, reader.uint32());
                              break;
                          case 3:
                              message.contents_get_shape_msg = $root.syft_proto.messaging.v1.GetShapeMessage.decode(reader, reader.uint32());
                              break;
                          case 4:
                              message.contents_is_none_msg = $root.syft_proto.messaging.v1.IsNoneMessage.decode(reader, reader.uint32());
                              break;
                          case 5:
                              message.contents_object_msg = $root.syft_proto.messaging.v1.ObjectMessage.decode(reader, reader.uint32());
                              break;
                          case 6:
                              message.contents_object_request_msg = $root.syft_proto.messaging.v1.ObjectRequestMessage.decode(reader, reader.uint32());
                              break;
                          case 7:
                              message.contents_tensor_cmd_msg = $root.syft_proto.messaging.v1.TensorCommandMessage.decode(reader, reader.uint32());
                              break;
                          case 8:
                              message.contents_plan_cmd_msg = $root.syft_proto.messaging.v1.PlanCommandMessage.decode(reader, reader.uint32());
                              break;
                          case 9:
                              message.contents_worker_cmd_msg = $root.syft_proto.messaging.v1.WorkerCommandMessage.decode(reader, reader.uint32());
                              break;
                          case 10:
                              message.contents_search_msg = $root.syft_proto.messaging.v1.SearchMessage.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a SyftMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.SyftMessage} SyftMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  SyftMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a SyftMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  SyftMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      var properties = {};
                      if (message.contents_empty_msg != null && message.hasOwnProperty("contents_empty_msg")) {
                          properties.contents = 1;
                          {
                              var error = $root.google.protobuf.Empty.verify(message.contents_empty_msg);
                              if (error)
                                  return "contents_empty_msg." + error;
                          }
                      }
                      if (message.contents_delete_msg != null && message.hasOwnProperty("contents_delete_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.verify(message.contents_delete_msg);
                              if (error)
                                  return "contents_delete_msg." + error;
                          }
                      }
                      if (message.contents_get_shape_msg != null && message.hasOwnProperty("contents_get_shape_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.GetShapeMessage.verify(message.contents_get_shape_msg);
                              if (error)
                                  return "contents_get_shape_msg." + error;
                          }
                      }
                      if (message.contents_is_none_msg != null && message.hasOwnProperty("contents_is_none_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.IsNoneMessage.verify(message.contents_is_none_msg);
                              if (error)
                                  return "contents_is_none_msg." + error;
                          }
                      }
                      if (message.contents_object_msg != null && message.hasOwnProperty("contents_object_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.ObjectMessage.verify(message.contents_object_msg);
                              if (error)
                                  return "contents_object_msg." + error;
                          }
                      }
                      if (message.contents_object_request_msg != null && message.hasOwnProperty("contents_object_request_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.ObjectRequestMessage.verify(message.contents_object_request_msg);
                              if (error)
                                  return "contents_object_request_msg." + error;
                          }
                      }
                      if (message.contents_tensor_cmd_msg != null && message.hasOwnProperty("contents_tensor_cmd_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.TensorCommandMessage.verify(message.contents_tensor_cmd_msg);
                              if (error)
                                  return "contents_tensor_cmd_msg." + error;
                          }
                      }
                      if (message.contents_plan_cmd_msg != null && message.hasOwnProperty("contents_plan_cmd_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.PlanCommandMessage.verify(message.contents_plan_cmd_msg);
                              if (error)
                                  return "contents_plan_cmd_msg." + error;
                          }
                      }
                      if (message.contents_worker_cmd_msg != null && message.hasOwnProperty("contents_worker_cmd_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.WorkerCommandMessage.verify(message.contents_worker_cmd_msg);
                              if (error)
                                  return "contents_worker_cmd_msg." + error;
                          }
                      }
                      if (message.contents_search_msg != null && message.hasOwnProperty("contents_search_msg")) {
                          if (properties.contents === 1)
                              return "contents: multiple values";
                          properties.contents = 1;
                          {
                              var error = $root.syft_proto.messaging.v1.SearchMessage.verify(message.contents_search_msg);
                              if (error)
                                  return "contents_search_msg." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a SyftMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.SyftMessage} SyftMessage
                   */
                  SyftMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.SyftMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.SyftMessage();
                      if (object.contents_empty_msg != null) {
                          if (typeof object.contents_empty_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_empty_msg: object expected");
                          message.contents_empty_msg = $root.google.protobuf.Empty.fromObject(object.contents_empty_msg);
                      }
                      if (object.contents_delete_msg != null) {
                          if (typeof object.contents_delete_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_delete_msg: object expected");
                          message.contents_delete_msg = $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.fromObject(object.contents_delete_msg);
                      }
                      if (object.contents_get_shape_msg != null) {
                          if (typeof object.contents_get_shape_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_get_shape_msg: object expected");
                          message.contents_get_shape_msg = $root.syft_proto.messaging.v1.GetShapeMessage.fromObject(object.contents_get_shape_msg);
                      }
                      if (object.contents_is_none_msg != null) {
                          if (typeof object.contents_is_none_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_is_none_msg: object expected");
                          message.contents_is_none_msg = $root.syft_proto.messaging.v1.IsNoneMessage.fromObject(object.contents_is_none_msg);
                      }
                      if (object.contents_object_msg != null) {
                          if (typeof object.contents_object_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_object_msg: object expected");
                          message.contents_object_msg = $root.syft_proto.messaging.v1.ObjectMessage.fromObject(object.contents_object_msg);
                      }
                      if (object.contents_object_request_msg != null) {
                          if (typeof object.contents_object_request_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_object_request_msg: object expected");
                          message.contents_object_request_msg = $root.syft_proto.messaging.v1.ObjectRequestMessage.fromObject(object.contents_object_request_msg);
                      }
                      if (object.contents_tensor_cmd_msg != null) {
                          if (typeof object.contents_tensor_cmd_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_tensor_cmd_msg: object expected");
                          message.contents_tensor_cmd_msg = $root.syft_proto.messaging.v1.TensorCommandMessage.fromObject(object.contents_tensor_cmd_msg);
                      }
                      if (object.contents_plan_cmd_msg != null) {
                          if (typeof object.contents_plan_cmd_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_plan_cmd_msg: object expected");
                          message.contents_plan_cmd_msg = $root.syft_proto.messaging.v1.PlanCommandMessage.fromObject(object.contents_plan_cmd_msg);
                      }
                      if (object.contents_worker_cmd_msg != null) {
                          if (typeof object.contents_worker_cmd_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_worker_cmd_msg: object expected");
                          message.contents_worker_cmd_msg = $root.syft_proto.messaging.v1.WorkerCommandMessage.fromObject(object.contents_worker_cmd_msg);
                      }
                      if (object.contents_search_msg != null) {
                          if (typeof object.contents_search_msg !== "object")
                              throw TypeError(".syft_proto.messaging.v1.SyftMessage.contents_search_msg: object expected");
                          message.contents_search_msg = $root.syft_proto.messaging.v1.SearchMessage.fromObject(object.contents_search_msg);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a SyftMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @static
                   * @param {syft_proto.messaging.v1.SyftMessage} message SyftMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  SyftMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (message.contents_empty_msg != null && message.hasOwnProperty("contents_empty_msg")) {
                          object.contents_empty_msg = $root.google.protobuf.Empty.toObject(message.contents_empty_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_empty_msg";
                      }
                      if (message.contents_delete_msg != null && message.hasOwnProperty("contents_delete_msg")) {
                          object.contents_delete_msg = $root.syft_proto.messaging.v1.ForceObjectDeleteMessage.toObject(message.contents_delete_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_delete_msg";
                      }
                      if (message.contents_get_shape_msg != null && message.hasOwnProperty("contents_get_shape_msg")) {
                          object.contents_get_shape_msg = $root.syft_proto.messaging.v1.GetShapeMessage.toObject(message.contents_get_shape_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_get_shape_msg";
                      }
                      if (message.contents_is_none_msg != null && message.hasOwnProperty("contents_is_none_msg")) {
                          object.contents_is_none_msg = $root.syft_proto.messaging.v1.IsNoneMessage.toObject(message.contents_is_none_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_is_none_msg";
                      }
                      if (message.contents_object_msg != null && message.hasOwnProperty("contents_object_msg")) {
                          object.contents_object_msg = $root.syft_proto.messaging.v1.ObjectMessage.toObject(message.contents_object_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_object_msg";
                      }
                      if (message.contents_object_request_msg != null && message.hasOwnProperty("contents_object_request_msg")) {
                          object.contents_object_request_msg = $root.syft_proto.messaging.v1.ObjectRequestMessage.toObject(message.contents_object_request_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_object_request_msg";
                      }
                      if (message.contents_tensor_cmd_msg != null && message.hasOwnProperty("contents_tensor_cmd_msg")) {
                          object.contents_tensor_cmd_msg = $root.syft_proto.messaging.v1.TensorCommandMessage.toObject(message.contents_tensor_cmd_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_tensor_cmd_msg";
                      }
                      if (message.contents_plan_cmd_msg != null && message.hasOwnProperty("contents_plan_cmd_msg")) {
                          object.contents_plan_cmd_msg = $root.syft_proto.messaging.v1.PlanCommandMessage.toObject(message.contents_plan_cmd_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_plan_cmd_msg";
                      }
                      if (message.contents_worker_cmd_msg != null && message.hasOwnProperty("contents_worker_cmd_msg")) {
                          object.contents_worker_cmd_msg = $root.syft_proto.messaging.v1.WorkerCommandMessage.toObject(message.contents_worker_cmd_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_worker_cmd_msg";
                      }
                      if (message.contents_search_msg != null && message.hasOwnProperty("contents_search_msg")) {
                          object.contents_search_msg = $root.syft_proto.messaging.v1.SearchMessage.toObject(message.contents_search_msg, options);
                          if (options.oneofs)
                              object.contents = "contents_search_msg";
                      }
                      return object;
                  };

                  /**
                   * Converts this SyftMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.SyftMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  SyftMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return SyftMessage;
              })();

              v1.IsNoneMessage = (function() {

                  /**
                   * Properties of an IsNoneMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface IIsNoneMessage
                   * @property {syft_proto.types.syft.v1.IId|null} [object_id] IsNoneMessage object_id
                   */

                  /**
                   * Constructs a new IsNoneMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents an IsNoneMessage.
                   * @implements IIsNoneMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.IIsNoneMessage=} [properties] Properties to set
                   */
                  function IsNoneMessage(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * IsNoneMessage object_id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @instance
                   */
                  IsNoneMessage.prototype.object_id = null;

                  /**
                   * Creates a new IsNoneMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IIsNoneMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.IsNoneMessage} IsNoneMessage instance
                   */
                  IsNoneMessage.create = function create(properties) {
                      return new IsNoneMessage(properties);
                  };

                  /**
                   * Encodes the specified IsNoneMessage message. Does not implicitly {@link syft_proto.messaging.v1.IsNoneMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IIsNoneMessage} message IsNoneMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  IsNoneMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.object_id != null && message.hasOwnProperty("object_id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified IsNoneMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.IsNoneMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IIsNoneMessage} message IsNoneMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  IsNoneMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes an IsNoneMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.IsNoneMessage} IsNoneMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  IsNoneMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.IsNoneMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes an IsNoneMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.IsNoneMessage} IsNoneMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  IsNoneMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies an IsNoneMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  IsNoneMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.object_id != null && message.hasOwnProperty("object_id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                          if (error)
                              return "object_id." + error;
                      }
                      return null;
                  };

                  /**
                   * Creates an IsNoneMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.IsNoneMessage} IsNoneMessage
                   */
                  IsNoneMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.IsNoneMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.IsNoneMessage();
                      if (object.object_id != null) {
                          if (typeof object.object_id !== "object")
                              throw TypeError(".syft_proto.messaging.v1.IsNoneMessage.object_id: object expected");
                          message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from an IsNoneMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IsNoneMessage} message IsNoneMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  IsNoneMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults)
                          object.object_id = null;
                      if (message.object_id != null && message.hasOwnProperty("object_id"))
                          object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                      return object;
                  };

                  /**
                   * Converts this IsNoneMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.IsNoneMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  IsNoneMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return IsNoneMessage;
              })();

              v1.ObjectMessage = (function() {

                  /**
                   * Properties of an ObjectMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface IObjectMessage
                   * @property {syft_proto.types.torch.v1.ITorchTensor|null} [tensor] ObjectMessage tensor
                   */

                  /**
                   * Constructs a new ObjectMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents an ObjectMessage.
                   * @implements IObjectMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.IObjectMessage=} [properties] Properties to set
                   */
                  function ObjectMessage(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * ObjectMessage tensor.
                   * @member {syft_proto.types.torch.v1.ITorchTensor|null|undefined} tensor
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @instance
                   */
                  ObjectMessage.prototype.tensor = null;

                  /**
                   * Creates a new ObjectMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IObjectMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.ObjectMessage} ObjectMessage instance
                   */
                  ObjectMessage.create = function create(properties) {
                      return new ObjectMessage(properties);
                  };

                  /**
                   * Encodes the specified ObjectMessage message. Does not implicitly {@link syft_proto.messaging.v1.ObjectMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IObjectMessage} message ObjectMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ObjectMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.tensor != null && message.hasOwnProperty("tensor"))
                          $root.syft_proto.types.torch.v1.TorchTensor.encode(message.tensor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified ObjectMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.ObjectMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IObjectMessage} message ObjectMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ObjectMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes an ObjectMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.ObjectMessage} ObjectMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ObjectMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.ObjectMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.tensor = $root.syft_proto.types.torch.v1.TorchTensor.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes an ObjectMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.ObjectMessage} ObjectMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ObjectMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies an ObjectMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  ObjectMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.tensor != null && message.hasOwnProperty("tensor")) {
                          var error = $root.syft_proto.types.torch.v1.TorchTensor.verify(message.tensor);
                          if (error)
                              return "tensor." + error;
                      }
                      return null;
                  };

                  /**
                   * Creates an ObjectMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.ObjectMessage} ObjectMessage
                   */
                  ObjectMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.ObjectMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.ObjectMessage();
                      if (object.tensor != null) {
                          if (typeof object.tensor !== "object")
                              throw TypeError(".syft_proto.messaging.v1.ObjectMessage.tensor: object expected");
                          message.tensor = $root.syft_proto.types.torch.v1.TorchTensor.fromObject(object.tensor);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from an ObjectMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ObjectMessage} message ObjectMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  ObjectMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults)
                          object.tensor = null;
                      if (message.tensor != null && message.hasOwnProperty("tensor"))
                          object.tensor = $root.syft_proto.types.torch.v1.TorchTensor.toObject(message.tensor, options);
                      return object;
                  };

                  /**
                   * Converts this ObjectMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.ObjectMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  ObjectMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return ObjectMessage;
              })();

              v1.TensorCommandMessage = (function() {

                  /**
                   * Properties of a TensorCommandMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface ITensorCommandMessage
                   * @property {syft_proto.execution.v1.IComputationAction|null} [computation] TensorCommandMessage computation
                   * @property {syft_proto.execution.v1.ICommunicationAction|null} [communication] TensorCommandMessage communication
                   */

                  /**
                   * Constructs a new TensorCommandMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents a TensorCommandMessage.
                   * @implements ITensorCommandMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.ITensorCommandMessage=} [properties] Properties to set
                   */
                  function TensorCommandMessage(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * TensorCommandMessage computation.
                   * @member {syft_proto.execution.v1.IComputationAction|null|undefined} computation
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @instance
                   */
                  TensorCommandMessage.prototype.computation = null;

                  /**
                   * TensorCommandMessage communication.
                   * @member {syft_proto.execution.v1.ICommunicationAction|null|undefined} communication
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @instance
                   */
                  TensorCommandMessage.prototype.communication = null;

                  // OneOf field names bound to virtual getters and setters
                  var $oneOfFields;

                  /**
                   * TensorCommandMessage action.
                   * @member {"computation"|"communication"|undefined} action
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @instance
                   */
                  Object.defineProperty(TensorCommandMessage.prototype, "action", {
                      get: $util.oneOfGetter($oneOfFields = ["computation", "communication"]),
                      set: $util.oneOfSetter($oneOfFields)
                  });

                  /**
                   * Creates a new TensorCommandMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ITensorCommandMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.TensorCommandMessage} TensorCommandMessage instance
                   */
                  TensorCommandMessage.create = function create(properties) {
                      return new TensorCommandMessage(properties);
                  };

                  /**
                   * Encodes the specified TensorCommandMessage message. Does not implicitly {@link syft_proto.messaging.v1.TensorCommandMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ITensorCommandMessage} message TensorCommandMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  TensorCommandMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.computation != null && message.hasOwnProperty("computation"))
                          $root.syft_proto.execution.v1.ComputationAction.encode(message.computation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.communication != null && message.hasOwnProperty("communication"))
                          $root.syft_proto.execution.v1.CommunicationAction.encode(message.communication, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified TensorCommandMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.TensorCommandMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ITensorCommandMessage} message TensorCommandMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  TensorCommandMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a TensorCommandMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.TensorCommandMessage} TensorCommandMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  TensorCommandMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.TensorCommandMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.computation = $root.syft_proto.execution.v1.ComputationAction.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.communication = $root.syft_proto.execution.v1.CommunicationAction.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a TensorCommandMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.TensorCommandMessage} TensorCommandMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  TensorCommandMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a TensorCommandMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  TensorCommandMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      var properties = {};
                      if (message.computation != null && message.hasOwnProperty("computation")) {
                          properties.action = 1;
                          {
                              var error = $root.syft_proto.execution.v1.ComputationAction.verify(message.computation);
                              if (error)
                                  return "computation." + error;
                          }
                      }
                      if (message.communication != null && message.hasOwnProperty("communication")) {
                          if (properties.action === 1)
                              return "action: multiple values";
                          properties.action = 1;
                          {
                              var error = $root.syft_proto.execution.v1.CommunicationAction.verify(message.communication);
                              if (error)
                                  return "communication." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a TensorCommandMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.TensorCommandMessage} TensorCommandMessage
                   */
                  TensorCommandMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.TensorCommandMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.TensorCommandMessage();
                      if (object.computation != null) {
                          if (typeof object.computation !== "object")
                              throw TypeError(".syft_proto.messaging.v1.TensorCommandMessage.computation: object expected");
                          message.computation = $root.syft_proto.execution.v1.ComputationAction.fromObject(object.computation);
                      }
                      if (object.communication != null) {
                          if (typeof object.communication !== "object")
                              throw TypeError(".syft_proto.messaging.v1.TensorCommandMessage.communication: object expected");
                          message.communication = $root.syft_proto.execution.v1.CommunicationAction.fromObject(object.communication);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a TensorCommandMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.TensorCommandMessage} message TensorCommandMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  TensorCommandMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (message.computation != null && message.hasOwnProperty("computation")) {
                          object.computation = $root.syft_proto.execution.v1.ComputationAction.toObject(message.computation, options);
                          if (options.oneofs)
                              object.action = "computation";
                      }
                      if (message.communication != null && message.hasOwnProperty("communication")) {
                          object.communication = $root.syft_proto.execution.v1.CommunicationAction.toObject(message.communication, options);
                          if (options.oneofs)
                              object.action = "communication";
                      }
                      return object;
                  };

                  /**
                   * Converts this TensorCommandMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.TensorCommandMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  TensorCommandMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return TensorCommandMessage;
              })();

              v1.ForceObjectDeleteMessage = (function() {

                  /**
                   * Properties of a ForceObjectDeleteMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface IForceObjectDeleteMessage
                   * @property {syft_proto.types.syft.v1.IId|null} [object_id] ForceObjectDeleteMessage object_id
                   */

                  /**
                   * Constructs a new ForceObjectDeleteMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents a ForceObjectDeleteMessage.
                   * @implements IForceObjectDeleteMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.IForceObjectDeleteMessage=} [properties] Properties to set
                   */
                  function ForceObjectDeleteMessage(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * ForceObjectDeleteMessage object_id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @instance
                   */
                  ForceObjectDeleteMessage.prototype.object_id = null;

                  /**
                   * Creates a new ForceObjectDeleteMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IForceObjectDeleteMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.ForceObjectDeleteMessage} ForceObjectDeleteMessage instance
                   */
                  ForceObjectDeleteMessage.create = function create(properties) {
                      return new ForceObjectDeleteMessage(properties);
                  };

                  /**
                   * Encodes the specified ForceObjectDeleteMessage message. Does not implicitly {@link syft_proto.messaging.v1.ForceObjectDeleteMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IForceObjectDeleteMessage} message ForceObjectDeleteMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ForceObjectDeleteMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.object_id != null && message.hasOwnProperty("object_id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified ForceObjectDeleteMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.ForceObjectDeleteMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IForceObjectDeleteMessage} message ForceObjectDeleteMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ForceObjectDeleteMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a ForceObjectDeleteMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.ForceObjectDeleteMessage} ForceObjectDeleteMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ForceObjectDeleteMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.ForceObjectDeleteMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a ForceObjectDeleteMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.ForceObjectDeleteMessage} ForceObjectDeleteMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ForceObjectDeleteMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a ForceObjectDeleteMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  ForceObjectDeleteMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.object_id != null && message.hasOwnProperty("object_id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                          if (error)
                              return "object_id." + error;
                      }
                      return null;
                  };

                  /**
                   * Creates a ForceObjectDeleteMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.ForceObjectDeleteMessage} ForceObjectDeleteMessage
                   */
                  ForceObjectDeleteMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.ForceObjectDeleteMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.ForceObjectDeleteMessage();
                      if (object.object_id != null) {
                          if (typeof object.object_id !== "object")
                              throw TypeError(".syft_proto.messaging.v1.ForceObjectDeleteMessage.object_id: object expected");
                          message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a ForceObjectDeleteMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ForceObjectDeleteMessage} message ForceObjectDeleteMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  ForceObjectDeleteMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults)
                          object.object_id = null;
                      if (message.object_id != null && message.hasOwnProperty("object_id"))
                          object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                      return object;
                  };

                  /**
                   * Converts this ForceObjectDeleteMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.ForceObjectDeleteMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  ForceObjectDeleteMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return ForceObjectDeleteMessage;
              })();

              v1.GetShapeMessage = (function() {

                  /**
                   * Properties of a GetShapeMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface IGetShapeMessage
                   * @property {syft_proto.types.syft.v1.IId|null} [object_id] GetShapeMessage object_id
                   */

                  /**
                   * Constructs a new GetShapeMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents a GetShapeMessage.
                   * @implements IGetShapeMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.IGetShapeMessage=} [properties] Properties to set
                   */
                  function GetShapeMessage(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * GetShapeMessage object_id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @instance
                   */
                  GetShapeMessage.prototype.object_id = null;

                  /**
                   * Creates a new GetShapeMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IGetShapeMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.GetShapeMessage} GetShapeMessage instance
                   */
                  GetShapeMessage.create = function create(properties) {
                      return new GetShapeMessage(properties);
                  };

                  /**
                   * Encodes the specified GetShapeMessage message. Does not implicitly {@link syft_proto.messaging.v1.GetShapeMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IGetShapeMessage} message GetShapeMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  GetShapeMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.object_id != null && message.hasOwnProperty("object_id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified GetShapeMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.GetShapeMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IGetShapeMessage} message GetShapeMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  GetShapeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a GetShapeMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.GetShapeMessage} GetShapeMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  GetShapeMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.GetShapeMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a GetShapeMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.GetShapeMessage} GetShapeMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  GetShapeMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a GetShapeMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  GetShapeMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.object_id != null && message.hasOwnProperty("object_id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                          if (error)
                              return "object_id." + error;
                      }
                      return null;
                  };

                  /**
                   * Creates a GetShapeMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.GetShapeMessage} GetShapeMessage
                   */
                  GetShapeMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.GetShapeMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.GetShapeMessage();
                      if (object.object_id != null) {
                          if (typeof object.object_id !== "object")
                              throw TypeError(".syft_proto.messaging.v1.GetShapeMessage.object_id: object expected");
                          message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a GetShapeMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @static
                   * @param {syft_proto.messaging.v1.GetShapeMessage} message GetShapeMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  GetShapeMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults)
                          object.object_id = null;
                      if (message.object_id != null && message.hasOwnProperty("object_id"))
                          object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                      return object;
                  };

                  /**
                   * Converts this GetShapeMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.GetShapeMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  GetShapeMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return GetShapeMessage;
              })();

              v1.ObjectRequestMessage = (function() {

                  /**
                   * Properties of an ObjectRequestMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface IObjectRequestMessage
                   * @property {syft_proto.types.syft.v1.IId|null} [object_id] ObjectRequestMessage object_id
                   * @property {string|null} [reason] ObjectRequestMessage reason
                   */

                  /**
                   * Constructs a new ObjectRequestMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents an ObjectRequestMessage.
                   * @implements IObjectRequestMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.IObjectRequestMessage=} [properties] Properties to set
                   */
                  function ObjectRequestMessage(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * ObjectRequestMessage object_id.
                   * @member {syft_proto.types.syft.v1.IId|null|undefined} object_id
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @instance
                   */
                  ObjectRequestMessage.prototype.object_id = null;

                  /**
                   * ObjectRequestMessage reason.
                   * @member {string} reason
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @instance
                   */
                  ObjectRequestMessage.prototype.reason = "";

                  /**
                   * Creates a new ObjectRequestMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IObjectRequestMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.ObjectRequestMessage} ObjectRequestMessage instance
                   */
                  ObjectRequestMessage.create = function create(properties) {
                      return new ObjectRequestMessage(properties);
                  };

                  /**
                   * Encodes the specified ObjectRequestMessage message. Does not implicitly {@link syft_proto.messaging.v1.ObjectRequestMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IObjectRequestMessage} message ObjectRequestMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ObjectRequestMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.object_id != null && message.hasOwnProperty("object_id"))
                          $root.syft_proto.types.syft.v1.Id.encode(message.object_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      if (message.reason != null && message.hasOwnProperty("reason"))
                          writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
                      return writer;
                  };

                  /**
                   * Encodes the specified ObjectRequestMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.ObjectRequestMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IObjectRequestMessage} message ObjectRequestMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ObjectRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes an ObjectRequestMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.ObjectRequestMessage} ObjectRequestMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ObjectRequestMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.ObjectRequestMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.object_id = $root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32());
                              break;
                          case 2:
                              message.reason = reader.string();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes an ObjectRequestMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.ObjectRequestMessage} ObjectRequestMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ObjectRequestMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies an ObjectRequestMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  ObjectRequestMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.object_id != null && message.hasOwnProperty("object_id")) {
                          var error = $root.syft_proto.types.syft.v1.Id.verify(message.object_id);
                          if (error)
                              return "object_id." + error;
                      }
                      if (message.reason != null && message.hasOwnProperty("reason"))
                          if (!$util.isString(message.reason))
                              return "reason: string expected";
                      return null;
                  };

                  /**
                   * Creates an ObjectRequestMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.ObjectRequestMessage} ObjectRequestMessage
                   */
                  ObjectRequestMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.ObjectRequestMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.ObjectRequestMessage();
                      if (object.object_id != null) {
                          if (typeof object.object_id !== "object")
                              throw TypeError(".syft_proto.messaging.v1.ObjectRequestMessage.object_id: object expected");
                          message.object_id = $root.syft_proto.types.syft.v1.Id.fromObject(object.object_id);
                      }
                      if (object.reason != null)
                          message.reason = String(object.reason);
                      return message;
                  };

                  /**
                   * Creates a plain object from an ObjectRequestMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ObjectRequestMessage} message ObjectRequestMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  ObjectRequestMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults) {
                          object.object_id = null;
                          object.reason = "";
                      }
                      if (message.object_id != null && message.hasOwnProperty("object_id"))
                          object.object_id = $root.syft_proto.types.syft.v1.Id.toObject(message.object_id, options);
                      if (message.reason != null && message.hasOwnProperty("reason"))
                          object.reason = message.reason;
                      return object;
                  };

                  /**
                   * Converts this ObjectRequestMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.ObjectRequestMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  ObjectRequestMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return ObjectRequestMessage;
              })();

              v1.PlanCommandMessage = (function() {

                  /**
                   * Properties of a PlanCommandMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface IPlanCommandMessage
                   * @property {string|null} [command_name] PlanCommandMessage command_name
                   * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] PlanCommandMessage args
                   */

                  /**
                   * Constructs a new PlanCommandMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents a PlanCommandMessage.
                   * @implements IPlanCommandMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.IPlanCommandMessage=} [properties] Properties to set
                   */
                  function PlanCommandMessage(properties) {
                      this.args = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * PlanCommandMessage command_name.
                   * @member {string} command_name
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @instance
                   */
                  PlanCommandMessage.prototype.command_name = "";

                  /**
                   * PlanCommandMessage args.
                   * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @instance
                   */
                  PlanCommandMessage.prototype.args = $util.emptyArray;

                  /**
                   * Creates a new PlanCommandMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IPlanCommandMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.PlanCommandMessage} PlanCommandMessage instance
                   */
                  PlanCommandMessage.create = function create(properties) {
                      return new PlanCommandMessage(properties);
                  };

                  /**
                   * Encodes the specified PlanCommandMessage message. Does not implicitly {@link syft_proto.messaging.v1.PlanCommandMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IPlanCommandMessage} message PlanCommandMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  PlanCommandMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.command_name != null && message.hasOwnProperty("command_name"))
                          writer.uint32(/* id 1, wireType 2 =*/10).string(message.command_name);
                      if (message.args != null && message.args.length)
                          for (var i = 0; i < message.args.length; ++i)
                              $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified PlanCommandMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.PlanCommandMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IPlanCommandMessage} message PlanCommandMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  PlanCommandMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a PlanCommandMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.PlanCommandMessage} PlanCommandMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  PlanCommandMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.PlanCommandMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.command_name = reader.string();
                              break;
                          case 2:
                              if (!(message.args && message.args.length))
                                  message.args = [];
                              message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a PlanCommandMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.PlanCommandMessage} PlanCommandMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  PlanCommandMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a PlanCommandMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  PlanCommandMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.command_name != null && message.hasOwnProperty("command_name"))
                          if (!$util.isString(message.command_name))
                              return "command_name: string expected";
                      if (message.args != null && message.hasOwnProperty("args")) {
                          if (!Array.isArray(message.args))
                              return "args: array expected";
                          for (var i = 0; i < message.args.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                              if (error)
                                  return "args." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a PlanCommandMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.PlanCommandMessage} PlanCommandMessage
                   */
                  PlanCommandMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.PlanCommandMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.PlanCommandMessage();
                      if (object.command_name != null)
                          message.command_name = String(object.command_name);
                      if (object.args) {
                          if (!Array.isArray(object.args))
                              throw TypeError(".syft_proto.messaging.v1.PlanCommandMessage.args: array expected");
                          message.args = [];
                          for (var i = 0; i < object.args.length; ++i) {
                              if (typeof object.args[i] !== "object")
                                  throw TypeError(".syft_proto.messaging.v1.PlanCommandMessage.args: object expected");
                              message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                          }
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a PlanCommandMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.PlanCommandMessage} message PlanCommandMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  PlanCommandMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults)
                          object.args = [];
                      if (options.defaults)
                          object.command_name = "";
                      if (message.command_name != null && message.hasOwnProperty("command_name"))
                          object.command_name = message.command_name;
                      if (message.args && message.args.length) {
                          object.args = [];
                          for (var j = 0; j < message.args.length; ++j)
                              object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                      }
                      return object;
                  };

                  /**
                   * Converts this PlanCommandMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.PlanCommandMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  PlanCommandMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return PlanCommandMessage;
              })();

              v1.WorkerCommandMessage = (function() {

                  /**
                   * Properties of a WorkerCommandMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface IWorkerCommandMessage
                   * @property {string|null} [command_name] WorkerCommandMessage command_name
                   * @property {Array.<syft_proto.types.syft.v1.IArg>|null} [args] WorkerCommandMessage args
                   */

                  /**
                   * Constructs a new WorkerCommandMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents a WorkerCommandMessage.
                   * @implements IWorkerCommandMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.IWorkerCommandMessage=} [properties] Properties to set
                   */
                  function WorkerCommandMessage(properties) {
                      this.args = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * WorkerCommandMessage command_name.
                   * @member {string} command_name
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @instance
                   */
                  WorkerCommandMessage.prototype.command_name = "";

                  /**
                   * WorkerCommandMessage args.
                   * @member {Array.<syft_proto.types.syft.v1.IArg>} args
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @instance
                   */
                  WorkerCommandMessage.prototype.args = $util.emptyArray;

                  /**
                   * Creates a new WorkerCommandMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IWorkerCommandMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.WorkerCommandMessage} WorkerCommandMessage instance
                   */
                  WorkerCommandMessage.create = function create(properties) {
                      return new WorkerCommandMessage(properties);
                  };

                  /**
                   * Encodes the specified WorkerCommandMessage message. Does not implicitly {@link syft_proto.messaging.v1.WorkerCommandMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IWorkerCommandMessage} message WorkerCommandMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  WorkerCommandMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.command_name != null && message.hasOwnProperty("command_name"))
                          writer.uint32(/* id 1, wireType 2 =*/10).string(message.command_name);
                      if (message.args != null && message.args.length)
                          for (var i = 0; i < message.args.length; ++i)
                              $root.syft_proto.types.syft.v1.Arg.encode(message.args[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified WorkerCommandMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.WorkerCommandMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.IWorkerCommandMessage} message WorkerCommandMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  WorkerCommandMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a WorkerCommandMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.WorkerCommandMessage} WorkerCommandMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  WorkerCommandMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.WorkerCommandMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.command_name = reader.string();
                              break;
                          case 2:
                              if (!(message.args && message.args.length))
                                  message.args = [];
                              message.args.push($root.syft_proto.types.syft.v1.Arg.decode(reader, reader.uint32()));
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a WorkerCommandMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.WorkerCommandMessage} WorkerCommandMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  WorkerCommandMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a WorkerCommandMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  WorkerCommandMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.command_name != null && message.hasOwnProperty("command_name"))
                          if (!$util.isString(message.command_name))
                              return "command_name: string expected";
                      if (message.args != null && message.hasOwnProperty("args")) {
                          if (!Array.isArray(message.args))
                              return "args: array expected";
                          for (var i = 0; i < message.args.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Arg.verify(message.args[i]);
                              if (error)
                                  return "args." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a WorkerCommandMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.WorkerCommandMessage} WorkerCommandMessage
                   */
                  WorkerCommandMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.WorkerCommandMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.WorkerCommandMessage();
                      if (object.command_name != null)
                          message.command_name = String(object.command_name);
                      if (object.args) {
                          if (!Array.isArray(object.args))
                              throw TypeError(".syft_proto.messaging.v1.WorkerCommandMessage.args: array expected");
                          message.args = [];
                          for (var i = 0; i < object.args.length; ++i) {
                              if (typeof object.args[i] !== "object")
                                  throw TypeError(".syft_proto.messaging.v1.WorkerCommandMessage.args: object expected");
                              message.args[i] = $root.syft_proto.types.syft.v1.Arg.fromObject(object.args[i]);
                          }
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a WorkerCommandMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @static
                   * @param {syft_proto.messaging.v1.WorkerCommandMessage} message WorkerCommandMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  WorkerCommandMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults)
                          object.args = [];
                      if (options.defaults)
                          object.command_name = "";
                      if (message.command_name != null && message.hasOwnProperty("command_name"))
                          object.command_name = message.command_name;
                      if (message.args && message.args.length) {
                          object.args = [];
                          for (var j = 0; j < message.args.length; ++j)
                              object.args[j] = $root.syft_proto.types.syft.v1.Arg.toObject(message.args[j], options);
                      }
                      return object;
                  };

                  /**
                   * Converts this WorkerCommandMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.WorkerCommandMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  WorkerCommandMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return WorkerCommandMessage;
              })();

              v1.SearchMessage = (function() {

                  /**
                   * Properties of a SearchMessage.
                   * @memberof syft_proto.messaging.v1
                   * @interface ISearchMessage
                   * @property {Array.<syft_proto.types.syft.v1.IId>|null} [query] SearchMessage query
                   */

                  /**
                   * Constructs a new SearchMessage.
                   * @memberof syft_proto.messaging.v1
                   * @classdesc Represents a SearchMessage.
                   * @implements ISearchMessage
                   * @constructor
                   * @param {syft_proto.messaging.v1.ISearchMessage=} [properties] Properties to set
                   */
                  function SearchMessage(properties) {
                      this.query = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * SearchMessage query.
                   * @member {Array.<syft_proto.types.syft.v1.IId>} query
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @instance
                   */
                  SearchMessage.prototype.query = $util.emptyArray;

                  /**
                   * Creates a new SearchMessage instance using the specified properties.
                   * @function create
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ISearchMessage=} [properties] Properties to set
                   * @returns {syft_proto.messaging.v1.SearchMessage} SearchMessage instance
                   */
                  SearchMessage.create = function create(properties) {
                      return new SearchMessage(properties);
                  };

                  /**
                   * Encodes the specified SearchMessage message. Does not implicitly {@link syft_proto.messaging.v1.SearchMessage.verify|verify} messages.
                   * @function encode
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ISearchMessage} message SearchMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  SearchMessage.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.query != null && message.query.length)
                          for (var i = 0; i < message.query.length; ++i)
                              $root.syft_proto.types.syft.v1.Id.encode(message.query[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                      return writer;
                  };

                  /**
                   * Encodes the specified SearchMessage message, length delimited. Does not implicitly {@link syft_proto.messaging.v1.SearchMessage.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @static
                   * @param {syft_proto.messaging.v1.ISearchMessage} message SearchMessage message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  SearchMessage.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a SearchMessage message from the specified reader or buffer.
                   * @function decode
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {syft_proto.messaging.v1.SearchMessage} SearchMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  SearchMessage.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.syft_proto.messaging.v1.SearchMessage();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              if (!(message.query && message.query.length))
                                  message.query = [];
                              message.query.push($root.syft_proto.types.syft.v1.Id.decode(reader, reader.uint32()));
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a SearchMessage message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {syft_proto.messaging.v1.SearchMessage} SearchMessage
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  SearchMessage.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a SearchMessage message.
                   * @function verify
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  SearchMessage.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.query != null && message.hasOwnProperty("query")) {
                          if (!Array.isArray(message.query))
                              return "query: array expected";
                          for (var i = 0; i < message.query.length; ++i) {
                              var error = $root.syft_proto.types.syft.v1.Id.verify(message.query[i]);
                              if (error)
                                  return "query." + error;
                          }
                      }
                      return null;
                  };

                  /**
                   * Creates a SearchMessage message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {syft_proto.messaging.v1.SearchMessage} SearchMessage
                   */
                  SearchMessage.fromObject = function fromObject(object) {
                      if (object instanceof $root.syft_proto.messaging.v1.SearchMessage)
                          return object;
                      var message = new $root.syft_proto.messaging.v1.SearchMessage();
                      if (object.query) {
                          if (!Array.isArray(object.query))
                              throw TypeError(".syft_proto.messaging.v1.SearchMessage.query: array expected");
                          message.query = [];
                          for (var i = 0; i < object.query.length; ++i) {
                              if (typeof object.query[i] !== "object")
                                  throw TypeError(".syft_proto.messaging.v1.SearchMessage.query: object expected");
                              message.query[i] = $root.syft_proto.types.syft.v1.Id.fromObject(object.query[i]);
                          }
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a SearchMessage message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @static
                   * @param {syft_proto.messaging.v1.SearchMessage} message SearchMessage
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  SearchMessage.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults)
                          object.query = [];
                      if (message.query && message.query.length) {
                          object.query = [];
                          for (var j = 0; j < message.query.length; ++j)
                              object.query[j] = $root.syft_proto.types.syft.v1.Id.toObject(message.query[j], options);
                      }
                      return object;
                  };

                  /**
                   * Converts this SearchMessage to JSON.
                   * @function toJSON
                   * @memberof syft_proto.messaging.v1.SearchMessage
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  SearchMessage.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return SearchMessage;
              })();

              return v1;
          })();

          return messaging;
      })();

      return syft_proto;
  })();

  $root.google = (function() {

      /**
       * Namespace google.
       * @exports google
       * @namespace
       */
      var google = {};

      google.protobuf = (function() {

          /**
           * Namespace protobuf.
           * @memberof google
           * @namespace
           */
          var protobuf = {};

          protobuf.Empty = (function() {

              /**
               * Properties of an Empty.
               * @memberof google.protobuf
               * @interface IEmpty
               */

              /**
               * Constructs a new Empty.
               * @memberof google.protobuf
               * @classdesc Represents an Empty.
               * @implements IEmpty
               * @constructor
               * @param {google.protobuf.IEmpty=} [properties] Properties to set
               */
              function Empty(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * Creates a new Empty instance using the specified properties.
               * @function create
               * @memberof google.protobuf.Empty
               * @static
               * @param {google.protobuf.IEmpty=} [properties] Properties to set
               * @returns {google.protobuf.Empty} Empty instance
               */
              Empty.create = function create(properties) {
                  return new Empty(properties);
              };

              /**
               * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.Empty
               * @static
               * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Empty.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  return writer;
              };

              /**
               * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.Empty
               * @static
               * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Empty.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an Empty message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.Empty
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.Empty} Empty
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Empty.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an Empty message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.Empty
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.Empty} Empty
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Empty.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an Empty message.
               * @function verify
               * @memberof google.protobuf.Empty
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              Empty.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  return null;
              };

              /**
               * Creates an Empty message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.Empty
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.Empty} Empty
               */
              Empty.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.Empty)
                      return object;
                  return new $root.google.protobuf.Empty();
              };

              /**
               * Creates a plain object from an Empty message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.Empty
               * @static
               * @param {google.protobuf.Empty} message Empty
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              Empty.toObject = function toObject() {
                  return {};
              };

              /**
               * Converts this Empty to JSON.
               * @function toJSON
               * @memberof google.protobuf.Empty
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              Empty.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return Empty;
          })();

          return protobuf;
      })();

      return google;
  })();

  var protobuf = $root;

  getCjsExportFromNamespace(proto$1);

  var protobuf$1 = protobuf;

  /**
   * Protocol stores a squence of actions. A Protocol's sequence of actions can
   * be sent to remote workers while the Protocol keeps a reference to the actions.
   * This way, to operate on remote input, only a single message with references
   * of the Protocol as well as the pointers is required for a worker to perform
   * the actions.
   *
   * Protocol contains a mix of ComputationActions and CommunicationActions.
   * Therefore, Protocol can act as a cross-worker and is different from Plan, which
   * contains pure mathematical operations.
   *
   * Note: Protocol is currently not used in syft.js.
   */

  var Protocol = /*#__PURE__*/function () {
    /**
     * @param {number} id - Id of the PointerTensor.
     * @param {Array.<string>} tags - Tags for Protocol.
     * @param {string} description - Description for Protocol.
     * @param {Array.<Plan>} planAssigments - Array of Plans that Protocol should execute.
     * @param {*} workersResolved
     */
    function Protocol(id, tags, description, planAssigments, workersResolved) {
      classCallCheck(this, Protocol);

      this.id = id;
      this.tags = tags;
      this.description = description;
      this.plans = planAssigments;
      this.workersResolved = workersResolved;
    }
    /**
     * Reconstructs a Protocol object from the protobuf message.
     * Note that this method might take a worker-specific argument in the future.
     *
     * @static
     * @param {*} worker - Reserved placeholder for worker-specific arguments.
     * @param {protobuf.syft_proto.execution.v1.Protocol} pb - Protobuf object for Protocol.
     * @returns {Protocol}
     */


    createClass(Protocol, null, [{
      key: "unbufferize",
      value: function unbufferize(worker, pb) {
        var planAssignments = [];

        if (pb.plan_assignments) {
          pb.plan_assignments.forEach(function (item) {
            planAssignments.push([getPbId(item.worker_id), getPbId(item.plan_id)]);
          });
        }

        return new Protocol(getPbId(pb.id), pb.tags, pb.description, planAssignments, pb.workers_resolved);
      }
    }]);

    return Protocol;
  }();

  function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /**
   * Plan stores a sequence of actions (ComputationAction) in its role.
   * A worker is assigned plans and executes the actions stored in the plans.
   */

  var Plan = /*#__PURE__*/function () {
    /**
     * @hideconstructor
     * @param {string} id - Id of the Plan.
     * @param {string} name - Name of the Plan.
     * @param {Array.<Role>} [role=[]] Array of Roles.
     * @param {Array.<string>} [tags=[]] - Tags for Plan.
     * @param {string|null} [description=null] Description for Plan.
     */
    function Plan(id, name) {
      var role = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var tags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var description = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      classCallCheck(this, Plan);

      this.id = id;
      this.name = name;
      this.role = role;
      this.tags = tags;
      this.description = description;
    }
    /**
     * Reconstructs a Plan object from the protobuf message.
     * Note that this method take a worker-specific argument in the future.
     * @private
     * @param {*} worker - Reserved placeholder for worker-specific arguments.
     * @param {protobuf.syft_proto.execution.v1.Plan} pb - Protobuf object for Role.
     * @returns {Plan}
     */


    createClass(Plan, [{
      key: "execute",

      /**
       * Executes the Plan and returns its output.
       *
       * The order, type and number of arguments must match to arguments defined in the PySyft Plan.
       *
       * @param {Syft} worker
       * @param {...(tf.Tensor|number)} data
       * @returns {Promise<Array.<tf.Tensor>>}
       */
      value: function () {
        var _execute = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(worker) {
          var _this$role;

          var _len,
              data,
              _key,
              _args = arguments;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  for (_len = _args.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = _args[_key];
                  }

                  return _context.abrupt("return", (_this$role = this.role).execute.apply(_this$role, [worker].concat(data)));

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function execute(_x) {
          return _execute.apply(this, arguments);
        }

        return execute;
      }()
    }], [{
      key: "unbufferize",
      value: function unbufferize$1(worker, pb) {
        var id = getPbId(pb.id);
        return new Plan(id, pb.name, unbufferize(worker, pb.role), pb.tags, pb.description);
      }
    }]);

    return Plan;
  }();
  /**
   * Object that describes Plan input.
   * Parameters known to `PlanTrainer`
   * (like training data, model parameters, batch size, etc.)
   * are mapped into Plan arguments according to this object.
   *
   * @param {string} type - Input argument type.
   * @param {string} [name] - Optional argument name.
   * @param {number} [index] - Optional argument index (to take from array).
   * @param {*} [value] - Argument value.
   */

  var PlanInputSpec = /*#__PURE__*/function () {
    /**
     * Represents training data (substituted with PlanTrainer's `data` batch)
     * @constant
     */

    /**
     * Represents training targets aka labels (substituted with PlanTrainer's `target` batch)
     * @constant
     */

    /**
     * Represents batch size (substituted with PlanTrainer's `batchSize`).
     * @constant
     */

    /**
     * Represents parameter from client config configured in FL model, `name` argument is required (substituted with parameter from PlanTrainer's `clientConfig`).
     * @constant
     */

    /**
     * Represents any value, `value` argument is required.
     * @constant
     */

    /**
     * Represents model parameter (substituted with `SyftModel` contents).
     * @constant
     */
    function PlanInputSpec(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      classCallCheck(this, PlanInputSpec);

      this.type = type;
      this.name = name;
      this.index = index;
      this.value = value;
    }
    /**
     * Creates list of Plan arguments according to specified `specs`.
     *
     * @private
     * @param {[PlanInputSpec]} specs - Plan arguments specifications.
     * @param {Object} data - Dictionary containing Plan arguments.
     * @returns {[]}
     */


    createClass(PlanInputSpec, null, [{
      key: "resolve",
      value: function resolve(specs, data) {
        var args = [];

        var _iterator = _createForOfIteratorHelper(specs),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var spec = _step.value;

            if (spec.type === this.TYPE_VALUE) {
              args.push(spec.value);
            } else if (spec.index !== null) {
              args.push(data[spec.type][spec.index]);
            } else if (spec.name !== null) {
              args.push(data[spec.type][spec.name]);
            } else if (spec.type === this.TYPE_CLIENT_CONFIG_PARAM) {
              args.push(data[spec.type][spec.name]);
            } else {
              args.push(data[spec.type]);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return args;
      }
    }]);

    return PlanInputSpec;
  }();
  /**
   * Object that describes Plan output.
   * Values returned from Plan
   * (like loss, accuracy, model parameters, etc.)
   * are mapped into `PlanTrainer`'s internal state according to this object.
   *
   * @param {string} type - Output variable type.
   * @param {string} [name] - Optional name.
   * @param {number} [index] - Optional index (to put into array).
   */

  defineProperty(PlanInputSpec, "TYPE_DATA", 'data');

  defineProperty(PlanInputSpec, "TYPE_TARGET", 'target');

  defineProperty(PlanInputSpec, "TYPE_BATCH_SIZE", 'batchSize');

  defineProperty(PlanInputSpec, "TYPE_CLIENT_CONFIG_PARAM", 'clientConfigParam');

  defineProperty(PlanInputSpec, "TYPE_VALUE", 'value');

  defineProperty(PlanInputSpec, "TYPE_MODEL_PARAM", 'modelParam');

  var PlanOutputSpec = /*#__PURE__*/function () {
    /**
     * Represents loss value (maps to PlanTrainer's loss).
     * @constant
     */

    /**
     * Represents metric value, name is required (maps to PlanTrainer's metrics dictionary).
     * @constant
     */

    /**
     * Represents model parameter (maps to `SyftModel` parameters)
     * @constant
     */
    function PlanOutputSpec(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      classCallCheck(this, PlanOutputSpec);

      this.type = type;
      this.name = name;
      this.index = index;
    }
    /**
     * Creates dictionary of Plan output values according to `specs`.
     *
     * @private
     * @param {[PlanOutputSpec]} specs - Specifications of Plan output variables.
     * @param {[*]} data - Plan output.
     * @returns {Object}
     */


    createClass(PlanOutputSpec, null, [{
      key: "resolve",
      value: function resolve(specs, data) {
        var out = {};
        var i = 0;

        var _iterator2 = _createForOfIteratorHelper(specs),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var spec = _step2.value;

            if (spec.index !== null) {
              if (typeof out[spec.type] === 'undefined') {
                out[spec.type] = [];
              }

              out[spec.type][spec.index] = data[i];
            } else if (spec.name !== null) {
              if (typeof out[spec.type] === 'undefined') {
                out[spec.type] = {};
              }

              out[spec.type][spec.name] = data[i];
            } else {
              out[spec.type] = data[i];
            }

            i++;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return out;
      }
    }]);

    return PlanOutputSpec;
  }();

  defineProperty(PlanOutputSpec, "TYPE_LOSS", 'loss');

  defineProperty(PlanOutputSpec, "TYPE_METRIC", 'metric');

  defineProperty(PlanOutputSpec, "TYPE_MODEL_PARAM", 'modelParam');

  /**
   * ObjectRegistry stores a map of {id -> object} and a map of {id -> gc},
   * where gc denotes if the object of given id will be garbage collected.
   */

  var ObjectRegistry = /*#__PURE__*/function () {
    /**
     * @property {Object.<string, Object>} objects - a map of {id: object}
     * @property {Object.<string, boolean>} gc - a map of {id: boolean} that determines if the object of id will be garbage collected
     */
    function ObjectRegistry() {
      classCallCheck(this, ObjectRegistry);

      this.objects = {};
      this.gc = {};
    }

    createClass(ObjectRegistry, [{
      key: "set",
      value: function set(id, obj) {
        var gc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        // Remove the current id and object in the objects map before replacing them
        if (this.objects[id] instanceof tf.Tensor) {
          this.objects[id].dispose();
          delete this.objects[id];
        }

        this.objects[id] = obj;
        this.gc[id] = gc;
      }
    }, {
      key: "setGc",
      value: function setGc(id, gc) {
        this.gc[id] = gc;
      }
    }, {
      key: "get",
      value: function get(id) {
        return this.objects[id];
      }
    }, {
      key: "has",
      value: function has(id) {
        return Object.hasOwnProperty.call(this.objects, id);
      }
    }, {
      key: "clear",
      value: function clear() {
        for (var _i = 0, _Object$keys = Object.keys(this.objects); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];

          if (this.gc[key] && this.objects[key] instanceof tf.Tensor) {
            this.objects[key].dispose();
          }
        }

        this.objects = {};
        this.gc = {};
      }
      /**
       * Loads the objects from an existing ObjectRegistry and stores them in this.objects
       * @param {ObjectRegistry} objectRegistry
       */

    }, {
      key: "load",
      value: function load(objectRegistry) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(objectRegistry.objects); _i2 < _Object$keys2.length; _i2++) {
          var key = _Object$keys2[_i2];
          this.set(key, objectRegistry.get(key));
        }
      }
    }]);

    return ObjectRegistry;
  }();

  function _createForOfIteratorHelper$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

  function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /**
   * Role encapsulates a list of ComputationActions that are executed in a Plan.
   *
   * Concretely, a worker is assigned a Role, which includes actions that the
   * worker should perform.
   */

  var Role = /*#__PURE__*/function () {
    /**
     * @param {string} id - Id of the Role.
     * @param {Array.<ComputationAction>} [actions=[]] - Array of actions to be executed.
     * @param {State} [state=null]
     * @param {Object.<string,Placeholder>} [placeholders={}] - Array of Placeholders that contain tensors.
     * @param {Array.<PlaceholderId>} [input_placeholder_ids=[]] - Array of PlaceholderIds for input values.
     * @param {Array.<PlaceholderId>} [output_placeholder_ids=[]] - Array of PlaceholderIds for output values.
     * @param {Array.<string>} [tags=[]] - Tags for Role.
     * @param {string|null} [description=null] Description for Role.
     */
    function Role(id) {
      var actions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var placeholders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var input_placeholder_ids = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
      var output_placeholder_ids = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
      var tags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
      var description = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

      classCallCheck(this, Role);

      this.id = id;
      this.actions = actions;
      this.state = state;
      this.placeholders = placeholders;
      this.input_placeholder_ids = input_placeholder_ids;
      this.output_placeholder_ids = output_placeholder_ids;
      this.tags = tags;
      this.description = description;
    }
    /**
     * Reconstructs a Role object from the protobuf message.
     * Note that this method might take a worker-specific argument in the future.
     *
     * @static
     * @param {*} worker - Reserved placeholder for worker-specific arguments.
     * @param {protobuf.syft_proto.execution.v1.Role} pb - Protobuf object for Role.
     * @returns {Role}
     */


    createClass(Role, [{
      key: "getInputPlaceholders",

      /**
       * @returns {Array.<Placeholder>} - Input Placeholders
       */
      value: function getInputPlaceholders() {
        var _this = this;

        return this.input_placeholder_ids.map(function (id) {
          return _this.placeholders[id];
        });
      }
      /**
       * @returns {Array.<Placeholder>} - Output Placeholders
       */

    }, {
      key: "getOutputPlaceholders",
      value: function getOutputPlaceholders() {
        var _this2 = this;

        return this.output_placeholder_ids.map(function (id) {
          return _this2.placeholders[id];
        });
      }
      /**
       * Executes the actions in the Role with a given worker.
       * @param {Syft} worker
       * @param {...(tf.Tensor)} data
       * @returns {Promise<Array>}
       */

    }, {
      key: "execute",
      value: function () {
        var _execute = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(worker) {
          var _this3 = this;

          var planScope,
              inputPlaceholders,
              outputPlaceholders,
              argsLength,
              _len,
              data,
              _key,
              _iterator,
              _step,
              action,
              result,
              resolvedResultingTensors,
              _args = arguments;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  // Create local scope
                  planScope = new ObjectRegistry();
                  planScope.load(worker.objects);
                  inputPlaceholders = this.getInputPlaceholders(), outputPlaceholders = this.getOutputPlaceholders(), argsLength = inputPlaceholders.length; // If the number of arguments supplied does not match the number of arguments required

                  for (_len = _args.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = _args[_key];
                  }

                  if (!(data.length !== argsLength)) {
                    _context.next = 6;
                    break;
                  }

                  throw new NotEnoughArgsError(data.length, argsLength);

                case 6:
                  // Add each argument to local scope
                  data.forEach(function (datum, i) {
                    planScope.set(inputPlaceholders[i].id, datum);
                  }); // Load state tensors to worker

                  if (this.state && this.state.tensors) {
                    this.state.placeholders.forEach(function (ph, idx) {
                      planScope.set(ph.id, _this3.state.tensors[idx]);
                    });
                  } // Execute the plan


                  _iterator = _createForOfIteratorHelper$1(this.actions);
                  _context.prev = 9;

                  _iterator.s();

                case 11:
                  if ((_step = _iterator.n()).done) {
                    _context.next = 19;
                    break;
                  }

                  action = _step.value;
                  _context.next = 15;
                  return action.execute(planScope);

                case 15:
                  result = _context.sent;

                  // Place the result of the current operation into this.objects at the 0th item in returnIds
                  // All intermediate tensors will be garbage collected by default
                  if (result) {
                    if (action.returnIds.length > 0) {
                      planScope.set(action.returnIds[0], result, true);
                    } else if (action.returnPlaceholderIds.length > 0) {
                      planScope.set(action.returnPlaceholderIds[0].id, result, true);
                    }
                  }

                case 17:
                  _context.next = 11;
                  break;

                case 19:
                  _context.next = 24;
                  break;

                case 21:
                  _context.prev = 21;
                  _context.t0 = _context["catch"](9);

                  _iterator.e(_context.t0);

                case 24:
                  _context.prev = 24;

                  _iterator.f();

                  return _context.finish(24);

                case 27:
                  // Resolve all of the requested resultId's as specified by the Plan
                  resolvedResultingTensors = [];
                  outputPlaceholders.forEach(function (placeholder) {
                    resolvedResultingTensors.push(planScope.get(placeholder.id)); // Do not gc output tensors

                    planScope.setGc(placeholder.id, false);
                  }); // Clean up intermediate plan variables.

                  planScope.clear(); // Return resolved tensors to the worker

                  return _context.abrupt("return", resolvedResultingTensors);

                case 31:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[9, 21, 24, 27]]);
        }));

        function execute(_x) {
          return _execute.apply(this, arguments);
        }

        return execute;
      }()
    }], [{
      key: "unbufferize",
      value: function unbufferize$1(worker, pb) {
        var placeholdersArray = unbufferize(worker, pb.placeholders);

        var placeholders = {};

        var _iterator2 = _createForOfIteratorHelper$1(placeholdersArray),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var ph = _step2.value;
            placeholders[ph.id] = ph;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return new Role(getPbId(pb.id), unbufferize(worker, pb.actions), unbufferize(worker, pb.state), placeholders, pb.input_placeholder_ids.map(getPbId), pb.output_placeholder_ids.map(getPbId), pb.tags, pb.description);
      }
    }]);

    return Role;
  }();

  /**
   * State stores a list of tensors. In Syft.JS, State is used to
   * serialize and store model weights.
   */

  var State$1 = /*#__PURE__*/function () {
    /**
     * @hideconstructor
     * @param {Array.<Placeholder>} [placeholders=null] - Array of Placeholders.
     * @param {Array.<TorchTensor>} [tensors=null] - Array of TorchTensors.
     */
    function State() {
      var placeholders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var tensors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      classCallCheck(this, State);

      this.placeholders = placeholders;
      this.tensors = tensors;
    }
    /**
     * Converts an Array of TorchTensor to tf.Tensor.
     * @returns {Array.<tf.Tensor>}
     */


    createClass(State, [{
      key: "getTfTensors",
      value: function getTfTensors() {
        return this.tensors.map(function (t) {
          return t.toTfTensor();
        });
      }
      /**
       * Reconstructs a State object from the protobuf message.
       * Note that this method take a worker-specific argument in the future.
       * @static
       * @param {*} worker - Reserved placeholder for worker-specific arguments.
       * @param {protobuf.syft_proto.execution.v1.State} pb - Protobuf object for State.
       * @returns {State}
       */

    }, {
      key: "bufferize",

      /**
       * Bufferizes the State object, its tensors and placeholders to
       * a protobuf State object.
       *
       * Note that this method should take a worker-specific argument in the future.
       * @param {*} worker - Reserved placeholder for worker-specific arguments.
       * @returns {protobuf.syft_proto.execution.v1.State}
       */
      value: function bufferize(worker) {
        var tensorsPb = this.tensors.map(function (tensor) {
          return protobuf$1.syft_proto.execution.v1.StateTensor.create({
            torch_tensor: tensor.bufferize(worker)
          });
        });
        var placeholdersPb = this.placeholders.map(function (ph) {
          return ph.bufferize();
        });
        return protobuf$1.syft_proto.execution.v1.State.create({
          placeholders: placeholdersPb,
          tensors: tensorsPb
        });
      }
    }], [{
      key: "unbufferize",
      value: function unbufferize$1(worker, pb) {
        var tensors = pb.tensors.map(function (stateTensor) {
          // unwrap StateTensor
          return unbufferize(worker, stateTensor[stateTensor.tensor]);
        });
        return new State(unbufferize(worker, pb.placeholders), tensors);
      }
    }]);

    return State;
  }();

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Message enables comunicating between PySyft and Syft workers.
   * Message is the parent class to all other Message types.
   *
   * All Message types are currently are currently not in use.
   *
   * @property {*} contents - For storing unbufferized message data.
   * @property {Logger} logger - For logging information.
   */

  var Message = function Message(contents) {
    classCallCheck(this, Message);

    if (contents) {
      this.contents = contents;
    }

    this.logger = new Logger();
  };
  /**
   * ObjectMessage is used to send an object as message between PySyft and Syft workers.
   * @extends Message
   */

  var ObjectMessage = /*#__PURE__*/function (_Message) {
    inherits(ObjectMessage, _Message);

    var _super = _createSuper$1(ObjectMessage);

    function ObjectMessage(contents) {
      classCallCheck(this, ObjectMessage);

      return _super.call(this, contents);
    }
    /**
     * Unbufferizes and maps data from protobuf object to JS object.
     *
     * @static
     * @param {*} worker - Reserved placeholder for worker-specific arguments when messaging with PySyft.
     * @param {protobuf.syft_proto.messaging.v1.ObjectMessage} pb - Protobuf object.
     * @returns {ObjectMessage}
     */


    createClass(ObjectMessage, null, [{
      key: "unbufferize",
      value: function unbufferize$1(worker, pb) {
        var tensor = unbufferize(worker, pb.tensor);

        return new ObjectMessage(tensor);
      }
    }]);

    return ObjectMessage;
  }(Message); // TODO when types will be availbale in protobuf

  /*
  export class ObjectRequestMessage extends Message {
    constructor(contents) {
      super(contents);
    }
  }

  export class IsNoneMessage extends Message {
    constructor(contents) {
      super(contents);
    }
  }

  export class GetShapeMessage extends Message {
    constructor(contents) {
      super(contents);
    }
  }

  export class ForceObjectDeleteMessage extends Message {
    constructor(contents) {
      super(contents);
    }
  }

  export class SearchMessage extends Message {
    constructor(contents) {
      super(contents);
    }
  }

  export class PlanCommandMessage extends Message {
    constructor(commandName, message) {
      super();

      this.commandName = commandName;
      this.message = message;
    }
  }
  */

  var TorchTensor = /*#__PURE__*/function () {
    function TorchTensor(id, contents, shape, dtype) {
      var chain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var gradChain = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var tags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
      var description = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

      classCallCheck(this, TorchTensor);

      this.id = id;
      this.shape = shape;
      this.dtype = dtype;
      this.contents = contents;
      this.chain = chain;
      this.gradChain = gradChain;
      this.tags = tags;
      this.description = description;
      this._tfTensor = null;
    }

    createClass(TorchTensor, [{
      key: "toTfTensor",
      value: function toTfTensor() {
        if (!this._tfTensor) {
          this._tfTensor = tf.tensor(this.contents, this.shape, this.dtype);
        }

        return this._tfTensor;
      }
    }, {
      key: "bufferize",
      value: function bufferize()
      /* worker */
      {
        var tensorData = {
          shape: protobuf$1.syft_proto.types.torch.v1.Size.create({
            dims: this.shape
          }),
          dtype: this.dtype
        };
        tensorData["contents_".concat(this.dtype)] = this.contents;
        var pbTensorData = protobuf$1.syft_proto.types.torch.v1.TensorData.create(tensorData);
        return protobuf$1.syft_proto.types.torch.v1.TorchTensor.create({
          id: pbId(this.id),
          serializer: protobuf$1.syft_proto.types.torch.v1.TorchTensor.Serializer.SERIALIZER_ALL,
          contents_data: pbTensorData,
          tags: this.tags,
          description: this.description
        });
      }
      /**
       * Returns new `TorchTensor` created from `tf.Tensor`.
       *
       * @param {tf.Tensor} tensor - Tensor.
       * @return {Promise<TorchTensor>}
       */

    }], [{
      key: "unbufferize",
      value: function unbufferize$1(worker, pb) {
        if (pb.serializer !== protobuf$1.syft_proto.types.torch.v1.TorchTensor.Serializer.SERIALIZER_ALL) {
          throw new Error("Tensor serializer ".concat(pb.serializer, " is not supported in syft.js"));
        } // unwrap TensorData


        var tensorData = pb.contents_data;
        var dtype = tensorData.dtype;
        var shape = tensorData.shape.dims;
        var contents = tensorData["contents_".concat(dtype)];
        return new TorchTensor(getPbId(pb.id), contents, shape, dtype, unbufferize(worker, pb.chain), unbufferize(worker, pb.grad_chain), pb.tags, pb.description);
      }
    }, {
      key: "fromTfTensor",
      value: function () {
        var _fromTfTensor = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(tensor) {
          var flat, array, t;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  flat = tensor.flatten();
                  _context.next = 3;
                  return flat.array();

                case 3:
                  array = _context.sent;
                  flat.dispose();
                  t = new TorchTensor(tensor.id, array, tensor.shape, tensor.dtype);
                  t._tfTensor = tensor;
                  return _context.abrupt("return", t);

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function fromTfTensor(_x) {
          return _fromTfTensor.apply(this, arguments);
        }

        return fromTfTensor;
      }()
    }]);

    return TorchTensor;
  }();
  var TorchParameter = /*#__PURE__*/function () {
    function TorchParameter(id, tensor, requiresGrad, grad) {
      classCallCheck(this, TorchParameter);

      this.id = id;
      this.tensor = tensor;
      this.requiresGrad = requiresGrad;
      this.grad = grad;
    }

    createClass(TorchParameter, [{
      key: "toTfTensor",
      value: function toTfTensor() {
        return this.tensor.toTfTensor();
      }
    }], [{
      key: "unbufferize",
      value: function unbufferize$1(worker, pb) {
        return new TorchParameter(getPbId(pb.id), unbufferize(worker, pb.tensor), pb.requires_grad, unbufferize(worker, pb.grad));
      }
    }]);

    return TorchParameter;
  }();

  /**
   * PlaceholderId identifies which Placeholder tensors should be used as
   * inputs and outputs of Actions inside a Plan.
   *
   * @property {string} id - Unbufferized, unique id for a Placeholder object.
   */

  var PlaceholderId = /*#__PURE__*/function () {
    function PlaceholderId(id) {
      classCallCheck(this, PlaceholderId);

      this.id = id;
    }
    /**
     * Reconstructs a PlaceholderId object from the protobuf message.
     * Note that this method might take a worker-specific argument in the future.
     *
     * @static
     * @param {*} worker - Reserved placeholder for worker-specific arguments.
     * @param {protobuf.syft_proto.types.syft.v1.Id} pb - Protobuf object for Id.
     * @returns {PlaceholderId}
     */


    createClass(PlaceholderId, [{
      key: "bufferize",

      /**
       * Save the Id string into a protobuf PlaceholderId message.
       * Note that this method might take a worker-specific argument in the future.
       *
       * @returns {protobuf.syft_proto.execution.v1.PlaceholderId}
       */
      value: function bufferize()
      /* worker */
      {
        return protobuf$1.syft_proto.execution.v1.PlaceholderId.create({
          id: pbId(this.id)
        });
      }
    }], [{
      key: "unbufferize",
      value: function unbufferize(worker, pb) {
        return new PlaceholderId(getPbId(pb.id));
      }
    }]);

    return PlaceholderId;
  }();
  /**
   * Placeholder acts as a tensor. It is replaced by actual tensors after actions
   * are acted on it and can be used to trace the actions from a Plan. A Placeholder
   * has a PlaceholderId that uniquely identifies itself.
   *
   * @property {string} id - Unbufferized Id object.
   */

  var Placeholder = /*#__PURE__*/function () {
    function Placeholder(id) {
      var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var expected_shape = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      classCallCheck(this, Placeholder);

      this.id = id;
      this.tags = tags;
      this.description = description;
      this.expected_shape = expected_shape;
    }
    /**
     * Reconstructs a Placeholder object from the protobuf message.
     * Note that this method might take a worker-specific argument in the future.
     *
     * @static
     * @param {*} worker - Reserved placeholder for worker-specific arguments.
     * @param {protobuf.syft_proto.execution.v1.Placeholder} pb - Protobuf object for Placeholder.
     * @returns {Placeholder}
     */


    createClass(Placeholder, [{
      key: "bufferize",

      /**
       * Bufferizes the Placeholder object to a protobuf Placeholder object.
       * Note that this method should take a worker-specific argument in the future.
       *
       * @returns {protobuf.syft_proto.execution.v1.Placeholder}
       */
      value: function bufferize()
      /* worker */
      {
        return protobuf$1.syft_proto.execution.v1.Placeholder.create({
          id: pbId(this.id),
          tags: this.tags,
          description: this.description,
          expected_shape: protobuf$1.syft_proto.types.syft.v1.Shape.create(this.expected_shape)
        });
      }
    }], [{
      key: "unbufferize",
      value: function unbufferize(worker, pb) {
        var expected_shape = null;

        if (pb.expected_shape && Array.isArray(pb.expected_shape.dims) && pb.expected_shape.dims.length > 0) {
          // Unwrap Shape
          expected_shape = pb.expected_shape.dims;
        }

        return new Placeholder(getPbId(pb.id), pb.tags || [], pb.description, expected_shape);
      }
    }]);

    return Placeholder;
  }();

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }

  var arrayWithoutHoles = _arrayWithoutHoles;

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  var iterableToArray = _iterableToArray;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableSpread = _nonIterableSpread;

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }

  var toConsumableArray = _toConsumableArray;

  /**
   * PointerTensor points to a remote tensor and forwards all API calls
   * to its remote tensor. A PointerTensor mimic the entire API of a normal
   * tensor, but instead of computing a tensor function (such as addition,
   * subtraction, etc.) locally, PointerTensor forwards the computation to
   * a remote machine as specified by self.locationId.
   *
   * Note that PointerTensor is currently not supported. Support for communication
   * between workers comes from Protocol.
   */
  var PointerTensor =
  /**
   * @param {number} id - Id of the PointerTensor.
   * @param {number} idAtLocation - Id of the remote tensor being pointed at.
   * @param {string} locationId - Id of the location where the remote tensor resides.
   * @param {string} pointToAttr - String value to specify if the PointerTensor should point to an attribute of the remote tensor such as .child or .grad.
   * @param {Array.<number>} shape - Size of the tensor the pointer points to.
   * @param {boolean} garbageCollectData - If True, delete the remote tensor when the PointerTensor is removed.
   */
  function PointerTensor(id, idAtLocation, locationId, pointToAttr, shape, garbageCollectData) {
    classCallCheck(this, PointerTensor);

    this.id = id;
    this.idAtLocation = idAtLocation;
    this.locationId = locationId;
    this.pointToAttr = pointToAttr;
    this.shape = shape;
    this.garbageCollectData = garbageCollectData;
  };

  /**
   * ComputationAction describes mathematical operations performed on tensors.
   *
   * @param {string} command - The name of the method to be invoked (e.g. "torch.abs").
   * @param {string|PointerTensor|PlaceholderId|TorchTensor} target - The object to invoke the method on.
   * @param {*} args - The arguments to the method call.
   * @param {Object} kwargs - The keyword arguments to the method call.
   * @param {Array.<string>} returnIds - List of ids for action results.
   * @param {Array.<PlaceholderId>} returnPlaceholderIds - List of PlaceholderIds returned from the action.
   */

  var ComputationAction = /*#__PURE__*/function () {
    function ComputationAction(command, target, args, kwargs, returnIds, returnPlaceholderIds) {
      classCallCheck(this, ComputationAction);

      this.command = command;
      this.target = target;
      this.args = args;
      this.kwargs = kwargs;
      this.returnIds = returnIds;
      this.returnPlaceholderIds = returnPlaceholderIds;
    }
    /**
     * Reconstructs a ComputationAction object from a protobuf message.
     * Note that this method might take a worker-specific argument in the future.
     *
     * @static
     * @param {*} worker - Reserved placeholder for worker-specific arguments.
     * @param {protobuf.syft_proto.execution.v1.ComputationAction} pb - Protobuf object for ComputationAction.
     * @returns {ComputationAction}
     */


    createClass(ComputationAction, [{
      key: "execute",

      /**
       * Execute the ComputationAction with given worker.
       * @param {ObjectRegistry} scope - Local scope provided by the Role on executing the Plan and its actions.
       * @returns {Promise<Array.<tf.Tensor|number>>}
       */
      value: function () {
        var _execute = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(scope) {
          var haveValuesForAllArgs, toTFTensor, getTensorByRef, pullTensorsFromArgs, args, self, resolvedArgs, functionName, _self;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  // Helper function to determine if all PointerTensors/Placeholders in "this.args" also exist as tensors in "objects"
                  haveValuesForAllArgs = function haveValuesForAllArgs(args) {
                    var enoughInfo = true;
                    args.forEach(function (arg) {
                      if (arg instanceof PointerTensor && !scope.has(arg.idAtLocation) || arg instanceof Placeholder && !scope.has(arg.id) || arg instanceof PlaceholderId && !scope.has(arg.id)) {
                        enoughInfo = false;
                      }
                    });
                    return enoughInfo;
                  };

                  toTFTensor = function toTFTensor(tensor) {
                    if (tensor instanceof tf.Tensor) {
                      return tensor;
                    } else if (tensor instanceof TorchTensor) {
                      return tensor.toTfTensor();
                    } else if (tensor instanceof TorchParameter) {
                      return tensor.tensor.toTfTensor();
                    } else if (typeof tensor === 'number') {
                      return tensor;
                    }

                    return null;
                  };

                  getTensorByRef = function getTensorByRef(reference) {
                    var tensor = null;

                    if (reference instanceof PlaceholderId) {
                      tensor = scope.get(reference.id);
                    } else if (reference instanceof Placeholder) {
                      tensor = scope.get(reference.id);
                    } else if (reference instanceof PointerTensor) {
                      tensor = scope.get(reference.idAtLocation);
                    }

                    tensor = toTFTensor(tensor);
                    return tensor;
                  }; // Helper function to get all operable tensors from PointerTensors in "this.args"


                  pullTensorsFromArgs = function pullTensorsFromArgs(args) {
                    var resolvedArgs = [];
                    args.forEach(function (arg) {
                      var tensorByRef = getTensorByRef(arg);

                      if (tensorByRef) {
                        resolvedArgs.push(toTFTensor(tensorByRef));
                      } else {
                        // Try to convert to tensor
                        var tensor = toTFTensor(arg);

                        if (tensor !== null) {
                          resolvedArgs.push(toTFTensor(arg));
                        } else {
                          // Keep as is.
                          resolvedArgs.push(arg);
                        }
                      }
                    });
                    return resolvedArgs;
                  };

                  args = this.args;
                  self = null;

                  if (!this.target) {
                    _context.next = 10;
                    break;
                  }

                  // Resolve "self" if it's present
                  self = getTensorByRef(this.target);

                  if (self) {
                    _context.next = 10;
                    break;
                  }

                  throw new MissingVariableError();

                case 10:
                  if (haveValuesForAllArgs(args)) {
                    _context.next = 12;
                    break;
                  }

                  throw new MissingVariableError();

                case 12:
                  resolvedArgs = pullTensorsFromArgs(args);
                  functionName = this.command.split('.').pop(); // If target exists, check if target contains the specific function and return computed results

                  if (!self) {
                    _context.next = 20;
                    break;
                  }

                  if (functionName in self) {
                    _context.next = 19;
                    break;
                  }

                  throw new CannotFindCommandError("tensor.".concat(functionName));

                case 19:
                  return _context.abrupt("return", (_self = self)[functionName].apply(_self, toConsumableArray(resolvedArgs)));

                case 20:
                  if (functionName in tf) {
                    _context.next = 24;
                    break;
                  }

                  throw new CannotFindCommandError(functionName);

                case 24:
                  return _context.abrupt("return", tf[functionName].apply(tf, toConsumableArray(resolvedArgs).concat(toConsumableArray(Object.values(this.kwargs)))));

                case 25:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function execute(_x) {
          return _execute.apply(this, arguments);
        }

        return execute;
      }()
    }], [{
      key: "unbufferize",
      value: function unbufferize$1(worker, pb) {
        return new ComputationAction(pb.command, unbufferize(worker, pb[pb.target]), unbufferize(worker, pb.args), unbufferize(worker, pb.kwargs), unbufferize(worker, pb.return_ids), unbufferize(worker, pb.return_placeholder_ids));
      }
    }]);

    return ComputationAction;
  }();

  var PB_CLASS_MAP, PB_TO_UNBUFFERIZER; // Because of cyclic dependencies between Protocol/etc modules and protobuf module
  // Protocol/etc classes are undefined at the moment when this module is imported

  var initMappings = function initMappings() {
    PB_CLASS_MAP = [[Protocol, protobuf$1.syft_proto.execution.v1.Protocol], [Plan, protobuf$1.syft_proto.execution.v1.Plan], [Role, protobuf$1.syft_proto.execution.v1.Role], [State$1, protobuf$1.syft_proto.execution.v1.State], [ComputationAction, protobuf$1.syft_proto.execution.v1.ComputationAction], [Placeholder, protobuf$1.syft_proto.execution.v1.Placeholder], [PlaceholderId, protobuf$1.syft_proto.execution.v1.PlaceholderId], [ObjectMessage, protobuf$1.syft_proto.messaging.v1.ObjectMessage], [TorchTensor, protobuf$1.syft_proto.types.torch.v1.TorchTensor], [TorchParameter, protobuf$1.syft_proto.types.torch.v1.Parameter]];
    PB_TO_UNBUFFERIZER = PB_CLASS_MAP.reduce(function (map, item) {
      map[item[1]] = item[0].unbufferize;
      return map;
    }, {});
  };

  var long_1 = Long;

  /**
   * wasm optimizations, to do native i64 multiplication and divide
   */
  var wasm = null;

  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
    ])), {}).exports;
  } catch (e) {
    // no wasm support :(
  }

  /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */
  function Long(low, high, unsigned) {

      /**
       * The low 32 bits as a signed value.
       * @type {number}
       */
      this.low = low | 0;

      /**
       * The high 32 bits as a signed value.
       * @type {number}
       */
      this.high = high | 0;

      /**
       * Whether unsigned or not.
       * @type {boolean}
       */
      this.unsigned = !!unsigned;
  }

  // The internal representation of a long is the two given signed, 32-bit values.
  // We use 32-bit pieces because these are the size of integers on which
  // Javascript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within Javascript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.

  /**
   * An indicator used to reliably determine if an object is a Long or not.
   * @type {boolean}
   * @const
   * @private
   */
  Long.prototype.__isLong__;

  Object.defineProperty(Long.prototype, "__isLong__", { value: true });

  /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */
  function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
  }

  /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */
  Long.isLong = isLong;

  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */
  var INT_CACHE = {};

  /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */
  var UINT_CACHE = {};

  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
          value >>>= 0;
          if (cache = (0 <= value && value < 256)) {
              cachedObj = UINT_CACHE[value];
              if (cachedObj)
                  return cachedObj;
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
              UINT_CACHE[value] = obj;
          return obj;
      } else {
          value |= 0;
          if (cache = (-128 <= value && value < 128)) {
              cachedObj = INT_CACHE[value];
              if (cachedObj)
                  return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
              INT_CACHE[value] = obj;
          return obj;
      }
  }

  /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromInt = fromInt;

  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromNumber(value, unsigned) {
      if (isNaN(value))
          return unsigned ? UZERO : ZERO;
      if (unsigned) {
          if (value < 0)
              return UZERO;
          if (value >= TWO_PWR_64_DBL)
              return MAX_UNSIGNED_VALUE;
      } else {
          if (value <= -TWO_PWR_63_DBL)
              return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
              return MAX_VALUE;
      }
      if (value < 0)
          return fromNumber(-value, unsigned).neg();
      return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
  }

  /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromNumber = fromNumber;

  /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
  }

  /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromBits = fromBits;

  /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */
  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

  /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */
  function fromString(str, unsigned, radix) {
      if (str.length === 0)
          throw Error('empty string');
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return ZERO;
      if (typeof unsigned === 'number') {
          // For goog.math.long compatibility
          radix = unsigned,
          unsigned = false;
      } else {
          unsigned = !! unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
          throw RangeError('radix');

      var p;
      if ((p = str.indexOf('-')) > 0)
          throw Error('interior hyphen');
      else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
      }

      // Do several (8) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.
      var radixToPower = fromNumber(pow_dbl(radix, 8));

      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i),
              value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
              var power = fromNumber(pow_dbl(radix, size));
              result = result.mul(power).add(fromNumber(value));
          } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber(value));
          }
      }
      result.unsigned = unsigned;
      return result;
  }

  /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */
  Long.fromString = fromString;

  /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromValue(val, unsigned) {
      if (typeof val === 'number')
          return fromNumber(val, unsigned);
      if (typeof val === 'string')
          return fromString(val, unsigned);
      // Throws for non-objects, converts non-instanceof Long:
      return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
  }

  /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
  Long.fromValue = fromValue;

  // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
  // no runtime penalty for these.

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_16_DBL = 1 << 16;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_24_DBL = 1 << 24;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

  /**
   * @type {!Long}
   * @const
   * @inner
   */
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

  /**
   * @type {!Long}
   * @inner
   */
  var ZERO = fromInt(0);

  /**
   * Signed zero.
   * @type {!Long}
   */
  Long.ZERO = ZERO;

  /**
   * @type {!Long}
   * @inner
   */
  var UZERO = fromInt(0, true);

  /**
   * Unsigned zero.
   * @type {!Long}
   */
  Long.UZERO = UZERO;

  /**
   * @type {!Long}
   * @inner
   */
  var ONE = fromInt(1);

  /**
   * Signed one.
   * @type {!Long}
   */
  Long.ONE = ONE;

  /**
   * @type {!Long}
   * @inner
   */
  var UONE = fromInt(1, true);

  /**
   * Unsigned one.
   * @type {!Long}
   */
  Long.UONE = UONE;

  /**
   * @type {!Long}
   * @inner
   */
  var NEG_ONE = fromInt(-1);

  /**
   * Signed negative one.
   * @type {!Long}
   */
  Long.NEG_ONE = NEG_ONE;

  /**
   * @type {!Long}
   * @inner
   */
  var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

  /**
   * Maximum signed value.
   * @type {!Long}
   */
  Long.MAX_VALUE = MAX_VALUE;

  /**
   * @type {!Long}
   * @inner
   */
  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

  /**
   * Maximum unsigned value.
   * @type {!Long}
   */
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

  /**
   * @type {!Long}
   * @inner
   */
  var MIN_VALUE = fromBits(0, 0x80000000|0, false);

  /**
   * Minimum signed value.
   * @type {!Long}
   */
  Long.MIN_VALUE = MIN_VALUE;

  /**
   * @alias Long.prototype
   * @inner
   */
  var LongPrototype = Long.prototype;

  /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @returns {number}
   */
  LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
  };

  /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @returns {number}
   */
  LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
          return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };

  /**
   * Converts the Long to a string written in the specified radix.
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */
  LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
          throw RangeError('radix');
      if (this.isZero())
          return '0';
      if (this.isNegative()) { // Unsigned Longs are never negative
          if (this.eq(MIN_VALUE)) {
              // We need to change the Long value before it can be negated, so we remove
              // the bottom-most digit in this base and then recurse to do the rest.
              var radixLong = fromNumber(radix),
                  div = this.div(radixLong),
                  rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
          } else
              return '-' + this.neg().toString(radix);
      }

      // Do several (6) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
          rem = this;
      var result = '';
      while (true) {
          var remDiv = rem.div(radixToPower),
              intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
              digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
              return digits + result;
          else {
              while (digits.length < 6)
                  digits = '0' + digits;
              result = '' + digits + result;
          }
      }
  };

  /**
   * Gets the high 32 bits as a signed integer.
   * @returns {number} Signed high bits
   */
  LongPrototype.getHighBits = function getHighBits() {
      return this.high;
  };

  /**
   * Gets the high 32 bits as an unsigned integer.
   * @returns {number} Unsigned high bits
   */
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
  };

  /**
   * Gets the low 32 bits as a signed integer.
   * @returns {number} Signed low bits
   */
  LongPrototype.getLowBits = function getLowBits() {
      return this.low;
  };

  /**
   * Gets the low 32 bits as an unsigned integer.
   * @returns {number} Unsigned low bits
   */
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
  };

  /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @returns {number}
   */
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative()) // Unsigned Longs are never negative
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
          if ((val & (1 << bit)) != 0)
              break;
      return this.high != 0 ? bit + 33 : bit + 1;
  };

  /**
   * Tests if this Long's value equals zero.
   * @returns {boolean}
   */
  LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
  };

  /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */
  LongPrototype.eqz = LongPrototype.isZero;

  /**
   * Tests if this Long's value is negative.
   * @returns {boolean}
   */
  LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
  };

  /**
   * Tests if this Long's value is positive.
   * @returns {boolean}
   */
  LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
  };

  /**
   * Tests if this Long's value is odd.
   * @returns {boolean}
   */
  LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
  };

  /**
   * Tests if this Long's value is even.
   * @returns {boolean}
   */
  LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
  };

  /**
   * Tests if this Long's value equals the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.equals = function equals(other) {
      if (!isLong(other))
          other = fromValue(other);
      if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
          return false;
      return this.high === other.high && this.low === other.low;
  };

  /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.eq = LongPrototype.equals;

  /**
   * Tests if this Long's value differs from the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(/* validates */ other);
  };

  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.neq = LongPrototype.notEquals;

  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.ne = LongPrototype.notEquals;

  /**
   * Tests if this Long's value is less than the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lessThan = function lessThan(other) {
      return this.comp(/* validates */ other) < 0;
  };

  /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lt = LongPrototype.lessThan;

  /**
   * Tests if this Long's value is less than or equal the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(/* validates */ other) <= 0;
  };

  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lte = LongPrototype.lessThanOrEqual;

  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.le = LongPrototype.lessThanOrEqual;

  /**
   * Tests if this Long's value is greater than the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(/* validates */ other) > 0;
  };

  /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.gt = LongPrototype.greaterThan;

  /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(/* validates */ other) >= 0;
  };

  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;

  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;

  /**
   * Compares this Long's value with the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  LongPrototype.compare = function compare(other) {
      if (!isLong(other))
          other = fromValue(other);
      if (this.eq(other))
          return 0;
      var thisNeg = this.isNegative(),
          otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
          return -1;
      if (!thisNeg && otherNeg)
          return 1;
      // At this point the sign bits are the same
      if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
      // Both are positive if at least one is unsigned
      return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
  };

  /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  LongPrototype.comp = LongPrototype.compare;

  /**
   * Negates this Long's value.
   * @returns {!Long} Negated Long
   */
  LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
      return this.not().add(ONE);
  };

  /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */
  LongPrototype.neg = LongPrototype.negate;

  /**
   * Returns the sum of this and the specified Long.
   * @param {!Long|number|string} addend Addend
   * @returns {!Long} Sum
   */
  LongPrototype.add = function add(addend) {
      if (!isLong(addend))
          addend = fromValue(addend);

      // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xFFFF;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xFFFF;

      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xFFFF;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xFFFF;

      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 + b48;
      c48 &= 0xFFFF;
      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
  };

  /**
   * Returns the difference of this and the specified Long.
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
  };

  /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  LongPrototype.sub = LongPrototype.subtract;

  /**
   * Returns the product of this and the specified Long.
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
          return ZERO;
      if (!isLong(multiplier))
          multiplier = fromValue(multiplier);

      // use wasm support if present
      if (wasm) {
          var low = wasm.mul(this.low,
                             this.high,
                             multiplier.low,
                             multiplier.high);
          return fromBits(low, wasm.get_high(), this.unsigned);
      }

      if (multiplier.isZero())
          return ZERO;
      if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;

      if (this.isNegative()) {
          if (multiplier.isNegative())
              return this.neg().mul(multiplier.neg());
          else
              return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();

      // If both longs are small, use float multiplication
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

      // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
      // We can skip products that would overflow.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xFFFF;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xFFFF;

      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xFFFF;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xFFFF;

      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xFFFF;
      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
  };

  /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  LongPrototype.mul = LongPrototype.multiply;

  /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
          divisor = fromValue(divisor);
      if (divisor.isZero())
          throw Error('division by zero');

      // use wasm support if present
      if (wasm) {
          // guard against signed division overflow: the largest
          // negative number / -1 would be 1 larger than the largest
          // positive number, due to two's complement.
          if (!this.unsigned &&
              this.high === -0x80000000 &&
              divisor.low === -1 && divisor.high === -1) {
              // be consistent with non-wasm code path
              return this;
          }
          var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
              this.low,
              this.high,
              divisor.low,
              divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
      }

      if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
          // This section is only relevant for signed longs and is derived from the
          // closure library as a whole.
          if (this.eq(MIN_VALUE)) {
              if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                  return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
              else if (divisor.eq(MIN_VALUE))
                  return ONE;
              else {
                  // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                  var halfThis = this.shr(1);
                  approx = halfThis.div(divisor).shl(1);
                  if (approx.eq(ZERO)) {
                      return divisor.isNegative() ? ONE : NEG_ONE;
                  } else {
                      rem = this.sub(divisor.mul(approx));
                      res = approx.add(rem.div(divisor));
                      return res;
                  }
              }
          } else if (divisor.eq(MIN_VALUE))
              return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
              if (divisor.isNegative())
                  return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
              return this.div(divisor.neg()).neg();
          res = ZERO;
      } else {
          // The algorithm below has not been made for unsigned longs. It's therefore
          // required to take special care of the MSB prior to running it.
          if (!divisor.unsigned)
              divisor = divisor.toUnsigned();
          if (divisor.gt(this))
              return UZERO;
          if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
              return UONE;
          res = UZERO;
      }

      // Repeat the following until the remainder is less than other:  find a
      // floating-point that approximates remainder / other *from below*, add this
      // into the result, and subtract it from the remainder.  It is critical that
      // the approximate value is less than or equal to the real value so that the
      // remainder never becomes negative.
      rem = this;
      while (rem.gte(divisor)) {
          // Approximate the result of division. This may be a little greater or
          // smaller than the actual value.
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

          // We will tweak the approximate result by changing it in the 48-th digit or
          // the smallest non-fractional digit, whichever is larger.
          var log2 = Math.ceil(Math.log(approx) / Math.LN2),
              delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

          // Decrease the approximation until it is smaller than the remainder.  Note
          // that if it is too large, the product overflows and is negative.
              approxRes = fromNumber(approx),
              approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
          }

          // We know the answer can't be zero... and actually, zero would cause
          // infinite recursion since we would make no progress.
          if (approxRes.isZero())
              approxRes = ONE;

          res = res.add(approxRes);
          rem = rem.sub(approxRem);
      }
      return res;
  };

  /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  LongPrototype.div = LongPrototype.divide;

  /**
   * Returns this Long modulo the specified.
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
          divisor = fromValue(divisor);

      // use wasm support if present
      if (wasm) {
          var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
              this.low,
              this.high,
              divisor.low,
              divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
      }

      return this.sub(this.div(divisor).mul(divisor));
  };

  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.mod = LongPrototype.modulo;

  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.rem = LongPrototype.modulo;

  /**
   * Returns the bitwise NOT of this Long.
   * @returns {!Long}
   */
  LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
  };

  /**
   * Returns the bitwise AND of this Long and the specified.
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.and = function and(other) {
      if (!isLong(other))
          other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };

  /**
   * Returns the bitwise OR of this Long and the specified.
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.or = function or(other) {
      if (!isLong(other))
          other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };

  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.xor = function xor(other) {
      if (!isLong(other))
          other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };

  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
          numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
          return this;
      else if (numBits < 32)
          return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
      else
          return fromBits(0, this.low << (numBits - 32), this.unsigned);
  };

  /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shl = LongPrototype.shiftLeft;

  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
          numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
          return this;
      else if (numBits < 32)
          return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
      else
          return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
  };

  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shr = LongPrototype.shiftRight;

  /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
          numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
          return this;
      else {
          var high = this.high;
          if (numBits < 32) {
              var low = this.low;
              return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
          } else if (numBits === 32)
              return fromBits(high, 0, this.unsigned);
          else
              return fromBits(high >>> (numBits - 32), 0, this.unsigned);
      }
  };

  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;

  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

  /**
   * Converts this Long to signed.
   * @returns {!Long} Signed long
   */
  LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
          return this;
      return fromBits(this.low, this.high, false);
  };

  /**
   * Converts this Long to unsigned.
   * @returns {!Long} Unsigned long
   */
  LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
          return this;
      return fromBits(this.low, this.high, true);
  };

  /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {!Array.<number>} Byte representation
   */
  LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
  };

  /**
   * Converts this Long to its little endian byte representation.
   * @returns {!Array.<number>} Little endian byte representation
   */
  LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high,
          lo = this.low;
      return [
          lo        & 0xff,
          lo >>>  8 & 0xff,
          lo >>> 16 & 0xff,
          lo >>> 24       ,
          hi        & 0xff,
          hi >>>  8 & 0xff,
          hi >>> 16 & 0xff,
          hi >>> 24
      ];
  };

  /**
   * Converts this Long to its big endian byte representation.
   * @returns {!Array.<number>} Big endian byte representation
   */
  LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high,
          lo = this.low;
      return [
          hi >>> 24       ,
          hi >>> 16 & 0xff,
          hi >>>  8 & 0xff,
          hi        & 0xff,
          lo >>> 24       ,
          lo >>> 16 & 0xff,
          lo >>>  8 & 0xff,
          lo        & 0xff
      ];
  };

  /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };

  /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
          bytes[0]       |
          bytes[1] <<  8 |
          bytes[2] << 16 |
          bytes[3] << 24,
          bytes[4]       |
          bytes[5] <<  8 |
          bytes[6] << 16 |
          bytes[7] << 24,
          unsigned
      );
  };

  /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
          bytes[4] << 24 |
          bytes[5] << 16 |
          bytes[6] <<  8 |
          bytes[7],
          bytes[0] << 24 |
          bytes[1] << 16 |
          bytes[2] <<  8 |
          bytes[3],
          unsigned
      );
  };

  var unbufferize = function unbufferize(worker, pbObj) {
    if (!PB_TO_UNBUFFERIZER) {
      initMappings();
    }

    if (pbObj === undefined || pbObj === null || ['number', 'string', 'boolean'].includes(_typeof_1(pbObj))) {
      return pbObj;
    }

    var pbType = pbObj.constructor; // automatically unbufferize repeated fields

    if (Array.isArray(pbObj)) {
      return pbObj.map(function (item) {
        return unbufferize(worker, item);
      });
    } // automatically unbufferize map fields


    if (pbType.name === 'Object') {
      var res = {};

      for (var _i = 0, _Object$keys = Object.keys(pbObj); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        res[key] = unbufferize(worker, pbObj[key]);
      }

      return res;
    } // automatically unbufferize Id


    if (pbType === protobuf$1.syft_proto.types.syft.v1.Id) {
      return getPbId(pbObj);
    } // automatically unwrap Arg


    if (pbType === protobuf$1.syft_proto.types.syft.v1.Arg) {
      if (pbObj.arg === 'arg_int' && pbObj[pbObj.arg] instanceof long_1) {
        // protobuf int64 is represented as Long
        return pbObj[pbObj.arg].toNumber();
      } else {
        return unbufferize(worker, pbObj[pbObj.arg]);
      }
    } // automatically unwrap ArgList


    if (pbType === protobuf$1.syft_proto.types.syft.v1.ArgList) {
      return unbufferize(worker, pbObj.args);
    }

    var unbufferizer = PB_TO_UNBUFFERIZER[pbType];

    if (typeof unbufferizer === 'undefined') {
      throw new NoDetailerError(pbType.name);
    }

    return unbufferizer(worker, pbObj);
  };
  /**
   * Converts binary in the form of ArrayBuffer or base64 string to syft class
   * @param worker
   * @param bin
   * @param pbType
   * @returns {Object}
   */

  var unserialize = function unserialize(worker, bin, pbType) {
    var buff = typeof bin === 'string' ? base64Decode(bin) : bin instanceof ArrayBuffer ? new Uint8Array(bin) : bin;
    var pbObj;

    try {
      pbObj = pbType.decode(buff);
    } catch (e) {
      throw new ProtobufUnserializeFailedError(pbType.name, e.message);
    }

    return unbufferize(worker, pbObj);
  };
  /**
   * Converts syft class to protobuf-serialized binary
   * @param worker
   * @param obj
   * @returns {ArrayBuffer}
   */

  var serialize = function serialize(worker, obj) {
    var pbObj = obj.bufferize(worker);
    var pbType = pbObj.constructor;
    var err = pbType.verify(pbObj);

    if (err) {
      throw new Error(err);
    }

    var bin = pbType.encode(pbObj).finish();
    return new Uint8Array(bin).buffer;
  };
  var getPbId = function getPbId(field) {
    // convert int64 to string
    return field[field.id].toString();
  };
  var pbId = function pbId(value) {
    if (typeof value === 'number') {
      return protobuf$1.syft_proto.types.syft.v1.Id.create({
        id_int: value
      });
    } else if (typeof value === 'string') {
      return protobuf$1.syft_proto.types.syft.v1.Id.create({
        id_str: value
      });
    }
  };

  /**
   * Model parameters as stored in the PyGrid.
   *
   * @property {[tf.Tensor]} params - Array of Model parameters.
   */

  var SyftModel = /*#__PURE__*/function () {
    /**
     * @hideconstructor
     * @param {Object} options
     * @param {Syft} options.worker - Instance of Syft client.
     * @param {ArrayBuffer} options.serializedModelParameters - Serialized Model parameters as returned by PyGrid.
     * @param {[tf.Tensor]} options.modelParameters - Serialized Model parameters as returned by PyGrid.
     */
    function SyftModel(_ref) {
      var worker = _ref.worker,
          _ref$serializedModelP = _ref.serializedModelParameters,
          serializedModelParameters = _ref$serializedModelP === void 0 ? null : _ref$serializedModelP,
          _ref$modelParameters = _ref.modelParameters,
          modelParameters = _ref$modelParameters === void 0 ? null : _ref$modelParameters;

      classCallCheck(this, SyftModel);

      this.worker = worker;

      if (serializedModelParameters) {
        // Convert model from binary and store model weights in the syft class State
        try {
          var state = unserialize(worker, serializedModelParameters, protobuf$1.syft_proto.execution.v1.State);
          this.params = state.getTfTensors();
        } catch (e) {
          throw new ModelLoadFailedError(e.message);
        }
      }

      if (modelParameters) {
        this.params = modelParameters;
      }
    }
    /**
     * Returns model serialized to protobuf.
     *
     * @return {Promise<ArrayBuffer>}
     */


    createClass(SyftModel, [{
      key: "toProtobuf",
      value: function () {
        var _toProtobuf = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var placeholders, tensors, i, state;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  placeholders = [], tensors = [];
                  i = 0;

                case 2:
                  if (!(i < this.params.length)) {
                    _context.next = 12;
                    break;
                  }

                  placeholders.push(new Placeholder(i, ["#".concat(i), "#state-".concat(i)]));
                  _context.t0 = tensors;
                  _context.next = 7;
                  return TorchTensor.fromTfTensor(this.params[i]);

                case 7:
                  _context.t1 = _context.sent;

                  _context.t0.push.call(_context.t0, _context.t1);

                case 9:
                  i++;
                  _context.next = 2;
                  break;

                case 12:
                  state = new State$1(placeholders, tensors);
                  return _context.abrupt("return", serialize(this.worker, state));

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function toProtobuf() {
          return _toProtobuf.apply(this, arguments);
        }

        return toProtobuf;
      }()
      /**
       * Calculates difference between 2 versions of the Model parameters
       * and returns serialized `diff` that can be submitted to PyGrid.
       *
       * @param {Array.<tf.Tensor>} updatedModelParams - Array of model parameters (tensors).
       * @returns {Promise<ArrayBuffer>} Protobuf-serialized `diff`.
       */

    }, {
      key: "createSerializedDiff",
      value: function () {
        var _createSerializedDiff = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(updatedModelParams) {
          var placeholders, tensors, i, paramDiff, state, bin;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  placeholders = [], tensors = []; // Store model weight differences in a new State and convert to protobuf-serialized binary

                  i = 0;

                case 2:
                  if (!(i < updatedModelParams.length)) {
                    _context2.next = 13;
                    break;
                  }

                  paramDiff = this.params[i].sub(updatedModelParams[i]);
                  placeholders.push(new Placeholder(i, ["#".concat(i), "#state-".concat(i)]));
                  _context2.t0 = tensors;
                  _context2.next = 8;
                  return TorchTensor.fromTfTensor(paramDiff);

                case 8:
                  _context2.t1 = _context2.sent;

                  _context2.t0.push.call(_context2.t0, _context2.t1);

                case 10:
                  i++;
                  _context2.next = 2;
                  break;

                case 13:
                  state = new State$1(placeholders, tensors);
                  bin = serialize(this.worker, state); // Free up memory

                  tensors.forEach(function (t) {
                    return t._tfTensor.dispose();
                  });
                  return _context2.abrupt("return", bin);

                case 17:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function createSerializedDiff(_x) {
          return _createSerializedDiff.apply(this, arguments);
        }

        return createSerializedDiff;
      }()
      /**
       * Calculates difference between 2 versions of the Model
       * and returns serialized `diff` that can be submitted to PyGrid.
       *
       * @param {SyftModel} model - Model to compare with.
       * @returns {Promise<ArrayBuffer>} Protobuf-serialized `diff`.
       */

    }, {
      key: "createSerializedDiffFromModel",
      value: function () {
        var _createSerializedDiffFromModel = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(model) {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", this.createSerializedDiff(model.params));

                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function createSerializedDiffFromModel(_x2) {
          return _createSerializedDiffFromModel.apply(this, arguments);
        }

        return createSerializedDiffFromModel;
      }()
    }]);

    return SyftModel;
  }();

  function _createForOfIteratorHelper$2(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

  function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Base transformation class.
   *
   * @param {...Object} options - Each argument is an options dict for an individual input
   */
  var Transform = /*#__PURE__*/function () {
    function Transform() {
      classCallCheck(this, Transform);

      for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
        options[_key] = arguments[_key];
      }

      this.options = options;
    }

    createClass(Transform, [{
      key: "apply",
      value: function apply() {
        var _this = this;

        for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          items[_key2] = arguments[_key2];
        }

        return items.map(function (item, idx) {
          if (!_this.options[idx]) {
            return item;
          }

          return _this.applyToItem(item, _this.options[idx]);
        });
      }
    }, {
      key: "applyToItem",
      value: function applyToItem(item
      /* options */
      ) {
        // no-op
        return item;
      }
    }]);

    return Transform;
  }();
  /**
   * Composes multiple transforms into one.
   *
   * @param {Transform[]} transforms - Array of transforms
   */

  var Compose = /*#__PURE__*/function (_Transform) {
    inherits(Compose, _Transform);

    var _super = _createSuper$2(Compose);

    function Compose(transforms) {
      var _this2;

      classCallCheck(this, Compose);

      _this2 = _super.call(this);
      _this2.transforms = transforms;
      return _this2;
    }

    createClass(Compose, [{
      key: "apply",
      value: function apply() {
        for (var _len3 = arguments.length, data = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          data[_key3] = arguments[_key3];
        }

        var _data = data;

        var _iterator = _createForOfIteratorHelper$2(this.transforms),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var transform = _step.value;
            _data = transform.apply.apply(transform, toConsumableArray(_data));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return _data;
      }
    }]);

    return Compose;
  }(Transform);

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Transform: Transform,
    Compose: Compose
  });

  function _toArray(arr) {
    return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
  }

  var toArray = _toArray;

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Converts numeric data to tfjs tensor of specified shape and dtype.
   *
   * @param {...Object} options - Options dict per each input
   * @param {Number[]} options.shape - Tensor shape
   * @param {String} options.dtype - Tensor dtype
   */

  var ToTensor = /*#__PURE__*/function (_Transform) {
    inherits(ToTensor, _Transform);

    var _super = _createSuper$3(ToTensor);

    function ToTensor() {
      classCallCheck(this, ToTensor);

      return _super.apply(this, arguments);
    }

    createClass(ToTensor, [{
      key: "applyToItem",
      value: function applyToItem(item, options) {
        var _ref = options || {},
            _ref$shape = _ref.shape,
            shape = _ref$shape === void 0 ? null : _ref$shape,
            _ref$dtype = _ref.dtype,
            dtype = _ref$dtype === void 0 ? null : _ref$dtype;

        return tf.tensor(item, shape, dtype);
      }
    }]);

    return ToTensor;
  }(Transform);
  /**
   * Scales tensor using mean/std.
   *
   * @param {...Object} options - Options dict per each input
   * @param {Number[]} options.mean - Mean (one item per channel)
   * @param {Number[]} options.std - Std (one item per channel)
   */

  var Normalize = /*#__PURE__*/function (_Transform2) {
    inherits(Normalize, _Transform2);

    var _super2 = _createSuper$3(Normalize);

    function Normalize() {
      classCallCheck(this, Normalize);

      return _super2.apply(this, arguments);
    }

    createClass(Normalize, [{
      key: "applyToItem",
      value: function applyToItem(item, options) {
        var mean = options.mean,
            std = options.std;
        var channels = mean.length;
        var dataChannels, dataShape;

        if (item.rank <= 1) {
          dataChannels = 1;
          dataShape = item.shape;
        } else {
          var _item$shape = toArray(item.shape);

          dataChannels = _item$shape[0];
          dataShape = _item$shape.slice(1);
        }

        if (channels !== 1 && dataChannels !== channels) {
          throw new TypeError('Number of channels does not match');
        }

        var result;

        if (channels > 1) {
          var means = [];
          var stds = [];

          for (var i = 0; i < channels; i++) {
            means.push(tf.zeros(dataShape).add(mean[i]));
            stds.push(tf.zeros(dataShape).add(std[i]));
          }

          result = item.sub(tf.stack(means)).div(tf.stack(stds));
        } else {
          result = item.sub(mean[0]).div(std[0]);
        }

        return result;
      }
    }]);

    return Normalize;
  }(Transform);
  /**
   * One-hot encoding of tensor.
   *
   * @param {...Object} options - Options dict per each input
   * @param {Number} options.depth - Number of classes for one-hot encoding
   * @param {Boolean} options.squeeze - Do not add extra dimension
   */

  var OneHot = /*#__PURE__*/function (_Transform3) {
    inherits(OneHot, _Transform3);

    var _super3 = _createSuper$3(OneHot);

    function OneHot() {
      classCallCheck(this, OneHot);

      return _super3.apply(this, arguments);
    }

    createClass(OneHot, [{
      key: "applyToItem",
      value: function applyToItem(item, options) {
        var depth = options.depth,
            _options$squeeze = options.squeeze,
            squeeze = _options$squeeze === void 0 ? false : _options$squeeze;
        var oneHot = tf.oneHot(item, depth);

        if (squeeze) {
          return tf.squeeze(oneHot);
        }

        return oneHot;
      }
    }]);

    return OneHot;
  }(Transform);

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ToTensor: ToTensor,
    Normalize: Normalize,
    OneHot: OneHot
  });

  var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    core: index,
    tfjs: index$1
  });

  /**
   * Abstract class for Dataset.
   * `getItem` method and `length` getter must be defined in the child class.
   *
   * @example
   * class MyDataset extends Dataset {
   *   constructor() {
   *     super();
   *     this.data = [1, 2, 3, 4, 5].map(i => tf.tensor(i));
   *     this.labels = [0, 0, 1, 0, 1].map(i => tf.tensor(i));
   *   }
   *
   *   getItem(index) {
   *     return [this.data[index], this.labels[index]];
   *   }
   *
   *   get length() {
   *     return this.data.length;
   *   }
   * }
   *
   * const ds = new MyDataset();
   * ds[0][0].print() // => Tensor 1
   * ds[0][1].print() // => Tensor 0
   *
   * @property {Function} getItem - Returns a sample
   * @property {Number} length - Length of the datasets
   * @abstract
   */
  var Dataset = function Dataset() {
    classCallCheck(this, Dataset);

    if ((this instanceof Dataset ? this.constructor : void 0) === Dataset) {
      throw new TypeError('Dataset is abstract, extend it');
    }

    if (this.getItem === undefined) {
      throw new TypeError('Override getItem method');
    }

    if (Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), 'length').get === undefined) {
      throw new TypeError('Override length getter');
    } // Make dataset[x] work


    var subscriptableHandler = {
      get: function get(target, prop
      /* receiver */
      ) {
        var possibleIdx = parseInt(prop);

        if (Number.isInteger(possibleIdx) && possibleIdx >= 0) {
          return target.getItem(prop);
        } else {
          return Reflect.get.apply(Reflect, arguments);
        }
      }
    };
    return new Proxy(this, subscriptableHandler);
  };

  function _createForOfIteratorHelper$3(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

  function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Abstract Sampler class.
   * Sampler produces indices for fetching samples from the Dataset.
   *
   * @private
   */
  var Sampler = function Sampler(dataset) {
    classCallCheck(this, Sampler);

    if ((this instanceof Sampler ? this.constructor : void 0) === Sampler) {
      throw new TypeError('Sampler is abstract, extend it');
    }

    if (this[Symbol.iterator] === undefined) {
      throw new TypeError('Override iterator method');
    }

    if (Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), 'length').get === undefined) {
      throw new TypeError('Override length getter');
    }

    this.dataset = dataset;
  };
  /**
   * Sequential sampler produces indices in sequential order.

   * @private
   * @param {Dataset} dataset
   */

  var SequentialSampler = /*#__PURE__*/function (_Sampler) {
    inherits(SequentialSampler, _Sampler);

    var _super = _createSuper$4(SequentialSampler);

    function SequentialSampler(dataset) {
      classCallCheck(this, SequentialSampler);

      return _super.call(this, dataset);
    }

    createClass(SequentialSampler, [{
      key: Symbol.iterator,
      value: /*#__PURE__*/regenerator.mark(function value() {
        var i;
        return regenerator.wrap(function value$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                i = 0;

              case 1:
                if (!(i < this.dataset.length)) {
                  _context.next = 7;
                  break;
                }

                _context.next = 4;
                return i;

              case 4:
                i++;
                _context.next = 1;
                break;

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, value, this);
      })
    }, {
      key: "length",
      get: function get() {
        return this.dataset.length;
      }
    }]);

    return SequentialSampler;
  }(Sampler);
  /**
   * Random sampler produces random indices drawn from uniform distribution.
   *
   * @private
   * @param {Dataset} dataset
   */

  var RandomSampler = /*#__PURE__*/function (_Sampler2) {
    inherits(RandomSampler, _Sampler2);

    var _super2 = _createSuper$4(RandomSampler);

    function RandomSampler(dataset) {
      classCallCheck(this, RandomSampler);

      return _super2.call(this, dataset);
    }

    createClass(RandomSampler, [{
      key: Symbol.iterator,
      value: /*#__PURE__*/regenerator.mark(function value() {
        var indices, i, j, _ref;

        return regenerator.wrap(function value$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // Create & shuffle list of dataset indices
                indices = toConsumableArray(Array(this.dataset.length).keys());

                for (i = indices.length - 1; i > 0; i--) {
                  j = Math.floor(Math.random() * (i + 1));
                  _ref = [indices[j], indices[i]];
                  indices[i] = _ref[0];
                  indices[j] = _ref[1];
                }

                return _context2.delegateYield(indices, "t0", 3);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, value, this);
      })
    }, {
      key: "length",
      get: function get() {
        return this.dataset.length;
      }
    }]);

    return RandomSampler;
  }(Sampler);
  /**
   * Batch sampler produces batched indices of other samplers.
   *
   * @private
   * @param {Sampler} sampler - Sampler to use for batching
   * @param {Number} batchSize - Batch size
   * @param {Boolean} dropLast - Whether the last undersized batch should be omitted
   */

  var BatchSampler = /*#__PURE__*/function (_Sampler3) {
    inherits(BatchSampler, _Sampler3);

    var _super3 = _createSuper$4(BatchSampler);

    function BatchSampler(sampler, batchSize, dropLast) {
      var _this;

      classCallCheck(this, BatchSampler);

      _this = _super3.call(this);
      _this.sampler = sampler;
      _this.batchSize = batchSize;
      _this.dropLast = dropLast;
      return _this;
    }

    createClass(BatchSampler, [{
      key: Symbol.iterator,
      value: /*#__PURE__*/regenerator.mark(function value() {
        var batch, _iterator, _step, idx;

        return regenerator.wrap(function value$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                batch = [];
                _iterator = _createForOfIteratorHelper$3(this.sampler);
                _context3.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context3.next = 13;
                  break;
                }

                idx = _step.value;
                batch.push(idx);

                if (!(batch.length === this.batchSize)) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 10;
                return batch;

              case 10:
                batch = [];

              case 11:
                _context3.next = 4;
                break;

              case 13:
                _context3.next = 18;
                break;

              case 15:
                _context3.prev = 15;
                _context3.t0 = _context3["catch"](2);

                _iterator.e(_context3.t0);

              case 18:
                _context3.prev = 18;

                _iterator.f();

                return _context3.finish(18);

              case 21:
                if (!(batch.length > 0 && !this.dropLast)) {
                  _context3.next = 24;
                  break;
                }

                _context3.next = 24;
                return batch;

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, value, this, [[2, 15, 18, 21]]);
      })
    }, {
      key: "length",
      get: function get() {
        return Math[this.dropLast ? 'floor' : 'ceil'](this.sampler.length / this.batchSize);
      }
    }]);

    return BatchSampler;
  }(Sampler);

  function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Base class for dataset fetchers.
   * Fetcher takes index or list of indices and returns collated samples from the dataset.
   *
   * @private
   * @param {Dataset} dataset - Dataset to fetch from
   * @param {Function} collateFn - Collate function
   * @param {Boolean} dropLast - If the last batch needs to be dropped
   */
  var BaseDatasetFetcher = /*#__PURE__*/function () {
    function BaseDatasetFetcher(dataset, collateFn, dropLast) {
      classCallCheck(this, BaseDatasetFetcher);

      this.dataset = dataset;
      this.collateFn = collateFn;
      this.dropLast = dropLast;
    }

    createClass(BaseDatasetFetcher, [{
      key: "fetch",
      value: function fetch()
      /* index */
      {}
    }]);

    return BaseDatasetFetcher;
  }();
  /**
   * Map-style dataset fetcher.
   * Assumes that a dataset sample can be accessed by specific index,
   * i.e. it is not iterable-style dataset.
   *
   * @private
   */


  var MapDatasetFetcher = /*#__PURE__*/function (_BaseDatasetFetcher) {
    inherits(MapDatasetFetcher, _BaseDatasetFetcher);

    var _super = _createSuper$5(MapDatasetFetcher);

    function MapDatasetFetcher(dataset, collateFn, dropLast) {
      classCallCheck(this, MapDatasetFetcher);

      return _super.call(this, dataset, collateFn, dropLast);
    }
    /**
     * Fetches a sample or batch of samples from the dataset.
     *
     * @param {Number[]|Number} indices
     * @return {*}
     */


    createClass(MapDatasetFetcher, [{
      key: "fetch",
      value: function fetch(indices) {
        var _this = this;

        var data;

        if (Array.isArray(indices)) {
          data = indices.map(function (idx) {
            return _this.dataset.getItem(idx);
          });
        } else {
          data = this.dataset.getItem(indices);
        }

        return this.collateFn(data);
      }
    }]);

    return MapDatasetFetcher;
  }(BaseDatasetFetcher);

  /**
   * Collates list of samples into one tensor.
   * When sample is a list or dictionary of tensors:
   *  `[[sampleA1, sampleB1], [sampleA2, sampleB2], ... ]`
   *  `[{a: sampleA1, b: sampleB1}, {a: sampleA2, b: sampleB2}, ... ]`
   * result is a list or dict of collated samples:
   *  `[batchA, batchB]`
   *  `{a: batchA, b: batchB}`
   *
   * @param {Array<tf.Tensor>|Array<Array<tf.Tensor>>|Object} batch - List of data samples to collate
   * @return {tf.Tensor|{}|tf.Tensor[]}
   */

  var tfjs_collate = function tfjs_collate(batch) {
    var elem = batch[0];

    if (elem instanceof tf.Tensor) {
      // List of Tensors to stack
      return tf.stack(batch, 0);
    } else if (Array.isArray(elem)) {
      // Sample is a list, we need to collate each element of it
      var params = [];

      var _loop = function _loop(i) {
        params.push(tfjs_collate(batch.map(function (item) {
          return item[i];
        })));
      };

      for (var i = 0; i < elem.length; i++) {
        _loop(i);
      }

      return params;
    } else if (_typeof_1(batch) === 'object' && !!batch) {
      // Sample is an object, we need to collate each property of it
      var dict = {};

      var _loop2 = function _loop2() {
        var key = _Object$keys[_i];
        dict[key] = tfjs_collate(batch.map(function (item) {
          return item[key];
        }));
      };

      for (var _i = 0, _Object$keys = Object.keys(elem); _i < _Object$keys.length; _i++) {
        _loop2();
      }

      return dict;
    }
  };

  function _createForOfIteratorHelper$4(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

  function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * DataLoader controls fetching the data from the Dataset,
   * including shuffling and batching.
   * Implements iterable protocol to iterate over data samples.
   *
   * Note: currently it only supports tf.Tensor data in the dataset,
   * and collates batches using TFJS.
   *
   * @example
   * const loader = new DataLoader({dataset, batchSize: 32})
   * consle.log('number of batches: ', loader.length)
   * for (let batch of loader) {
   *   // ...
   * }
   *
   * @param {Object} parameters
   * @param {Dataset} parameters.dataset - Dataset to load
   * @param {Number} parameters.batchSize - Batch size for batching
   * @param {Boolean} parameters.shuffle - Shuffle the Dataset
   * @param {Boolean} parameters.dropLast - Skip the last chunk if it is smaller than the `batchSize`
   *
   * @property {Number} length - Data length.
   */

  var DataLoader = /*#__PURE__*/function () {
    function DataLoader(_ref) {
      var dataset = _ref.dataset,
          _ref$batchSize = _ref.batchSize,
          batchSize = _ref$batchSize === void 0 ? 1 : _ref$batchSize,
          _ref$shuffle = _ref.shuffle,
          shuffle = _ref$shuffle === void 0 ? true : _ref$shuffle,
          _ref$dropLast = _ref.dropLast,
          dropLast = _ref$dropLast === void 0 ? false : _ref$dropLast;

      classCallCheck(this, DataLoader);

      this.dataset = dataset;
      this.batchSize = batchSize;
      this.shuffle = shuffle;
      this.dropLast = dropLast;

      if (this.shuffle) {
        this.sampler = new RandomSampler(this.dataset);
      } else {
        this.sampler = new SequentialSampler(this.dataset);
      }

      this.batchSampler = new BatchSampler(this.sampler, this.batchSize, this.dropLast); // Default collate function supports TFJS only

      this.collateFn = tfjs_collate;
    }
    /**
     * Iterator producing data batches.
     * @return {*}
     */


    createClass(DataLoader, [{
      key: Symbol.iterator,
      value: /*#__PURE__*/regenerator.mark(function value() {
        var iterator;
        return regenerator.wrap(function value$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                iterator = new SimpleDataloaderIterator(this);
                return _context.delegateYield(iterator, "t0", 2);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, value, this);
      })
      /**
       * Returns indices sampler.
       * @private
       * @return {Sampler}
       */

    }, {
      key: "indexSampler",
      get: function get() {
        return this.batchSampler;
      }
    }, {
      key: "length",
      get: function get() {
        return this.indexSampler.length;
      }
    }]);

    return DataLoader;
  }();
  /**
   * Base class for DataLoader iterator.
   *
   * @private
   * @param {DataLoader} loader - DataLoader to iterate
   */

  var BaseDataLoaderIterator = function BaseDataLoaderIterator(loader) {
    classCallCheck(this, BaseDataLoaderIterator);

    this.indexSampler = loader.indexSampler;
    this.collateFn = loader.collateFn;
    this.datasetFetcher = new MapDatasetFetcher(loader.dataset, loader.collateFn, loader.dropLast);
  };
  /**
   * Simple Dataloader iterator that sequentially fetches
   * dataset samples as a single worker.
   *
   * @private
   * @param {DataLoader} loader - DataLoader to iterate
   */


  var SimpleDataloaderIterator = /*#__PURE__*/function (_BaseDataLoaderIterat) {
    inherits(SimpleDataloaderIterator, _BaseDataLoaderIterat);

    var _super = _createSuper$6(SimpleDataloaderIterator);

    function SimpleDataloaderIterator(loader) {
      classCallCheck(this, SimpleDataloaderIterator);

      return _super.call(this, loader);
    }

    createClass(SimpleDataloaderIterator, [{
      key: Symbol.iterator,
      value: /*#__PURE__*/regenerator.mark(function value() {
        var _iterator, _step, index;

        return regenerator.wrap(function value$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _iterator = _createForOfIteratorHelper$4(this.indexSampler);
                _context2.prev = 1;

                _iterator.s();

              case 3:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 9;
                  break;
                }

                index = _step.value;
                _context2.next = 7;
                return this.datasetFetcher.fetch(index);

              case 7:
                _context2.next = 3;
                break;

              case 9:
                _context2.next = 14;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](1);

                _iterator.e(_context2.t0);

              case 14:
                _context2.prev = 14;

                _iterator.f();

                return _context2.finish(14);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, value, this, [[1, 11, 14, 17]]);
      })
    }]);

    return SimpleDataloaderIterator;
  }(BaseDataLoaderIterator);

  var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    transform: index$2,
    Dataset: Dataset,
    DataLoader: DataLoader
  });

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Class that contains training loop logic.
   *
   * @property {SyftModel} originalModel - Original model.
   * @property {SyftModel} currentModel - Trained model.
   * @property {number} epoch - Current epoch.
   * @property {number} batchIdx - Current batch.
   * @property {boolean} stopped - Is the training currently stopped.
   */

  var PlanTrainer = /*#__PURE__*/function () {
    /**
     * @hideconstructor
     * @param {Object} parameters - Dictionary of training parameters.
     * @param {Syft} parameters.worker - Syft Worker.
     * @param {Plan} parameters.plan - Training Plan to execute.
     * @param {[PlanInputSpec]} parameters.inputs - Plan input specification.
     * @param {[PlanOutputSpec]} parameters.outputs - Plan output specification.
     * @param {SyftModel} parameters.model - Model to train.
     * @param {DataLoader|tf.Tensor} parameters.data - DataLoader or plain tensor containing training data.
     * @param {tf.Tensor} [parameters.target] - Training labels (optional if `data` is DataLoader).
     * @param {number} parameters.epochs - Number of epochs.
     * @param {number} [parameters.batchSize] - Batch size. Optional if `data` is DataLoader.
     * @param {number} [parameters.stepsPerEpoch] - Optional max number of steps in epoch.
     * @param {Object} [parameters.clientConfig] - Optional dictionary of additional client configuration parameters.
     * @param {Object} [parameters.checkpoint] - Checkpoint.
     * @param {Object} [parameters.events] - Optional dictionary of events.
     * @param {Function} [parameters.events.start] - Training start event handler.
     * @param {Function} [parameters.events.end] - Training end event handler.
     * @param {Function} [parameters.events.stop] - Training stop event handler.
     * @param {Function} [parameters.events.epochStart] - Training epoch start event handler.
     * @param {Function} [parameters.events.epochEnd] - Training epoch end event handler.
     * @param {Function} [parameters.events.batchStart] - Training batch start event handler.
     * @param {Function} [parameters.events.batchEnd] - Training batch end event handler.
     */
    function PlanTrainer(_ref) {
      var worker = _ref.worker,
          plan = _ref.plan,
          inputs = _ref.inputs,
          outputs = _ref.outputs,
          model = _ref.model,
          data = _ref.data,
          target = _ref.target,
          epochs = _ref.epochs,
          batchSize = _ref.batchSize,
          _ref$stepsPerEpoch = _ref.stepsPerEpoch,
          stepsPerEpoch = _ref$stepsPerEpoch === void 0 ? null : _ref$stepsPerEpoch,
          _ref$clientConfig = _ref.clientConfig,
          clientConfig = _ref$clientConfig === void 0 ? {} : _ref$clientConfig,
          _ref$checkpoint = _ref.checkpoint,
          checkpoint = _ref$checkpoint === void 0 ? null : _ref$checkpoint,
          _ref$events = _ref.events,
          events = _ref$events === void 0 ? {} : _ref$events;

      classCallCheck(this, PlanTrainer);

      this.worker = worker;
      this.plan = plan;
      this.planInputs = inputs;
      this.planOutputs = outputs;
      this.originalModel = model;
      this.data = data;
      this.target = target;
      this.epochs = epochs || 1;
      this.batchSize = data instanceof DataLoader ? data.batchSize : batchSize;
      this.stepsPerEpoch = stepsPerEpoch;
      this.clientConfig = clientConfig;
      this.events = events;
      this.logger = new Logger();
      this.observer = new EventObserver(); // State

      this.currentModel = null;
      this.epoch = 0;
      this.batchIdx = 0;
      this.stopped = false; // Register event handlers.

      if (events && _typeof_1(events) === 'object') {
        for (var _i = 0, _Object$keys = Object.keys(events); _i < _Object$keys.length; _i++) {
          var eventName = _Object$keys[_i];
          this.on(eventName, events[eventName]);
        }
      }

      if (checkpoint) {
        this.applyCheckpoint(checkpoint);
      }
    }
    /**
     * Registers an event listener to the PlanTrainer's event observer.
     *
     * Available events: `start`, `end`, `epochStart`, `epochEnd`, `batchStart`, `batchEnd`.
     *
     * @param {string} event - Event name.
     * @param {Function} handler - Event listener.
     */


    createClass(PlanTrainer, [{
      key: "on",
      value: function on(event, handler) {
        var events = [PlanTrainer.EVENT_TRAINING_START, PlanTrainer.EVENT_TRAINING_END, PlanTrainer.EVENT_TRAINING_STOP, PlanTrainer.EVENT_EPOCH_START, PlanTrainer.EVENT_EPOCH_END, PlanTrainer.EVENT_BATCH_START, PlanTrainer.EVENT_BATCH_END];

        if (events.includes(event)) {
          this.observer.subscribe(event, handler.bind(this));
        }
      }
      /**
       * Starts the training loop.
       *
       * @fires PlanTrainer#start
       * @fires PlanTrainer#end
       * @fires PlanTrainer#stop
       * @fires PlanTrainer#epochStart
       * @fires PlanTrainer#epochEnd
       * @fires PlanTrainer#batchStart
       * @fires PlanTrainer#batchEnd
       */

    }, {
      key: "start",
      value: function () {
        var _start = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var resume,
              startEpoch,
              startBatch,
              startModel,
              modelParams,
              epoch,
              batch,
              _this$plan,
              argData,
              planArgs,
              planRawOutput,
              output,
              updatedModelParams,
              i,
              status,
              _i2,
              _Object$keys2,
              metric,
              _args = arguments;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  resume = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;
                  startEpoch = 0;
                  startBatch = 0;
                  startModel = this.originalModel;

                  if (this.stopped && resume) {
                    this.stopped = false;
                    startEpoch = this.epoch;
                    startBatch = this.batchIdx;
                    startModel = this.currentModel;
                  } // Copy model params to preserve original.


                  modelParams = startModel.params.map(function (p) {
                    return p.clone();
                  });
                  /**
                   * `start` event.
                   * Triggered on training start.
                   * @event PlanTrainer#start
                   * @type {Object}
                   */

                  this.observer.broadcast(PlanTrainer.EVENT_TRAINING_START, {}); // Main training loop.

                  epoch = startEpoch;

                case 8:
                  if (!(epoch < this.epochs)) {
                    _context.next = 61;
                    break;
                  }

                  this.epoch = epoch;
                  this.batchIdx = startBatch; // Reset start batch after it is used

                  startBatch = 0;
                  /**
                   * `epochStart` event.
                   * Triggered before epoch start.
                   * @event PlanTrainer#epochStart
                   * @type {Object}
                   * @property {number} epoch - Current epoch.
                   */

                  this.observer.broadcast(PlanTrainer.EVENT_EPOCH_START, {
                    epoch: epoch
                  });

                  if (!this._isStopped()) {
                    _context.next = 15;
                    break;
                  }

                  return _context.abrupt("return");

                case 15:
                  batch = void 0;

                case 16:
                  if (!((batch = this._nextBatch()) !== undefined)) {
                    _context.next = 57;
                    break;
                  }

                  /**
                   * `batchStart` event.
                   * Triggered before batch start.
                   * @event PlanTrainer#batchStart
                   * @type {Object}
                   * @property {number} epoch - Current epoch.
                   * @property {number} batch - Current batch.
                   */
                  this.observer.broadcast(PlanTrainer.EVENT_BATCH_START, {
                    epoch: epoch,
                    batch: this.batchIdx
                  });

                  if (!this._isStopped()) {
                    _context.next = 20;
                    break;
                  }

                  return _context.abrupt("return");

                case 20:
                  // Prepare data for Plan arguments
                  argData = {};
                  argData[PlanInputSpec.TYPE_BATCH_SIZE] = this.batchSize;
                  argData[PlanInputSpec.TYPE_MODEL_PARAM] = modelParams;
                  argData[PlanInputSpec.TYPE_CLIENT_CONFIG_PARAM] = this.clientConfig;

                  if (this.data instanceof DataLoader) {
                    argData[PlanInputSpec.TYPE_DATA] = batch;
                  } else {
                    argData[PlanInputSpec.TYPE_DATA] = batch[0];
                    argData[PlanInputSpec.TYPE_TARGET] = batch[1];
                  } // Execute the Plan


                  planArgs = PlanInputSpec.resolve(this.planInputs, argData);
                  _context.next = 28;
                  return (_this$plan = this.plan).execute.apply(_this$plan, [this.worker].concat(toConsumableArray(planArgs)));

                case 28:
                  planRawOutput = _context.sent;
                  output = PlanOutputSpec.resolve(this.planOutputs, planRawOutput); // Set updated model params for the next run.

                  if (Object.hasOwnProperty.call(output, PlanOutputSpec.TYPE_MODEL_PARAM)) {
                    updatedModelParams = output[PlanOutputSpec.TYPE_MODEL_PARAM];

                    for (i = 0; i < updatedModelParams.length; i++) {
                      modelParams[i].dispose();
                      modelParams[i] = updatedModelParams[i];
                    }
                  } // Update current model.


                  this.currentModel = new SyftModel({
                    worker: this.worker,
                    modelParameters: modelParams
                  }); // Populate loss/metrics into status.

                  status = {
                    epoch: epoch,
                    batch: this.batchIdx
                  };

                  if (!Object.hasOwnProperty.call(output, PlanOutputSpec.TYPE_LOSS)) {
                    _context.next = 37;
                    break;
                  }

                  _context.next = 36;
                  return output[PlanOutputSpec.TYPE_LOSS].array();

                case 36:
                  status['loss'] = _context.sent;

                case 37:
                  if (!Object.hasOwnProperty.call(output, PlanOutputSpec.TYPE_METRIC)) {
                    _context.next = 48;
                    break;
                  }

                  status['metrics'] = {};
                  _i2 = 0, _Object$keys2 = Object.keys(output[PlanOutputSpec.TYPE_METRIC]);

                case 40:
                  if (!(_i2 < _Object$keys2.length)) {
                    _context.next = 48;
                    break;
                  }

                  metric = _Object$keys2[_i2];
                  _context.next = 44;
                  return output[PlanOutputSpec.TYPE_METRIC][metric].array();

                case 44:
                  status['metrics'][metric] = _context.sent;

                case 45:
                  _i2++;
                  _context.next = 40;
                  break;

                case 48:
                  // Free mem.
                  batch.map(function (item) {
                    return item.dispose();
                  });
                  /**
                   * `batchEnd` event.
                   * Triggered after batch end.
                   * @event PlanTrainer#batchEnd
                   * @type {Object}
                   * @property {number} epoch - Current epoch.
                   * @property {number} batch - Current batch.
                   * @property {number} [loss] - Batch loss.
                   * @property {Object} [metrics] - Dictionary containing metrics (if any defined in the `outputs`).
                   */

                  this.observer.broadcast(PlanTrainer.EVENT_BATCH_END, status); // Process other browser events.

                  _context.next = 52;
                  return tf.nextFrame();

                case 52:
                  if (!(typeof this.stepsPerEpoch === 'number' && this.batchIdx >= this.stepsPerEpoch)) {
                    _context.next = 54;
                    break;
                  }

                  return _context.abrupt("break", 57);

                case 54:
                  this.batchIdx++;
                  _context.next = 16;
                  break;

                case 57:
                  /**
                   * `epochEnd` event.
                   * Triggered after epoch end.
                   * @event PlanTrainer#epochEnd
                   * @property {number} epoch - Current epoch.
                   */
                  this.observer.broadcast(PlanTrainer.EVENT_EPOCH_END, {
                    epoch: epoch
                  });

                case 58:
                  epoch++;
                  _context.next = 8;
                  break;

                case 61:
                  /**
                   * `end` event.
                   * Triggered after training end.
                   * @event PlanTrainer#end
                   */
                  this.observer.broadcast(PlanTrainer.EVENT_TRAINING_END, {});

                case 62:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function start() {
          return _start.apply(this, arguments);
        }

        return start;
      }()
      /**
       * @private
       */

    }, {
      key: "_isStopped",
      value: function _isStopped() {
        // Stop training
        if (this.stopped) {
          /**
           * `stop` event.
           * Triggered when training was stopped.
           * @event PlanTrainer#stop
           * @property {Object}
           */
          this.observer.broadcast(PlanTrainer.EVENT_TRAINING_STOP, {});
          return true;
        }

        return false;
      }
      /**
       * Returns the next batch of data from DataLoader or tensor.
       * @return {tf.Tensor[]|undefined}
       * @private
       */

    }, {
      key: "_nextBatch",
      value: function _nextBatch() {
        if (this.data instanceof DataLoader) {
          if (!this.dataIterator) {
            this.dataIterator = this.data[Symbol.iterator]();
          } // Stop if current batch is larger than data length


          if (this.batchIdx >= this.data.length) {
            return undefined;
          }

          return this.dataIterator.next().value;
        } else {
          // Number of batches in data
          var numBatches = Math.floor(this.data.shape[0] / this.batchSize); // Stop if current batch is larger than data length

          if (this.batchIdx >= numBatches) {
            return undefined;
          } // Slice a batch.


          var dataBatch = tf.slice(this.data, this.batchIdx * this.batchSize, this.batchSize);
          var targetBatch = tf.slice(this.target, this.batchIdx * this.batchSize, this.batchSize);
          return [dataBatch, targetBatch];
        }
      }
      /**
       * Stops training loop and returns training checkpoint.
       *
       * @returns {Promise<PlanTrainerCheckpoint>}
       */

    }, {
      key: "stop",
      value: function stop() {
        var _this = this;

        return new Promise(function (resolve) {
          _this.observer.subscribe(PlanTrainer.EVENT_TRAINING_STOP, function () {
            resolve(_this.createCheckpoint());
          }, 1);

          _this.stopped = true;
        });
      }
      /**
       * Resume stopped training process.
       */

    }, {
      key: "resume",
      value: function () {
        var _resume = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!this.stopped) {
                    _context2.next = 3;
                    break;
                  }

                  _context2.next = 3;
                  return this.start(true);

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function resume() {
          return _resume.apply(this, arguments);
        }

        return resume;
      }()
      /**
       * Creates checkpoint using current training state.
       *
       * @return {PlanTrainerCheckpoint}
       */

    }, {
      key: "createCheckpoint",
      value: function createCheckpoint() {
        return new PlanTrainerCheckpoint({
          epochs: this.epochs,
          stepsPerEpoch: this.stepsPerEpoch,
          batchSize: this.batchSize,
          clientConfig: this.clientConfig,
          originalModel: this.originalModel,
          epoch: this.epoch,
          batch: this.batchIdx,
          currentModel: this.currentModel
        });
      }
      /**
       * Restores `PlanTrainer` state from checkpoint.
       *
       * @param {PlanTrainerCheckpoint} checkpoint
       */

    }, {
      key: "applyCheckpoint",
      value: function applyCheckpoint(checkpoint) {
        // Set values from checkpoint
        this.epochs = checkpoint.epochs;
        this.epoch = checkpoint.epoch;
        this.stepsPerEpoch = checkpoint.stepsPerEpoch;
        this.batchIdx = checkpoint.batch;
        this.batchSize = checkpoint.batchSize;
        this.currentModel = checkpoint.currentModel;
        this.clientConfig = checkpoint.clientConfig; // Mark training as stopped

        this.stopped = true;
      }
    }]);

    return PlanTrainer;
  }();
  /**
   * Object that stores `PlanTrainer` state, to resume training from it.
   *
   * @param {Object} parameters - Dictionary of parameters
   * @param {number} parameters.epochs - Total number of epochs
   * @param {number} [parameters.stepsPerEpoch] - Max steps per epoch
   * @param {number} parameters.batchSize - Batch size
   * @param {Object} parameters.clientConfig - Client config
   * @param {number} parameters.epoch - Current epoch
   * @param {number} parameters.batch - Current batch number
   * @param {SyftModel} parameters.currentModel - Current state of the Model
   */

  defineProperty(PlanTrainer, "EVENT_TRAINING_START", 'start');

  defineProperty(PlanTrainer, "EVENT_TRAINING_END", 'end');

  defineProperty(PlanTrainer, "EVENT_TRAINING_STOP", 'stop');

  defineProperty(PlanTrainer, "EVENT_EPOCH_START", 'epochStart');

  defineProperty(PlanTrainer, "EVENT_EPOCH_END", 'epochEnd');

  defineProperty(PlanTrainer, "EVENT_BATCH_START", 'batchStart');

  defineProperty(PlanTrainer, "EVENT_BATCH_END", 'batchEnd');

  var PlanTrainerCheckpoint = /*#__PURE__*/function () {
    function PlanTrainerCheckpoint(_ref2) {
      var epochs = _ref2.epochs,
          stepsPerEpoch = _ref2.stepsPerEpoch,
          batchSize = _ref2.batchSize,
          clientConfig = _ref2.clientConfig,
          epoch = _ref2.epoch,
          batch = _ref2.batch,
          currentModel = _ref2.currentModel;

      classCallCheck(this, PlanTrainerCheckpoint);

      this.epochs = epochs;
      this.stepsPerEpoch = stepsPerEpoch;
      this.batchSize = batchSize;
      this.clientConfig = clientConfig;
      this.epoch = epoch;
      this.batch = batch;
      this.currentModel = currentModel;
    }
    /**
     * Returns `PlanTrainerCheckpoint` serialized to plain Object.
     *
     * @return {Promise<Object>}
     */


    createClass(PlanTrainerCheckpoint, [{
      key: "toJSON",
      value: function () {
        var _toJSON = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.t0 = this.epochs;
                  _context3.t1 = this.stepsPerEpoch;
                  _context3.t2 = this.batchSize;
                  _context3.t3 = this.clientConfig || {};
                  _context3.t4 = this.epoch;
                  _context3.t5 = this.batch;
                  _context3.t6 = base64Encode;
                  _context3.next = 9;
                  return this.currentModel.toProtobuf();

                case 9:
                  _context3.t7 = _context3.sent;
                  _context3.t8 = (0, _context3.t6)(_context3.t7);
                  return _context3.abrupt("return", {
                    epochs: _context3.t0,
                    stepsPerEpoch: _context3.t1,
                    batchSize: _context3.t2,
                    clientConfig: _context3.t3,
                    epoch: _context3.t4,
                    batch: _context3.t5,
                    currentModelBase64: _context3.t8
                  });

                case 12:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function toJSON() {
          return _toJSON.apply(this, arguments);
        }

        return toJSON;
      }()
      /**
       * Creates `PlanTrainerCheckpoint` from object.
       *
       * @param {Syft} worker - Syft Worker
       * @param {Object} obj - Object containing checkpoint data
       * @return {PlanTrainerCheckpoint}
       */

    }], [{
      key: "fromJSON",
      value: function fromJSON(worker, obj) {
        var currentModel = new SyftModel({
          worker: worker,
          serializedModelParameters: base64Decode(obj.currentModelBase64)
        });
        return new PlanTrainerCheckpoint(_objectSpread(_objectSpread({}, obj), {}, {
          currentModel: currentModel
        }));
      }
    }]);

    return PlanTrainerCheckpoint;
  }();

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Job represents a single training cycle done by the client.
   *
   * @property {Object.<string, Plan>} plans - Plans dictionary.
   * @property {Object.<string, Protocol>} protocols - [not implemented] Protocols dictionary.
   * @property {SyftModel} model - Model.
   */

  var Job = /*#__PURE__*/function () {
    /**
     * @hideconstructor
     * @param {object} options
     * @param {Syft} options.worker - Instance of Syft client.
     * @param {string} options.modelName - Model name.
     * @param {string} options.modelVersion - Model version.
     * @param {string} options.authToken - Authentication token for the model.
     * @param {GridAPIClient} options.gridClient - Instance of GridAPIClient.
     */
    function Job(_ref) {
      var worker = _ref.worker,
          modelName = _ref.modelName,
          modelVersion = _ref.modelVersion,
          authToken = _ref.authToken,
          gridClient = _ref.gridClient;

      classCallCheck(this, Job);

      this.worker = worker;
      this.modelName = modelName;
      this.modelVersion = modelVersion;
      this.authToken = authToken;
      this.grid = gridClient;
      this.logger = new Logger();
      this.observer = new EventObserver(); // Parameters to be loaded from PyGrid

      this.worker_id = null;
      this.requires_speed_test = false;
      this.model = null;
      this.plans = {};
      this.protocols = {}; // Parameter for hosting request_key

      this.cycleParams = {};
      this.clientConfig = {};
    }
    /**
     * Registers an event listener to the Job's event observer.
     *
     * Available events: `accepted`, `rejected`, `error`.
     *
     * @param {string} event - Event name.
     * @param {Function} handler - Event listener.
     */


    createClass(Job, [{
      key: "on",
      value: function on(event, handler) {
        if (['accepted', 'rejected', 'error'].includes(event)) {
          this.observer.subscribe(event, handler.bind(this));
        }
      }
      /**
       * Initializes the Job with provided training cycle params and
       * downloads the model, plans, and protocols from PyGrid.
       *
       * @private
       * @param {Object} cycleParams
       * @returns {Promise<void>}
       */

    }, {
      key: "initCycle",
      value: function () {
        var _initCycle = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(cycleParams) {
          var modelData, _i, _Object$keys, planName, planId, planBinary, _i2, _Object$keys2, protocolName, protocolId, protocolBinary;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.logger.log("Cycle initialization with params: ".concat(JSON.stringify(cycleParams)));
                  this.cycleParams = cycleParams;
                  this.clientConfig = cycleParams.client_config; // Load model

                  _context.next = 5;
                  return this.grid.getModel(this.worker_id, cycleParams.request_key, cycleParams.model_id);

                case 5:
                  modelData = _context.sent;
                  this.model = new SyftModel({
                    worker: this.worker,
                    serializedModelParameters: modelData
                  }); // Load all plans

                  _i = 0, _Object$keys = Object.keys(cycleParams.plans);

                case 8:
                  if (!(_i < _Object$keys.length)) {
                    _context.next = 24;
                    break;
                  }

                  planName = _Object$keys[_i];
                  planId = cycleParams.plans[planName];
                  _context.next = 13;
                  return this.grid.getPlan(this.worker_id, cycleParams.request_key, planId);

                case 13:
                  planBinary = _context.sent;
                  _context.prev = 14;
                  this.plans[planName] = unserialize(this.worker, planBinary, protobuf$1.syft_proto.execution.v1.Plan);
                  _context.next = 21;
                  break;

                case 18:
                  _context.prev = 18;
                  _context.t0 = _context["catch"](14);
                  throw new PlanLoadFailedError(planName, _context.t0.message);

                case 21:
                  _i++;
                  _context.next = 8;
                  break;

                case 24:
                  _i2 = 0, _Object$keys2 = Object.keys(cycleParams.protocols);

                case 25:
                  if (!(_i2 < _Object$keys2.length)) {
                    _context.next = 35;
                    break;
                  }

                  protocolName = _Object$keys2[_i2];
                  protocolId = cycleParams.protocols[protocolName];
                  _context.next = 30;
                  return this.grid.getProtocol(this.worker_id, cycleParams.request_key, protocolId);

                case 30:
                  protocolBinary = _context.sent;
                  this.protocols[protocolName] = unserialize(this.worker, protocolBinary, protobuf$1.syft_proto.execution.v1.Protocol);

                case 32:
                  _i2++;
                  _context.next = 25;
                  break;

                case 35:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[14, 18]]);
        }));

        function initCycle(_x) {
          return _initCycle.apply(this, arguments);
        }

        return initCycle;
      }()
      /**
       * Starts the Job by executing following actions:
       *  * Authenticates for given FL model.
       *  * Meters connection speed to PyGrid (if requested by PyGrid).
       *  * Registers into training cycle on PyGrid.
       *  * Retrieves cycle and client parameters.
       *  * Downloads the model, plans, protocols from PyGrid.
       *  * Fires `accepted` event on success.
       *
       * @fires Job#accepted
       * @fires Job#rejected
       * @fires Job#error
       * @returns {Promise<void>}
       */

    }, {
      key: "start",
      value: function () {
        var _start = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var cycleParams, authResponse, ping, download, upload, _yield$this$grid$getC;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  _context2.next = 3;
                  return this.grid.authenticate(this.modelName, this.modelVersion, this.authToken);

                case 3:
                  authResponse = _context2.sent;
                  this.worker_id = authResponse.worker_id; // True if PyGrid requested to meter the speed

                  this.requires_speed_test = authResponse.requires_speed_test || false;
                  ping = 0, download = 0, upload = 0; // Test connection speed if required

                  if (!this.requires_speed_test) {
                    _context2.next = 14;
                    break;
                  }

                  _context2.next = 10;
                  return this.grid.getConnectionSpeed(this.worker_id);

                case 10:
                  _yield$this$grid$getC = _context2.sent;
                  ping = _yield$this$grid$getC.ping;
                  download = _yield$this$grid$getC.download;
                  upload = _yield$this$grid$getC.upload;

                case 14:
                  _context2.next = 16;
                  return this.grid.requestCycle(this.worker_id, this.modelName, this.modelVersion, ping, download, upload);

                case 16:
                  cycleParams = _context2.sent;

                  if (!(cycleParams.status === CYCLE_STATUS_ACCEPTED)) {
                    _context2.next = 21;
                    break;
                  }

                  this.logger.log("Accepted into cycle with params: ".concat(JSON.stringify(cycleParams, null, 2)));
                  _context2.next = 21;
                  return this.initCycle(cycleParams);

                case 21:
                  if ([CYCLE_STATUS_ACCEPTED, CYCLE_STATUS_REJECTED].includes(cycleParams.status)) {
                    _context2.next = 23;
                    break;
                  }

                  throw new GridUnknownCycleStatusError(cycleParams.status);

                case 23:
                  _context2.next = 29;
                  break;

                case 25:
                  _context2.prev = 25;
                  _context2.t0 = _context2["catch"](0);

                  /**
                   * `error` event.
                   * Triggered for plethora of error conditions.
                   *
                   * @event Job#error
                   */
                  this.observer.broadcast('error', _context2.t0);
                  return _context2.abrupt("return");

                case 29:
                  _context2.t1 = cycleParams.status;
                  _context2.next = _context2.t1 === CYCLE_STATUS_ACCEPTED ? 32 : _context2.t1 === CYCLE_STATUS_REJECTED ? 34 : 37;
                  break;

                case 32:
                  /**
                   * `accepted` event.
                   * Triggered when PyGrid accepts the client into training cycle.
                   *
                   * @event Job#accepted
                   * @type {Object}
                   * @property {SyftModel} model - Instance of SyftModel.
                   * @property {Object} clientConfig - Client configuration returned by PyGrid.
                   */
                  this.observer.broadcast('accepted', {
                    model: this.model,
                    clientConfig: this.clientConfig
                  });
                  return _context2.abrupt("break", 37);

                case 34:
                  this.logger.log("Rejected from cycle with timeout: ".concat(cycleParams.timeout));
                  /**
                   * `rejected` event.
                   * Triggered when PyGrid rejects the client.
                   *
                   * @event Job#rejected
                   * @type {Object}
                   * @property {number|null} timeout - Time in seconds to retry. Empty when the FL model is not trainable anymore.
                   */

                  this.observer.broadcast('rejected', {
                    timeout: cycleParams.timeout
                  });
                  return _context2.abrupt("break", 37);

                case 37:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this, [[0, 25]]);
        }));

        function start() {
          return _start.apply(this, arguments);
        }

        return start;
      }()
      /**
       * Alias for `Job.start`
       *
       * @see Job.start
       * @returns {Promise<void>}
       */

    }, {
      key: "request",
      value: function () {
        var _request = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", this.start());

                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function request() {
          return _request.apply(this, arguments);
        }

        return request;
      }()
      /**
       * Submits the model diff to PyGrid.
       *
       * @param {ArrayBuffer} diff - Serialized difference between original and trained model parameters.
       * @returns {Promise<void>}
       */

    }, {
      key: "report",
      value: function () {
        var _report = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(diff) {
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return this.grid.submitReport(this.worker_id, this.cycleParams.request_key, base64Encode(diff));

                case 2:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function report(_x2) {
          return _report.apply(this, arguments);
        }

        return report;
      }()
      /**
       * Trains the model against specified plan and using specified parameters.
       * Returns `PlanTrainer` object to have a handle on training process.
       *
       * @param {string} trainingPlan - Training Plan name.
       * @param {Object} parameters - Dictionary of training parameters.
       * @param {[PlanInputSpec]}  parameters.inputs - List of training Plan input arguments
       * @param {[PlanOutputSpec]} parameters.outputs - List of training Plan outputs
       * @param {tf.Tensor} parameters.data - Tensor containing training data
       * @param {tf.Tensor} parameters.target - Tensor containing training targets
       * @param {number} [parameters.epochs] - Epochs to train (if not specified, taken from Job)
       * @param {number} [parameters.batchSize] - Batch size (if not specified, taken from Job)
       * @param {number} [parameters.stepsPerEpoch] - Max number of steps per epoch (if not specified, taken from Job)
       * @param {PlanTrainerCheckpoint} [parameters.checkpoint] - Checkpoint
       * @param {Object} [parameters.events] - List of event listeners
       * @param {Function} [parameters.events.start] - On training start listener
       * @param {Function} [parameters.events.end] - On training end listener
       * @param {Function} [parameters.events.epochStart] - On epoch start listener
       * @param {Function} [parameters.events.epochEnd] - On epoch end listener
       * @param {Function} [parameters.events.batchStart] - On batch start listener
       * @param {Function} [parameters.events.batchEnd] - On batch end listener
       * @returns {PlanTrainer}
       */

    }, {
      key: "train",
      value: function train(trainingPlan, parameters) {
        var trainingParams = _objectSpread$1({
          clientConfig: this.clientConfig,
          batchSize: this.clientConfig.batch_size,
          epochs: this.clientConfig.max_epochs || 1,
          stepsPerEpoch: this.clientConfig.max_updates || null
        }, parameters);

        var trainer = new PlanTrainer(_objectSpread$1({
          worker: this.worker,
          plan: this.plans[trainingPlan],
          model: this.model
        }, trainingParams)); // For convenience of assigning event handlers, start training in the next macrotask

        setTimeout(function () {
          trainer.start(typeof parameters.checkpoint !== 'undefined');
        }, 0);
        return trainer;
      }
    }]);

    return Job;
  }();

  /**
   * Syft client for model-centric federated learning.
   *
   * @param {Object} options
   * @param {string} options.url - Full URL to PyGrid app (`ws` and `http` schemas supported).
   * @param {boolean} options.verbose - Whether to enable logging and allow unsecured PyGrid connection.
   * @param {Object} options.peerConfig - [not implemented] WebRTC peer config used with RTCPeerConnection.
   *
   * @example
   *
   * const client = new Syft({url: "ws://localhost:5000", verbose: true})
   * const job = client.newJob({modelName: "mnist", modelVersion: "1.0.0"})
   * job.on('accepted', async ({model, clientConfig}) => {
   *   // Execute training
   *   const training = this.train('...', { ... })
   *   training.on('end', async () => {
   *     const diff = await model.createSerializedDiffFromModel(training.currentModel)
   *     await this.report(diff)
   *   }
   * })
   * job.on('rejected', ({timeout}) => {
   *   // Retry later or stop
   * })
   * job.on('error', (err) => {
   *   // Handle errors
   * })
   * job.request()
   */

  var Syft = /*#__PURE__*/function () {
    function Syft(_ref) {
      var url = _ref.url,
          verbose = _ref.verbose,
          peerConfig = _ref.peerConfig;

      classCallCheck(this, Syft);

      // Create verbose logging if verbose value is true
      this.logger = new Logger('syft.js', verbose); // Force connection to be secure if verbose value is false

      this.verbose = verbose;
      this.gridClient = new GridAPIClient({
        url: url,
        allowInsecureUrl: verbose
      }); // Create objects registry

      this.objects = new ObjectRegistry(); // Create event listeners

      this.observer = new EventObserver();
      this.peerConfig = peerConfig;
    }
    /**
     * Instantiates the new Job with given options.
     *
     * @param {Object} options
     * @param {string} options.modelName - FL Model name.
     * @param {string} options.modelVersion - FL Model version.
     * @param {string} options.authToken - FL Model authentication token.
     * @returns {Job}
     */


    createClass(Syft, [{
      key: "newJob",
      value: function newJob(_ref2) {
        var modelName = _ref2.modelName,
            modelVersion = _ref2.modelVersion,
            authToken = _ref2.authToken;
        return new Job({
          worker: this,
          modelName: modelName,
          modelVersion: modelVersion,
          authToken: authToken,
          gridClient: this.gridClient
        });
      }
    }]);

    return Syft;
  }();

  exports.CYCLE_STATUS_ACCEPTED = CYCLE_STATUS_ACCEPTED;
  exports.CYCLE_STATUS_REJECTED = CYCLE_STATUS_REJECTED;
  exports.GET_PROTOCOL = GET_PROTOCOL;
  exports.PlanInputSpec = PlanInputSpec;
  exports.PlanOutputSpec = PlanOutputSpec;
  exports.PlanTrainerCheckpoint = PlanTrainerCheckpoint;
  exports.SOCKET_PING = SOCKET_PING;
  exports.SOCKET_STATUS = SOCKET_STATUS;
  exports.Syft = Syft;
  exports.WEBRTC_DATACHANNEL_BUFFER_TIMEOUT = WEBRTC_DATACHANNEL_BUFFER_TIMEOUT;
  exports.WEBRTC_DATACHANNEL_CHUNK_SIZE = WEBRTC_DATACHANNEL_CHUNK_SIZE;
  exports.WEBRTC_DATACHANNEL_MAX_BUFFER = WEBRTC_DATACHANNEL_MAX_BUFFER;
  exports.WEBRTC_DATACHANNEL_MAX_BUFFER_TIMEOUTS = WEBRTC_DATACHANNEL_MAX_BUFFER_TIMEOUTS;
  exports.WEBRTC_INTERNAL_MESSAGE = WEBRTC_INTERNAL_MESSAGE;
  exports.WEBRTC_JOIN_ROOM = WEBRTC_JOIN_ROOM;
  exports.WEBRTC_PEER_CONFIG = WEBRTC_PEER_CONFIG;
  exports.WEBRTC_PEER_LEFT = WEBRTC_PEER_LEFT;
  exports.WEBRTC_PEER_OPTIONS = WEBRTC_PEER_OPTIONS;
  exports.data = index$3;
  exports.default = Syft;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
